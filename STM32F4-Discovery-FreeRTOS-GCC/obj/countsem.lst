   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"countsem.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xErrorDetected,"aw",%nobits
  20              		.align	2
  23              	xErrorDetected:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xParameters,"aw",%nobits
  26              		.align	2
  29              	xParameters:
  30 0000 00000000 		.space	24
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.rodata
  32              		.align	2
  33              	.LC0:
  34 0000 436F756E 		.ascii	"Counting_Sem_1\000"
  34      74696E67 
  34      5F53656D 
  34      5F3100
  35 000f 00       		.align	2
  36              	.LC1:
  37 0010 436F756E 		.ascii	"Counting_Sem_2\000"
  37      74696E67 
  37      5F53656D 
  37      5F3200
  38 001f 00       		.align	2
  39              	.LC2:
  40 0020 434E5431 		.ascii	"CNT1\000"
  40      00
  41 0025 000000   		.align	2
  42              	.LC3:
  43 0028 434E5432 		.ascii	"CNT2\000"
  43      00
  44 002d 000000   		.section	.text.vStartCountingSemaphoreTasks,"ax",%progbits
  45              		.align	2
  46              		.global	vStartCountingSemaphoreTasks
  47              		.thumb
  48              		.thumb_func
  50              	vStartCountingSemaphoreTasks:
  51              	.LFB110:
  52              		.file 1 "App/Common/Minimal/countsem.c"
   1:App/Common/Minimal/countsem.c **** /*
   2:App/Common/Minimal/countsem.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/countsem.c ****     All rights reserved
   4:App/Common/Minimal/countsem.c **** 
   5:App/Common/Minimal/countsem.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/countsem.c **** 
   7:App/Common/Minimal/countsem.c ****     ***************************************************************************
   8:App/Common/Minimal/countsem.c ****      *                                                                       *
   9:App/Common/Minimal/countsem.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/countsem.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/countsem.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/countsem.c ****      *                                                                       *
  13:App/Common/Minimal/countsem.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/countsem.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/countsem.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/countsem.c ****      *                                                                       *
  17:App/Common/Minimal/countsem.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/countsem.c ****      *                                                                       *
  19:App/Common/Minimal/countsem.c ****     ***************************************************************************
  20:App/Common/Minimal/countsem.c **** 
  21:App/Common/Minimal/countsem.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/countsem.c **** 
  23:App/Common/Minimal/countsem.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/countsem.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/countsem.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/countsem.c **** 
  27:App/Common/Minimal/countsem.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/countsem.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/countsem.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/countsem.c ****     >>! kernel.
  31:App/Common/Minimal/countsem.c **** 
  32:App/Common/Minimal/countsem.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/countsem.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/countsem.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/countsem.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/countsem.c **** 
  37:App/Common/Minimal/countsem.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/countsem.c **** 
  39:App/Common/Minimal/countsem.c ****     ***************************************************************************
  40:App/Common/Minimal/countsem.c ****      *                                                                       *
  41:App/Common/Minimal/countsem.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/countsem.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/countsem.c ****      *                                                                       *
  44:App/Common/Minimal/countsem.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/countsem.c ****      *                                                                       *
  46:App/Common/Minimal/countsem.c ****     ***************************************************************************
  47:App/Common/Minimal/countsem.c **** 
  48:App/Common/Minimal/countsem.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/countsem.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/countsem.c **** 
  51:App/Common/Minimal/countsem.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/countsem.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/countsem.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/countsem.c **** 
  55:App/Common/Minimal/countsem.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/countsem.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/countsem.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/countsem.c **** 
  59:App/Common/Minimal/countsem.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/countsem.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/countsem.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/countsem.c **** 
  63:App/Common/Minimal/countsem.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/countsem.c **** */
  65:App/Common/Minimal/countsem.c **** 
  66:App/Common/Minimal/countsem.c **** 
  67:App/Common/Minimal/countsem.c **** /* 
  68:App/Common/Minimal/countsem.c ****  * Simple demonstration of the usage of counting semaphore.
  69:App/Common/Minimal/countsem.c ****  */
  70:App/Common/Minimal/countsem.c **** 
  71:App/Common/Minimal/countsem.c **** /* Scheduler include files. */
  72:App/Common/Minimal/countsem.c **** #include "FreeRTOS.h"
  73:App/Common/Minimal/countsem.c **** #include "task.h"
  74:App/Common/Minimal/countsem.c **** #include "semphr.h"
  75:App/Common/Minimal/countsem.c **** 
  76:App/Common/Minimal/countsem.c **** /* Demo program include files. */
  77:App/Common/Minimal/countsem.c **** #include "countsem.h"
  78:App/Common/Minimal/countsem.c **** 
  79:App/Common/Minimal/countsem.c **** /* The maximum count value that the semaphore used for the demo can hold. */
  80:App/Common/Minimal/countsem.c **** #define countMAX_COUNT_VALUE	( 200 )
  81:App/Common/Minimal/countsem.c **** 
  82:App/Common/Minimal/countsem.c **** /* Constants used to indicate whether or not the semaphore should have been
  83:App/Common/Minimal/countsem.c **** created with its maximum count value, or its minimum count value.  These 
  84:App/Common/Minimal/countsem.c **** numbers are used to ensure that the pointers passed in as the task parameters
  85:App/Common/Minimal/countsem.c **** are valid. */
  86:App/Common/Minimal/countsem.c **** #define countSTART_AT_MAX_COUNT	( 0xaa )
  87:App/Common/Minimal/countsem.c **** #define countSTART_AT_ZERO		( 0x55 )
  88:App/Common/Minimal/countsem.c **** 
  89:App/Common/Minimal/countsem.c **** /* Two tasks are created for the test.  One uses a semaphore created with its
  90:App/Common/Minimal/countsem.c **** count value set to the maximum, and one with the count value set to zero. */
  91:App/Common/Minimal/countsem.c **** #define countNUM_TEST_TASKS		( 2 )
  92:App/Common/Minimal/countsem.c **** #define countDONT_BLOCK			( 0 )
  93:App/Common/Minimal/countsem.c **** 
  94:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
  95:App/Common/Minimal/countsem.c **** 
  96:App/Common/Minimal/countsem.c **** /* Flag that will be latched to pdTRUE should any unexpected behaviour be
  97:App/Common/Minimal/countsem.c **** detected in any of the tasks. */
  98:App/Common/Minimal/countsem.c **** static volatile portBASE_TYPE xErrorDetected = pdFALSE;
  99:App/Common/Minimal/countsem.c **** 
 100:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 101:App/Common/Minimal/countsem.c **** 
 102:App/Common/Minimal/countsem.c **** /*
 103:App/Common/Minimal/countsem.c ****  * The demo task.  This simply counts the semaphore up to its maximum value,
 104:App/Common/Minimal/countsem.c ****  * the counts it back down again.  The result of each semaphore 'give' and
 105:App/Common/Minimal/countsem.c ****  * 'take' is inspected, with an error being flagged if it is found not to be
 106:App/Common/Minimal/countsem.c ****  * the expected result.
 107:App/Common/Minimal/countsem.c ****  */
 108:App/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters );
 109:App/Common/Minimal/countsem.c **** 
 110:App/Common/Minimal/countsem.c **** /*
 111:App/Common/Minimal/countsem.c ****  * Utility function to increment the semaphore count value up from zero to
 112:App/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE.
 113:App/Common/Minimal/countsem.c ****  */
 114:App/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 115:App/Common/Minimal/countsem.c **** 
 116:App/Common/Minimal/countsem.c **** /*
 117:App/Common/Minimal/countsem.c ****  * Utility function to decrement the semaphore count value up from 
 118:App/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE to zero.
 119:App/Common/Minimal/countsem.c ****  */
 120:App/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 121:App/Common/Minimal/countsem.c **** 
 122:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 123:App/Common/Minimal/countsem.c **** 
 124:App/Common/Minimal/countsem.c **** /* The structure that is passed into the task as the task parameter. */
 125:App/Common/Minimal/countsem.c **** typedef struct COUNT_SEM_STRUCT
 126:App/Common/Minimal/countsem.c **** {
 127:App/Common/Minimal/countsem.c **** 	/* The semaphore to be used for the demo. */
 128:App/Common/Minimal/countsem.c **** 	xSemaphoreHandle xSemaphore;
 129:App/Common/Minimal/countsem.c **** 
 130:App/Common/Minimal/countsem.c **** 	/* Set to countSTART_AT_MAX_COUNT if the semaphore should be created with
 131:App/Common/Minimal/countsem.c **** 	its count value set to its max count value, or countSTART_AT_ZERO if it
 132:App/Common/Minimal/countsem.c **** 	should have been created with its count value set to 0. */
 133:App/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxExpectedStartCount;	
 134:App/Common/Minimal/countsem.c **** 
 135:App/Common/Minimal/countsem.c **** 	/* Incremented on each cycle of the demo task.  Used to detect a stalled
 136:App/Common/Minimal/countsem.c **** 	task. */
 137:App/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxLoopCounter;			
 138:App/Common/Minimal/countsem.c **** } xCountSemStruct;
 139:App/Common/Minimal/countsem.c **** 
 140:App/Common/Minimal/countsem.c **** /* Two structures are defined, one is passed to each test task. */
 141:App/Common/Minimal/countsem.c **** static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];
 142:App/Common/Minimal/countsem.c **** 
 143:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 144:App/Common/Minimal/countsem.c **** 
 145:App/Common/Minimal/countsem.c **** void vStartCountingSemaphoreTasks( void )
 146:App/Common/Minimal/countsem.c **** {
  53              		.loc 1 146 0
  54              		.cfi_startproc
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 1, uses_anonymous_args = 0
  57 0000 80B5     		push	{r7, lr}
  58              	.LCFI0:
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 7, -8
  61              		.cfi_offset 14, -4
  62 0002 84B0     		sub	sp, sp, #16
  63              	.LCFI1:
  64              		.cfi_def_cfa_offset 24
  65 0004 04AF     		add	r7, sp, #16
  66              	.LCFI2:
  67              		.cfi_def_cfa 7, 8
 147:App/Common/Minimal/countsem.c **** 	/* Create the semaphores that we are going to use for the test/demo.  The
 148:App/Common/Minimal/countsem.c **** 	first should be created such that it starts at its maximum count value,
 149:App/Common/Minimal/countsem.c **** 	the second should be created such that it starts with a count value of zero. */
 150:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
  68              		.loc 1 150 0
  69 0006 C820     		movs	r0, #200
  70 0008 C821     		movs	r1, #200
  71 000a FFF7FEFF 		bl	xQueueCreateCountingSemaphore
  72 000e 0246     		mov	r2, r0
  73 0010 234B     		ldr	r3, .L4
  74 0012 1A60     		str	r2, [r3]
 151:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
  75              		.loc 1 151 0
  76 0014 224B     		ldr	r3, .L4
  77 0016 AA22     		movs	r2, #170
  78 0018 5A60     		str	r2, [r3, #4]
 152:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxLoopCounter = 0;
  79              		.loc 1 152 0
  80 001a 214B     		ldr	r3, .L4
  81 001c 0022     		movs	r2, #0
  82 001e 9A60     		str	r2, [r3, #8]
 153:App/Common/Minimal/countsem.c **** 
 154:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
  83              		.loc 1 154 0
  84 0020 C820     		movs	r0, #200
  85 0022 0021     		movs	r1, #0
  86 0024 FFF7FEFF 		bl	xQueueCreateCountingSemaphore
  87 0028 0246     		mov	r2, r0
  88 002a 1D4B     		ldr	r3, .L4
  89 002c DA60     		str	r2, [r3, #12]
 155:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxExpectedStartCount = 0;
  90              		.loc 1 155 0
  91 002e 1C4B     		ldr	r3, .L4
  92 0030 0022     		movs	r2, #0
  93 0032 1A61     		str	r2, [r3, #16]
 156:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxLoopCounter = 0;
  94              		.loc 1 156 0
  95 0034 1A4B     		ldr	r3, .L4
  96 0036 0022     		movs	r2, #0
  97 0038 5A61     		str	r2, [r3, #20]
 157:App/Common/Minimal/countsem.c **** 
 158:App/Common/Minimal/countsem.c **** 	/* vQueueAddToRegistry() adds the semaphore to the registry, if one is
 159:App/Common/Minimal/countsem.c **** 	in use.  The registry is provided as a means for kernel aware 
 160:App/Common/Minimal/countsem.c **** 	debuggers to locate semaphores and has no purpose if a kernel aware debugger
 161:App/Common/Minimal/countsem.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 162:App/Common/Minimal/countsem.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 163:App/Common/Minimal/countsem.c **** 	defined to be less than 1. */
 164:App/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting
  98              		.loc 1 164 0
  99 003a 194B     		ldr	r3, .L4
 100 003c 1B68     		ldr	r3, [r3]
 101 003e 1846     		mov	r0, r3
 102 0040 1849     		ldr	r1, .L4+4
 103 0042 FFF7FEFF 		bl	vQueueAddToRegistry
 165:App/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting
 104              		.loc 1 165 0
 105 0046 164B     		ldr	r3, .L4
 106 0048 DB68     		ldr	r3, [r3, #12]
 107 004a 1846     		mov	r0, r3
 108 004c 1649     		ldr	r1, .L4+8
 109 004e FFF7FEFF 		bl	vQueueAddToRegistry
 166:App/Common/Minimal/countsem.c **** 
 167:App/Common/Minimal/countsem.c **** 
 168:App/Common/Minimal/countsem.c **** 	/* Were the semaphores created? */
 169:App/Common/Minimal/countsem.c **** 	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 110              		.loc 1 169 0
 111 0052 134B     		ldr	r3, .L4
 112 0054 1B68     		ldr	r3, [r3]
 113 0056 002B     		cmp	r3, #0
 114 0058 03D1     		bne	.L2
 115              		.loc 1 169 0 is_stmt 0 discriminator 1
 116 005a 114B     		ldr	r3, .L4
 117 005c DB68     		ldr	r3, [r3, #12]
 118 005e 002B     		cmp	r3, #0
 119 0060 1BD0     		beq	.L1
 120              	.L2:
 170:App/Common/Minimal/countsem.c **** 	{
 171:App/Common/Minimal/countsem.c **** 		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
 172:App/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( 
 121              		.loc 1 172 0 is_stmt 1
 122 0062 0023     		movs	r3, #0
 123 0064 0093     		str	r3, [sp]
 124 0066 0023     		movs	r3, #0
 125 0068 0193     		str	r3, [sp, #4]
 126 006a 0023     		movs	r3, #0
 127 006c 0293     		str	r3, [sp, #8]
 128 006e 0023     		movs	r3, #0
 129 0070 0393     		str	r3, [sp, #12]
 130 0072 0E48     		ldr	r0, .L4+12
 131 0074 0E49     		ldr	r1, .L4+16
 132 0076 8222     		movs	r2, #130
 133 0078 094B     		ldr	r3, .L4
 134 007a FFF7FEFF 		bl	xTaskGenericCreate
 173:App/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( 
 135              		.loc 1 173 0
 136 007e 0023     		movs	r3, #0
 137 0080 0093     		str	r3, [sp]
 138 0082 0023     		movs	r3, #0
 139 0084 0193     		str	r3, [sp, #4]
 140 0086 0023     		movs	r3, #0
 141 0088 0293     		str	r3, [sp, #8]
 142 008a 0023     		movs	r3, #0
 143 008c 0393     		str	r3, [sp, #12]
 144 008e 0748     		ldr	r0, .L4+12
 145 0090 0849     		ldr	r1, .L4+20
 146 0092 8222     		movs	r2, #130
 147 0094 084B     		ldr	r3, .L4+24
 148 0096 FFF7FEFF 		bl	xTaskGenericCreate
 149              	.L1:
 174:App/Common/Minimal/countsem.c **** 	}
 175:App/Common/Minimal/countsem.c **** }
 150              		.loc 1 175 0
 151 009a BD46     		mov	sp, r7
 152              		@ sp needed
 153 009c 80BD     		pop	{r7, pc}
 154              	.L5:
 155 009e 00BF     		.align	2
 156              	.L4:
 157 00a0 00000000 		.word	xParameters
 158 00a4 00000000 		.word	.LC0
 159 00a8 10000000 		.word	.LC1
 160 00ac 00000000 		.word	prvCountingSemaphoreTask
 161 00b0 20000000 		.word	.LC2
 162 00b4 28000000 		.word	.LC3
 163 00b8 0C000000 		.word	xParameters+12
 164              		.cfi_endproc
 165              	.LFE110:
 167              		.section	.text.prvDecrementSemaphoreCount,"ax",%progbits
 168              		.align	2
 169              		.thumb
 170              		.thumb_func
 172              	prvDecrementSemaphoreCount:
 173              	.LFB111:
 176:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 177:App/Common/Minimal/countsem.c **** 
 178:App/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 179:App/Common/Minimal/countsem.c **** {
 174              		.loc 1 179 0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 16
 177              		@ frame_needed = 1, uses_anonymous_args = 0
 178 0000 80B5     		push	{r7, lr}
 179              	.LCFI3:
 180              		.cfi_def_cfa_offset 8
 181              		.cfi_offset 7, -8
 182              		.cfi_offset 14, -4
 183 0002 84B0     		sub	sp, sp, #16
 184              	.LCFI4:
 185              		.cfi_def_cfa_offset 24
 186 0004 00AF     		add	r7, sp, #0
 187              	.LCFI5:
 188              		.cfi_def_cfa_register 7
 189 0006 7860     		str	r0, [r7, #4]
 190 0008 3960     		str	r1, [r7]
 180:App/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 181:App/Common/Minimal/countsem.c **** 
 182:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 183:App/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 184:App/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 191              		.loc 1 184 0
 192 000a 7868     		ldr	r0, [r7, #4]
 193 000c 0021     		movs	r1, #0
 194 000e 0022     		movs	r2, #0
 195 0010 0023     		movs	r3, #0
 196 0012 FFF7FEFF 		bl	xQueueGenericSend
 197 0016 0346     		mov	r3, r0
 198 0018 012B     		cmp	r3, #1
 199 001a 02D1     		bne	.L7
 185:App/Common/Minimal/countsem.c **** 	{
 186:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 200              		.loc 1 186 0
 201 001c 154B     		ldr	r3, .L12
 202 001e 0122     		movs	r2, #1
 203 0020 1A60     		str	r2, [r3]
 204              	.L7:
 187:App/Common/Minimal/countsem.c **** 	}
 188:App/Common/Minimal/countsem.c **** 
 189:App/Common/Minimal/countsem.c **** 	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 205              		.loc 1 190 0
 206 0022 0023     		movs	r3, #0
 207 0024 FB60     		str	r3, [r7, #12]
 208 0026 13E0     		b	.L8
 209              	.L10:
 191:App/Common/Minimal/countsem.c **** 	{
 192:App/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
 210              		.loc 1 192 0
 211 0028 7868     		ldr	r0, [r7, #4]
 212 002a 0021     		movs	r1, #0
 213 002c 0022     		movs	r2, #0
 214 002e 0023     		movs	r3, #0
 215 0030 FFF7FEFF 		bl	xQueueGenericReceive
 216 0034 0346     		mov	r3, r0
 217 0036 012B     		cmp	r3, #1
 218 0038 02D0     		beq	.L9
 193:App/Common/Minimal/countsem.c **** 		{
 194:App/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 195:App/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 219              		.loc 1 195 0
 220 003a 0E4B     		ldr	r3, .L12
 221 003c 0122     		movs	r2, #1
 222 003e 1A60     		str	r2, [r3]
 223              	.L9:
 196:App/Common/Minimal/countsem.c **** 		}
 197:App/Common/Minimal/countsem.c **** 
 198:App/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 224              		.loc 1 198 0
 225 0040 3B68     		ldr	r3, [r7]
 226 0042 1B68     		ldr	r3, [r3]
 227 0044 5A1C     		adds	r2, r3, #1
 228 0046 3B68     		ldr	r3, [r7]
 229 0048 1A60     		str	r2, [r3]
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 230              		.loc 1 190 0
 231 004a FB68     		ldr	r3, [r7, #12]
 232 004c 0133     		adds	r3, r3, #1
 233 004e FB60     		str	r3, [r7, #12]
 234              	.L8:
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 235              		.loc 1 190 0 is_stmt 0 discriminator 1
 236 0050 FB68     		ldr	r3, [r7, #12]
 237 0052 C72B     		cmp	r3, #199
 238 0054 E8D9     		bls	.L10
 199:App/Common/Minimal/countsem.c **** 	}
 200:App/Common/Minimal/countsem.c **** 
 201:App/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 202:App/Common/Minimal/countsem.c **** 		taskYIELD();
 203:App/Common/Minimal/countsem.c **** 	#endif
 204:App/Common/Minimal/countsem.c **** 
 205:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 206:App/Common/Minimal/countsem.c **** 	the semaphore. */
 207:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 239              		.loc 1 207 0 is_stmt 1
 240 0056 7868     		ldr	r0, [r7, #4]
 241 0058 0021     		movs	r1, #0
 242 005a 0022     		movs	r2, #0
 243 005c 0023     		movs	r3, #0
 244 005e FFF7FEFF 		bl	xQueueGenericReceive
 245 0062 0346     		mov	r3, r0
 246 0064 012B     		cmp	r3, #1
 247 0066 02D1     		bne	.L6
 208:App/Common/Minimal/countsem.c **** 	{
 209:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 248              		.loc 1 209 0
 249 0068 024B     		ldr	r3, .L12
 250 006a 0122     		movs	r2, #1
 251 006c 1A60     		str	r2, [r3]
 252              	.L6:
 210:App/Common/Minimal/countsem.c **** 	}
 211:App/Common/Minimal/countsem.c **** }
 253              		.loc 1 211 0
 254 006e 1037     		adds	r7, r7, #16
 255 0070 BD46     		mov	sp, r7
 256              		@ sp needed
 257 0072 80BD     		pop	{r7, pc}
 258              	.L13:
 259              		.align	2
 260              	.L12:
 261 0074 00000000 		.word	xErrorDetected
 262              		.cfi_endproc
 263              	.LFE111:
 265              		.section	.text.prvIncrementSemaphoreCount,"ax",%progbits
 266              		.align	2
 267              		.thumb
 268              		.thumb_func
 270              	prvIncrementSemaphoreCount:
 271              	.LFB112:
 212:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 213:App/Common/Minimal/countsem.c **** 
 214:App/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 215:App/Common/Minimal/countsem.c **** {
 272              		.loc 1 215 0
 273              		.cfi_startproc
 274              		@ args = 0, pretend = 0, frame = 16
 275              		@ frame_needed = 1, uses_anonymous_args = 0
 276 0000 80B5     		push	{r7, lr}
 277              	.LCFI6:
 278              		.cfi_def_cfa_offset 8
 279              		.cfi_offset 7, -8
 280              		.cfi_offset 14, -4
 281 0002 84B0     		sub	sp, sp, #16
 282              	.LCFI7:
 283              		.cfi_def_cfa_offset 24
 284 0004 00AF     		add	r7, sp, #0
 285              	.LCFI8:
 286              		.cfi_def_cfa_register 7
 287 0006 7860     		str	r0, [r7, #4]
 288 0008 3960     		str	r1, [r7]
 216:App/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 217:App/Common/Minimal/countsem.c **** 
 218:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 219:App/Common/Minimal/countsem.c **** 	the semaphore. */
 220:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 289              		.loc 1 220 0
 290 000a 7868     		ldr	r0, [r7, #4]
 291 000c 0021     		movs	r1, #0
 292 000e 0022     		movs	r2, #0
 293 0010 0023     		movs	r3, #0
 294 0012 FFF7FEFF 		bl	xQueueGenericReceive
 295 0016 0346     		mov	r3, r0
 296 0018 012B     		cmp	r3, #1
 297 001a 02D1     		bne	.L15
 221:App/Common/Minimal/countsem.c **** 	{
 222:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 298              		.loc 1 222 0
 299 001c 154B     		ldr	r3, .L20
 300 001e 0122     		movs	r2, #1
 301 0020 1A60     		str	r2, [r3]
 302              	.L15:
 223:App/Common/Minimal/countsem.c **** 	}
 224:App/Common/Minimal/countsem.c **** 
 225:App/Common/Minimal/countsem.c **** 	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 303              		.loc 1 226 0
 304 0022 0023     		movs	r3, #0
 305 0024 FB60     		str	r3, [r7, #12]
 306 0026 13E0     		b	.L16
 307              	.L18:
 227:App/Common/Minimal/countsem.c **** 	{
 228:App/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 308              		.loc 1 228 0
 309 0028 7868     		ldr	r0, [r7, #4]
 310 002a 0021     		movs	r1, #0
 311 002c 0022     		movs	r2, #0
 312 002e 0023     		movs	r3, #0
 313 0030 FFF7FEFF 		bl	xQueueGenericSend
 314 0034 0346     		mov	r3, r0
 315 0036 012B     		cmp	r3, #1
 316 0038 02D0     		beq	.L17
 229:App/Common/Minimal/countsem.c **** 		{
 230:App/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 231:App/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 317              		.loc 1 231 0
 318 003a 0E4B     		ldr	r3, .L20
 319 003c 0122     		movs	r2, #1
 320 003e 1A60     		str	r2, [r3]
 321              	.L17:
 232:App/Common/Minimal/countsem.c **** 		}
 233:App/Common/Minimal/countsem.c **** 
 234:App/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 322              		.loc 1 234 0
 323 0040 3B68     		ldr	r3, [r7]
 324 0042 1B68     		ldr	r3, [r3]
 325 0044 5A1C     		adds	r2, r3, #1
 326 0046 3B68     		ldr	r3, [r7]
 327 0048 1A60     		str	r2, [r3]
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 328              		.loc 1 226 0
 329 004a FB68     		ldr	r3, [r7, #12]
 330 004c 0133     		adds	r3, r3, #1
 331 004e FB60     		str	r3, [r7, #12]
 332              	.L16:
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 333              		.loc 1 226 0 is_stmt 0 discriminator 1
 334 0050 FB68     		ldr	r3, [r7, #12]
 335 0052 C72B     		cmp	r3, #199
 336 0054 E8D9     		bls	.L18
 235:App/Common/Minimal/countsem.c **** 	}
 236:App/Common/Minimal/countsem.c **** 
 237:App/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 238:App/Common/Minimal/countsem.c **** 		taskYIELD();
 239:App/Common/Minimal/countsem.c **** 	#endif
 240:App/Common/Minimal/countsem.c **** 
 241:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 242:App/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 243:App/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 337              		.loc 1 243 0 is_stmt 1
 338 0056 7868     		ldr	r0, [r7, #4]
 339 0058 0021     		movs	r1, #0
 340 005a 0022     		movs	r2, #0
 341 005c 0023     		movs	r3, #0
 342 005e FFF7FEFF 		bl	xQueueGenericSend
 343 0062 0346     		mov	r3, r0
 344 0064 012B     		cmp	r3, #1
 345 0066 02D1     		bne	.L14
 244:App/Common/Minimal/countsem.c **** 	{
 245:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 346              		.loc 1 245 0
 347 0068 024B     		ldr	r3, .L20
 348 006a 0122     		movs	r2, #1
 349 006c 1A60     		str	r2, [r3]
 350              	.L14:
 246:App/Common/Minimal/countsem.c **** 	}
 247:App/Common/Minimal/countsem.c **** }
 351              		.loc 1 247 0
 352 006e 1037     		adds	r7, r7, #16
 353 0070 BD46     		mov	sp, r7
 354              		@ sp needed
 355 0072 80BD     		pop	{r7, pc}
 356              	.L21:
 357              		.align	2
 358              	.L20:
 359 0074 00000000 		.word	xErrorDetected
 360              		.cfi_endproc
 361              	.LFE112:
 363              		.section	.text.prvCountingSemaphoreTask,"ax",%progbits
 364              		.align	2
 365              		.thumb
 366              		.thumb_func
 368              	prvCountingSemaphoreTask:
 369              	.LFB113:
 248:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 249:App/Common/Minimal/countsem.c **** 
 250:App/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters )
 251:App/Common/Minimal/countsem.c **** {
 370              		.loc 1 251 0
 371              		.cfi_startproc
 372              		@ args = 0, pretend = 0, frame = 16
 373              		@ frame_needed = 1, uses_anonymous_args = 0
 374 0000 80B5     		push	{r7, lr}
 375              	.LCFI9:
 376              		.cfi_def_cfa_offset 8
 377              		.cfi_offset 7, -8
 378              		.cfi_offset 14, -4
 379 0002 84B0     		sub	sp, sp, #16
 380              	.LCFI10:
 381              		.cfi_def_cfa_offset 24
 382 0004 00AF     		add	r7, sp, #0
 383              	.LCFI11:
 384              		.cfi_def_cfa_register 7
 385 0006 7860     		str	r0, [r7, #4]
 252:App/Common/Minimal/countsem.c **** xCountSemStruct *pxParameter;
 253:App/Common/Minimal/countsem.c **** 
 254:App/Common/Minimal/countsem.c **** 	#ifdef USE_STDIO
 255:App/Common/Minimal/countsem.c **** 	void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
 256:App/Common/Minimal/countsem.c **** 	
 257:App/Common/Minimal/countsem.c **** 		const portCHAR * const pcTaskStartMsg = "Counting semaphore demo started.\r\n";
 258:App/Common/Minimal/countsem.c **** 
 259:App/Common/Minimal/countsem.c **** 		/* Queue a message for printing to say the task has started. */
 260:App/Common/Minimal/countsem.c **** 		vPrintDisplayMessage( &pcTaskStartMsg );
 261:App/Common/Minimal/countsem.c **** 	#endif
 262:App/Common/Minimal/countsem.c **** 
 263:App/Common/Minimal/countsem.c **** 	/* The semaphore to be used was passed as the parameter. */
 264:App/Common/Minimal/countsem.c **** 	pxParameter = ( xCountSemStruct * ) pvParameters;
 386              		.loc 1 264 0
 387 0008 7B68     		ldr	r3, [r7, #4]
 388 000a FB60     		str	r3, [r7, #12]
 265:App/Common/Minimal/countsem.c **** 
 266:App/Common/Minimal/countsem.c **** 	/* Did we expect to find the semaphore already at its max count value, or
 267:App/Common/Minimal/countsem.c **** 	at zero? */
 268:App/Common/Minimal/countsem.c **** 	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 389              		.loc 1 268 0
 390 000c FB68     		ldr	r3, [r7, #12]
 391 000e 5B68     		ldr	r3, [r3, #4]
 392 0010 AA2B     		cmp	r3, #170
 393 0012 07D1     		bne	.L23
 269:App/Common/Minimal/countsem.c **** 	{
 270:App/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 394              		.loc 1 270 0
 395 0014 FB68     		ldr	r3, [r7, #12]
 396 0016 1A68     		ldr	r2, [r3]
 397 0018 FB68     		ldr	r3, [r7, #12]
 398 001a 0833     		adds	r3, r3, #8
 399 001c 1046     		mov	r0, r2
 400 001e 1946     		mov	r1, r3
 401 0020 FFF7FEFF 		bl	prvDecrementSemaphoreCount
 402              	.L23:
 271:App/Common/Minimal/countsem.c **** 	}
 272:App/Common/Minimal/countsem.c **** 
 273:App/Common/Minimal/countsem.c **** 	/* Now we expect the semaphore count to be 0, so this time there is an
 274:App/Common/Minimal/countsem.c **** 	error if we can take the semaphore. */
 275:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 403              		.loc 1 275 0
 404 0024 FB68     		ldr	r3, [r7, #12]
 405 0026 1B68     		ldr	r3, [r3]
 406 0028 1846     		mov	r0, r3
 407 002a 0021     		movs	r1, #0
 408 002c 0022     		movs	r2, #0
 409 002e 0023     		movs	r3, #0
 410 0030 FFF7FEFF 		bl	xQueueGenericReceive
 411 0034 0346     		mov	r3, r0
 412 0036 012B     		cmp	r3, #1
 413 0038 02D1     		bne	.L24
 276:App/Common/Minimal/countsem.c **** 	{
 277:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 414              		.loc 1 277 0
 415 003a 0A4B     		ldr	r3, .L25
 416 003c 0122     		movs	r2, #1
 417 003e 1A60     		str	r2, [r3]
 418              	.L24:
 278:App/Common/Minimal/countsem.c **** 	}
 279:App/Common/Minimal/countsem.c **** 
 280:App/Common/Minimal/countsem.c **** 	for( ;; )
 281:App/Common/Minimal/countsem.c **** 	{
 282:App/Common/Minimal/countsem.c **** 		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 419              		.loc 1 282 0 discriminator 1
 420 0040 FB68     		ldr	r3, [r7, #12]
 421 0042 1A68     		ldr	r2, [r3]
 422 0044 FB68     		ldr	r3, [r7, #12]
 423 0046 0833     		adds	r3, r3, #8
 424 0048 1046     		mov	r0, r2
 425 004a 1946     		mov	r1, r3
 426 004c FFF7FEFF 		bl	prvIncrementSemaphoreCount
 283:App/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 427              		.loc 1 283 0 discriminator 1
 428 0050 FB68     		ldr	r3, [r7, #12]
 429 0052 1A68     		ldr	r2, [r3]
 430 0054 FB68     		ldr	r3, [r7, #12]
 431 0056 0833     		adds	r3, r3, #8
 432 0058 1046     		mov	r0, r2
 433 005a 1946     		mov	r1, r3
 434 005c FFF7FEFF 		bl	prvDecrementSemaphoreCount
 284:App/Common/Minimal/countsem.c **** 	}
 435              		.loc 1 284 0 discriminator 1
 436 0060 EEE7     		b	.L24
 437              	.L26:
 438 0062 00BF     		.align	2
 439              	.L25:
 440 0064 00000000 		.word	xErrorDetected
 441              		.cfi_endproc
 442              	.LFE113:
 444              		.section	.text.xAreCountingSemaphoreTasksStillRunning,"ax",%progbits
 445              		.align	2
 446              		.global	xAreCountingSemaphoreTasksStillRunning
 447              		.thumb
 448              		.thumb_func
 450              	xAreCountingSemaphoreTasksStillRunning:
 451              	.LFB114:
 285:App/Common/Minimal/countsem.c **** }
 286:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 287:App/Common/Minimal/countsem.c **** 
 288:App/Common/Minimal/countsem.c **** portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
 289:App/Common/Minimal/countsem.c **** {
 452              		.loc 1 289 0
 453              		.cfi_startproc
 454              		@ args = 0, pretend = 0, frame = 8
 455              		@ frame_needed = 1, uses_anonymous_args = 0
 456              		@ link register save eliminated.
 457 0000 80B4     		push	{r7}
 458              	.LCFI12:
 459              		.cfi_def_cfa_offset 4
 460              		.cfi_offset 7, -4
 461 0002 83B0     		sub	sp, sp, #12
 462              	.LCFI13:
 463              		.cfi_def_cfa_offset 16
 464 0004 00AF     		add	r7, sp, #0
 465              	.LCFI14:
 466              		.cfi_def_cfa_register 7
 290:App/Common/Minimal/countsem.c **** static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
 291:App/Common/Minimal/countsem.c **** portBASE_TYPE xReturn = pdPASS;
 467              		.loc 1 291 0
 468 0006 0123     		movs	r3, #1
 469 0008 7B60     		str	r3, [r7, #4]
 292:App/Common/Minimal/countsem.c **** 
 293:App/Common/Minimal/countsem.c **** 	/* Return fail if any 'give' or 'take' did not result in the expected
 294:App/Common/Minimal/countsem.c **** 	behaviour. */
 295:App/Common/Minimal/countsem.c **** 	if( xErrorDetected != pdFALSE )
 470              		.loc 1 295 0
 471 000a 134B     		ldr	r3, .L34
 472 000c 1B68     		ldr	r3, [r3]
 473 000e 002B     		cmp	r3, #0
 474 0010 01D0     		beq	.L28
 296:App/Common/Minimal/countsem.c **** 	{
 297:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 475              		.loc 1 297 0
 476 0012 0023     		movs	r3, #0
 477 0014 7B60     		str	r3, [r7, #4]
 478              	.L28:
 298:App/Common/Minimal/countsem.c **** 	}
 299:App/Common/Minimal/countsem.c **** 
 300:App/Common/Minimal/countsem.c **** 	/* Return fail if either task is not still incrementing its loop counter. */
 301:App/Common/Minimal/countsem.c **** 	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
 479              		.loc 1 301 0
 480 0016 114B     		ldr	r3, .L34+4
 481 0018 9A68     		ldr	r2, [r3, #8]
 482 001a 114B     		ldr	r3, .L34+8
 483 001c 1B68     		ldr	r3, [r3]
 484 001e 9A42     		cmp	r2, r3
 485 0020 02D1     		bne	.L29
 302:App/Common/Minimal/countsem.c **** 	{
 303:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 486              		.loc 1 303 0
 487 0022 0023     		movs	r3, #0
 488 0024 7B60     		str	r3, [r7, #4]
 489 0026 03E0     		b	.L30
 490              	.L29:
 304:App/Common/Minimal/countsem.c **** 	}
 305:App/Common/Minimal/countsem.c **** 	else
 306:App/Common/Minimal/countsem.c **** 	{
 307:App/Common/Minimal/countsem.c **** 		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
 491              		.loc 1 307 0
 492 0028 0C4B     		ldr	r3, .L34+4
 493 002a 9A68     		ldr	r2, [r3, #8]
 494 002c 0C4B     		ldr	r3, .L34+8
 495 002e 1A60     		str	r2, [r3]
 496              	.L30:
 308:App/Common/Minimal/countsem.c **** 	}
 309:App/Common/Minimal/countsem.c **** 
 310:App/Common/Minimal/countsem.c **** 	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
 497              		.loc 1 310 0
 498 0030 0A4B     		ldr	r3, .L34+4
 499 0032 5A69     		ldr	r2, [r3, #20]
 500 0034 0B4B     		ldr	r3, .L34+12
 501 0036 1B68     		ldr	r3, [r3]
 502 0038 9A42     		cmp	r2, r3
 503 003a 02D1     		bne	.L31
 311:App/Common/Minimal/countsem.c **** 	{
 312:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 504              		.loc 1 312 0
 505 003c 0023     		movs	r3, #0
 506 003e 7B60     		str	r3, [r7, #4]
 507 0040 03E0     		b	.L32
 508              	.L31:
 313:App/Common/Minimal/countsem.c **** 	}
 314:App/Common/Minimal/countsem.c **** 	else
 315:App/Common/Minimal/countsem.c **** 	{
 316:App/Common/Minimal/countsem.c **** 		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
 509              		.loc 1 316 0
 510 0042 064B     		ldr	r3, .L34+4
 511 0044 5A69     		ldr	r2, [r3, #20]
 512 0046 074B     		ldr	r3, .L34+12
 513 0048 1A60     		str	r2, [r3]
 514              	.L32:
 317:App/Common/Minimal/countsem.c **** 	}
 318:App/Common/Minimal/countsem.c **** 
 319:App/Common/Minimal/countsem.c **** 	return xReturn;
 515              		.loc 1 319 0
 516 004a 7B68     		ldr	r3, [r7, #4]
 320:App/Common/Minimal/countsem.c **** }
 517              		.loc 1 320 0
 518 004c 1846     		mov	r0, r3
 519 004e 0C37     		adds	r7, r7, #12
 520 0050 BD46     		mov	sp, r7
 521              		@ sp needed
 522 0052 5DF8047B 		ldr	r7, [sp], #4
 523 0056 7047     		bx	lr
 524              	.L35:
 525              		.align	2
 526              	.L34:
 527 0058 00000000 		.word	xErrorDetected
 528 005c 00000000 		.word	xParameters
 529 0060 00000000 		.word	uxLastCount0.7665
 530 0064 00000000 		.word	uxLastCount1.7666
 531              		.cfi_endproc
 532              	.LFE114:
 534              		.section	.bss.uxLastCount0.7665,"aw",%nobits
 535              		.align	2
 538              	uxLastCount0.7665:
 539 0000 00000000 		.space	4
 540              		.section	.bss.uxLastCount1.7666,"aw",%nobits
 541              		.align	2
 544              	uxLastCount1.7666:
 545 0000 00000000 		.space	4
 546              		.text
 547              	.Letext0:
 548              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 549              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 550              		.file 4 "Source/include/queue.h"
 551              		.file 5 "Source/include/semphr.h"
 552              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 countsem.c
     /tmp/cclkhIaJ.s:20     .bss.xErrorDetected:00000000 $d
     /tmp/cclkhIaJ.s:23     .bss.xErrorDetected:00000000 xErrorDetected
     /tmp/cclkhIaJ.s:26     .bss.xParameters:00000000 $d
     /tmp/cclkhIaJ.s:29     .bss.xParameters:00000000 xParameters
     /tmp/cclkhIaJ.s:32     .rodata:00000000 $d
     /tmp/cclkhIaJ.s:45     .text.vStartCountingSemaphoreTasks:00000000 $t
     /tmp/cclkhIaJ.s:50     .text.vStartCountingSemaphoreTasks:00000000 vStartCountingSemaphoreTasks
     /tmp/cclkhIaJ.s:157    .text.vStartCountingSemaphoreTasks:000000a0 $d
     /tmp/cclkhIaJ.s:368    .text.prvCountingSemaphoreTask:00000000 prvCountingSemaphoreTask
     /tmp/cclkhIaJ.s:168    .text.prvDecrementSemaphoreCount:00000000 $t
     /tmp/cclkhIaJ.s:172    .text.prvDecrementSemaphoreCount:00000000 prvDecrementSemaphoreCount
     /tmp/cclkhIaJ.s:261    .text.prvDecrementSemaphoreCount:00000074 $d
     /tmp/cclkhIaJ.s:266    .text.prvIncrementSemaphoreCount:00000000 $t
     /tmp/cclkhIaJ.s:270    .text.prvIncrementSemaphoreCount:00000000 prvIncrementSemaphoreCount
     /tmp/cclkhIaJ.s:359    .text.prvIncrementSemaphoreCount:00000074 $d
     /tmp/cclkhIaJ.s:364    .text.prvCountingSemaphoreTask:00000000 $t
     /tmp/cclkhIaJ.s:440    .text.prvCountingSemaphoreTask:00000064 $d
     /tmp/cclkhIaJ.s:445    .text.xAreCountingSemaphoreTasksStillRunning:00000000 $t
     /tmp/cclkhIaJ.s:450    .text.xAreCountingSemaphoreTasksStillRunning:00000000 xAreCountingSemaphoreTasksStillRunning
     /tmp/cclkhIaJ.s:527    .text.xAreCountingSemaphoreTasksStillRunning:00000058 $d
     /tmp/cclkhIaJ.s:538    .bss.uxLastCount0.7665:00000000 uxLastCount0.7665
     /tmp/cclkhIaJ.s:544    .bss.uxLastCount1.7666:00000000 uxLastCount1.7666
     /tmp/cclkhIaJ.s:535    .bss.uxLastCount0.7665:00000000 $d
     /tmp/cclkhIaJ.s:541    .bss.uxLastCount1.7666:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueCreateCountingSemaphore
vQueueAddToRegistry
xTaskGenericCreate
xQueueGenericSend
xQueueGenericReceive
