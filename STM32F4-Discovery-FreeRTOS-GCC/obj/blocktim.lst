   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"blocktim.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xTestQueue,"aw",%nobits
  20              		.align	2
  23              	xTestQueue:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xSecondary,"aw",%nobits
  26              		.align	2
  29              	xSecondary:
  30 0000 00000000 		.space	4
  31              		.section	.bss.xPrimaryCycles,"aw",%nobits
  32              		.align	2
  35              	xPrimaryCycles:
  36 0000 00000000 		.space	4
  37              		.section	.bss.xSecondaryCycles,"aw",%nobits
  38              		.align	2
  41              	xSecondaryCycles:
  42 0000 00000000 		.space	4
  43              		.section	.bss.xErrorOccurred,"aw",%nobits
  44              		.align	2
  47              	xErrorOccurred:
  48 0000 00000000 		.space	4
  49              		.section	.bss.xRunIndicator,"aw",%nobits
  50              		.align	2
  53              	xRunIndicator:
  54 0000 00000000 		.space	4
  55              		.section	.rodata
  56              		.align	2
  57              	.LC0:
  58 0000 426C6F63 		.ascii	"Block_Time_Queue\000"
  58      6B5F5469 
  58      6D655F51 
  58      75657565 
  58      00
  59 0011 000000   		.align	2
  60              	.LC1:
  61 0014 42546573 		.ascii	"BTest1\000"
  61      743100
  62 001b 00       		.align	2
  63              	.LC2:
  64 001c 42546573 		.ascii	"BTest2\000"
  64      743200
  65 0023 00       		.section	.text.vCreateBlockTimeTasks,"ax",%progbits
  66              		.align	2
  67              		.global	vCreateBlockTimeTasks
  68              		.thumb
  69              		.thumb_func
  71              	vCreateBlockTimeTasks:
  72              	.LFB110:
  73              		.file 1 "App/Common/Minimal/blocktim.c"
   1:App/Common/Minimal/blocktim.c **** /*
   2:App/Common/Minimal/blocktim.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/blocktim.c ****     All rights reserved
   4:App/Common/Minimal/blocktim.c **** 
   5:App/Common/Minimal/blocktim.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/blocktim.c **** 
   7:App/Common/Minimal/blocktim.c ****     ***************************************************************************
   8:App/Common/Minimal/blocktim.c ****      *                                                                       *
   9:App/Common/Minimal/blocktim.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/blocktim.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/blocktim.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/blocktim.c ****      *                                                                       *
  13:App/Common/Minimal/blocktim.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/blocktim.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/blocktim.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/blocktim.c ****      *                                                                       *
  17:App/Common/Minimal/blocktim.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/blocktim.c ****      *                                                                       *
  19:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  20:App/Common/Minimal/blocktim.c **** 
  21:App/Common/Minimal/blocktim.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/blocktim.c **** 
  23:App/Common/Minimal/blocktim.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/blocktim.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/blocktim.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/blocktim.c **** 
  27:App/Common/Minimal/blocktim.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/blocktim.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/blocktim.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/blocktim.c ****     >>! kernel.
  31:App/Common/Minimal/blocktim.c **** 
  32:App/Common/Minimal/blocktim.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/blocktim.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/blocktim.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/blocktim.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/blocktim.c **** 
  37:App/Common/Minimal/blocktim.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/blocktim.c **** 
  39:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  40:App/Common/Minimal/blocktim.c ****      *                                                                       *
  41:App/Common/Minimal/blocktim.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/blocktim.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/blocktim.c ****      *                                                                       *
  44:App/Common/Minimal/blocktim.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/blocktim.c ****      *                                                                       *
  46:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  47:App/Common/Minimal/blocktim.c **** 
  48:App/Common/Minimal/blocktim.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/blocktim.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/blocktim.c **** 
  51:App/Common/Minimal/blocktim.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/blocktim.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/blocktim.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/blocktim.c **** 
  55:App/Common/Minimal/blocktim.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/blocktim.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/blocktim.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/blocktim.c **** 
  59:App/Common/Minimal/blocktim.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/blocktim.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/blocktim.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/blocktim.c **** 
  63:App/Common/Minimal/blocktim.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/blocktim.c **** */
  65:App/Common/Minimal/blocktim.c **** 
  66:App/Common/Minimal/blocktim.c **** /*
  67:App/Common/Minimal/blocktim.c ****  * This file contains some test scenarios that ensure tasks do not exit queue
  68:App/Common/Minimal/blocktim.c ****  * send or receive functions prematurely.  A description of the tests is
  69:App/Common/Minimal/blocktim.c ****  * included within the code.
  70:App/Common/Minimal/blocktim.c ****  */
  71:App/Common/Minimal/blocktim.c **** 
  72:App/Common/Minimal/blocktim.c **** /* Kernel includes. */
  73:App/Common/Minimal/blocktim.c **** #include "FreeRTOS.h"
  74:App/Common/Minimal/blocktim.c **** #include "task.h"
  75:App/Common/Minimal/blocktim.c **** #include "queue.h"
  76:App/Common/Minimal/blocktim.c **** 
  77:App/Common/Minimal/blocktim.c **** /* Demo includes. */
  78:App/Common/Minimal/blocktim.c **** #include "blocktim.h"
  79:App/Common/Minimal/blocktim.c **** 
  80:App/Common/Minimal/blocktim.c **** /* Task priorities.  Allow these to be overridden. */
  81:App/Common/Minimal/blocktim.c **** #ifndef bktPRIMARY_PRIORITY
  82:App/Common/Minimal/blocktim.c **** 	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
  83:App/Common/Minimal/blocktim.c **** #endif
  84:App/Common/Minimal/blocktim.c **** 
  85:App/Common/Minimal/blocktim.c **** #ifndef bktSECONDARY_PRIORITY
  86:App/Common/Minimal/blocktim.c **** 	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
  87:App/Common/Minimal/blocktim.c **** #endif
  88:App/Common/Minimal/blocktim.c **** 
  89:App/Common/Minimal/blocktim.c **** /* Task behaviour. */
  90:App/Common/Minimal/blocktim.c **** #define bktQUEUE_LENGTH				( 5 )
  91:App/Common/Minimal/blocktim.c **** #define bktSHORT_WAIT				( ( ( portTickType ) 20 ) / portTICK_RATE_MS )
  92:App/Common/Minimal/blocktim.c **** #define bktPRIMARY_BLOCK_TIME		( 10 )
  93:App/Common/Minimal/blocktim.c **** #define bktALLOWABLE_MARGIN			( 15 )
  94:App/Common/Minimal/blocktim.c **** #define bktTIME_TO_BLOCK			( 175 )
  95:App/Common/Minimal/blocktim.c **** #define bktDONT_BLOCK				( ( portTickType ) 0 )
  96:App/Common/Minimal/blocktim.c **** #define bktRUN_INDICATOR			( ( unsigned portBASE_TYPE ) 0x55 )
  97:App/Common/Minimal/blocktim.c **** 
  98:App/Common/Minimal/blocktim.c **** /* The queue on which the tasks block. */
  99:App/Common/Minimal/blocktim.c **** static xQueueHandle xTestQueue;
 100:App/Common/Minimal/blocktim.c **** 
 101:App/Common/Minimal/blocktim.c **** /* Handle to the secondary task is required by the primary task for calls
 102:App/Common/Minimal/blocktim.c **** to vTaskSuspend/Resume(). */
 103:App/Common/Minimal/blocktim.c **** static xTaskHandle xSecondary;
 104:App/Common/Minimal/blocktim.c **** 
 105:App/Common/Minimal/blocktim.c **** /* Used to ensure that tasks are still executing without error. */
 106:App/Common/Minimal/blocktim.c **** static volatile portBASE_TYPE xPrimaryCycles = 0, xSecondaryCycles = 0;
 107:App/Common/Minimal/blocktim.c **** static volatile portBASE_TYPE xErrorOccurred = pdFALSE;
 108:App/Common/Minimal/blocktim.c **** 
 109:App/Common/Minimal/blocktim.c **** /* Provides a simple mechanism for the primary task to know when the
 110:App/Common/Minimal/blocktim.c **** secondary task has executed. */
 111:App/Common/Minimal/blocktim.c **** static volatile unsigned portBASE_TYPE xRunIndicator;
 112:App/Common/Minimal/blocktim.c **** 
 113:App/Common/Minimal/blocktim.c **** /* The two test tasks.  Their behaviour is commented within the files. */
 114:App/Common/Minimal/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters );
 115:App/Common/Minimal/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters );
 116:App/Common/Minimal/blocktim.c **** 
 117:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 118:App/Common/Minimal/blocktim.c **** 
 119:App/Common/Minimal/blocktim.c **** void vCreateBlockTimeTasks( void )
 120:App/Common/Minimal/blocktim.c **** {
  74              		.loc 1 120 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78 0000 80B5     		push	{r7, lr}
  79              	.LCFI0:
  80              		.cfi_def_cfa_offset 8
  81              		.cfi_offset 7, -8
  82              		.cfi_offset 14, -4
  83 0002 84B0     		sub	sp, sp, #16
  84              	.LCFI1:
  85              		.cfi_def_cfa_offset 24
  86 0004 04AF     		add	r7, sp, #16
  87              	.LCFI2:
  88              		.cfi_def_cfa 7, 8
 121:App/Common/Minimal/blocktim.c **** 	/* Create the queue on which the two tasks block. */
 122:App/Common/Minimal/blocktim.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
  89              		.loc 1 122 0
  90 0006 0520     		movs	r0, #5
  91 0008 0421     		movs	r1, #4
  92 000a 0022     		movs	r2, #0
  93 000c FFF7FEFF 		bl	xQueueGenericCreate
  94 0010 0246     		mov	r2, r0
  95 0012 134B     		ldr	r3, .L2
  96 0014 1A60     		str	r2, [r3]
 123:App/Common/Minimal/blocktim.c **** 
 124:App/Common/Minimal/blocktim.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 125:App/Common/Minimal/blocktim.c **** 	in use.  The queue registry is provided as a means for kernel aware
 126:App/Common/Minimal/blocktim.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 127:App/Common/Minimal/blocktim.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 128:App/Common/Minimal/blocktim.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 129:App/Common/Minimal/blocktim.c **** 	defined to be less than 1. */
 130:App/Common/Minimal/blocktim.c **** 	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );
  97              		.loc 1 130 0
  98 0016 124B     		ldr	r3, .L2
  99 0018 1B68     		ldr	r3, [r3]
 100 001a 1846     		mov	r0, r3
 101 001c 1149     		ldr	r1, .L2+4
 102 001e FFF7FEFF 		bl	vQueueAddToRegistry
 131:App/Common/Minimal/blocktim.c **** 
 132:App/Common/Minimal/blocktim.c **** 	/* Create the two test tasks. */
 133:App/Common/Minimal/blocktim.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL,
 103              		.loc 1 133 0
 104 0022 0223     		movs	r3, #2
 105 0024 0093     		str	r3, [sp]
 106 0026 0023     		movs	r3, #0
 107 0028 0193     		str	r3, [sp, #4]
 108 002a 0023     		movs	r3, #0
 109 002c 0293     		str	r3, [sp, #8]
 110 002e 0023     		movs	r3, #0
 111 0030 0393     		str	r3, [sp, #12]
 112 0032 0D48     		ldr	r0, .L2+8
 113 0034 0D49     		ldr	r1, .L2+12
 114 0036 8222     		movs	r2, #130
 115 0038 0023     		movs	r3, #0
 116 003a FFF7FEFF 		bl	xTaskGenericCreate
 134:App/Common/Minimal/blocktim.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NUL
 117              		.loc 1 134 0
 118 003e 0123     		movs	r3, #1
 119 0040 0093     		str	r3, [sp]
 120 0042 0B4B     		ldr	r3, .L2+16
 121 0044 0193     		str	r3, [sp, #4]
 122 0046 0023     		movs	r3, #0
 123 0048 0293     		str	r3, [sp, #8]
 124 004a 0023     		movs	r3, #0
 125 004c 0393     		str	r3, [sp, #12]
 126 004e 0948     		ldr	r0, .L2+20
 127 0050 0949     		ldr	r1, .L2+24
 128 0052 8222     		movs	r2, #130
 129 0054 0023     		movs	r3, #0
 130 0056 FFF7FEFF 		bl	xTaskGenericCreate
 135:App/Common/Minimal/blocktim.c **** }
 131              		.loc 1 135 0
 132 005a BD46     		mov	sp, r7
 133              		@ sp needed
 134 005c 80BD     		pop	{r7, pc}
 135              	.L3:
 136 005e 00BF     		.align	2
 137              	.L2:
 138 0060 00000000 		.word	xTestQueue
 139 0064 00000000 		.word	.LC0
 140 0068 00000000 		.word	vPrimaryBlockTimeTestTask
 141 006c 14000000 		.word	.LC1
 142 0070 00000000 		.word	xSecondary
 143 0074 00000000 		.word	vSecondaryBlockTimeTestTask
 144 0078 1C000000 		.word	.LC2
 145              		.cfi_endproc
 146              	.LFE110:
 148              		.section	.text.vPrimaryBlockTimeTestTask,"ax",%progbits
 149              		.align	2
 150              		.thumb
 151              		.thumb_func
 153              	vPrimaryBlockTimeTestTask:
 154              	.LFB111:
 136:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 137:App/Common/Minimal/blocktim.c **** 
 138:App/Common/Minimal/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters )
 139:App/Common/Minimal/blocktim.c **** {
 155              		.loc 1 139 0
 156              		.cfi_startproc
 157              		@ args = 0, pretend = 0, frame = 32
 158              		@ frame_needed = 1, uses_anonymous_args = 0
 159 0000 80B5     		push	{r7, lr}
 160              	.LCFI3:
 161              		.cfi_def_cfa_offset 8
 162              		.cfi_offset 7, -8
 163              		.cfi_offset 14, -4
 164 0002 88B0     		sub	sp, sp, #32
 165              	.LCFI4:
 166              		.cfi_def_cfa_offset 40
 167 0004 00AF     		add	r7, sp, #0
 168              	.LCFI5:
 169              		.cfi_def_cfa_register 7
 170 0006 7860     		str	r0, [r7, #4]
 171              	.L41:
 140:App/Common/Minimal/blocktim.c **** portBASE_TYPE xItem, xData;
 141:App/Common/Minimal/blocktim.c **** portTickType xTimeWhenBlocking;
 142:App/Common/Minimal/blocktim.c **** portTickType xTimeToBlock, xBlockedTime;
 143:App/Common/Minimal/blocktim.c **** 
 144:App/Common/Minimal/blocktim.c **** 	( void ) pvParameters;
 145:App/Common/Minimal/blocktim.c **** 
 146:App/Common/Minimal/blocktim.c **** 	for( ;; )
 147:App/Common/Minimal/blocktim.c **** 	{
 148:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 149:App/Common/Minimal/blocktim.c ****         Test 1
 150:App/Common/Minimal/blocktim.c **** 
 151:App/Common/Minimal/blocktim.c ****         Simple block time wakeup test on queue receives. */
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 172              		.loc 1 152 0
 173 0008 0023     		movs	r3, #0
 174 000a 3B61     		str	r3, [r7, #16]
 175 000c 30E0     		b	.L5
 176              	.L9:
 153:App/Common/Minimal/blocktim.c **** 		{
 154:App/Common/Minimal/blocktim.c **** 			/* The queue is empty. Attempt to read from the queue using a block
 155:App/Common/Minimal/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 156:App/Common/Minimal/blocktim.c **** 			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
 177              		.loc 1 156 0
 178 000e 3B69     		ldr	r3, [r7, #16]
 179 0010 0A22     		movs	r2, #10
 180 0012 02FA03F3 		lsl	r3, r2, r3
 181 0016 FB61     		str	r3, [r7, #28]
 157:App/Common/Minimal/blocktim.c **** 
 158:App/Common/Minimal/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 182              		.loc 1 158 0
 183 0018 FFF7FEFF 		bl	xTaskGetTickCount
 184 001c B861     		str	r0, [r7, #24]
 159:App/Common/Minimal/blocktim.c **** 
 160:App/Common/Minimal/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 161:App/Common/Minimal/blocktim.c **** 			anything on the queue. */
 162:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 185              		.loc 1 162 0
 186 001e 894B     		ldr	r3, .L42
 187 0020 1A68     		ldr	r2, [r3]
 188 0022 07F10C03 		add	r3, r7, #12
 189 0026 1046     		mov	r0, r2
 190 0028 1946     		mov	r1, r3
 191 002a FA69     		ldr	r2, [r7, #28]
 192 002c 0023     		movs	r3, #0
 193 002e FFF7FEFF 		bl	xQueueGenericReceive
 194 0032 0346     		mov	r3, r0
 195 0034 002B     		cmp	r3, #0
 196 0036 02D0     		beq	.L6
 163:App/Common/Minimal/blocktim.c **** 			{
 164:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 197              		.loc 1 164 0
 198 0038 834B     		ldr	r3, .L42+4
 199 003a 0122     		movs	r2, #1
 200 003c 1A60     		str	r2, [r3]
 201              	.L6:
 165:App/Common/Minimal/blocktim.c **** 			}
 166:App/Common/Minimal/blocktim.c **** 
 167:App/Common/Minimal/blocktim.c **** 			/* How long were we blocked for? */
 168:App/Common/Minimal/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 202              		.loc 1 168 0
 203 003e FFF7FEFF 		bl	xTaskGetTickCount
 204 0042 0246     		mov	r2, r0
 205 0044 BB69     		ldr	r3, [r7, #24]
 206 0046 D31A     		subs	r3, r2, r3
 207 0048 7B61     		str	r3, [r7, #20]
 169:App/Common/Minimal/blocktim.c **** 
 170:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 208              		.loc 1 170 0
 209 004a 7A69     		ldr	r2, [r7, #20]
 210 004c FB69     		ldr	r3, [r7, #28]
 211 004e 9A42     		cmp	r2, r3
 212 0050 02D2     		bcs	.L7
 171:App/Common/Minimal/blocktim.c **** 			{
 172:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 173:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 213              		.loc 1 173 0
 214 0052 7D4B     		ldr	r3, .L42+4
 215 0054 0122     		movs	r2, #1
 216 0056 1A60     		str	r2, [r3]
 217              	.L7:
 174:App/Common/Minimal/blocktim.c **** 			}
 175:App/Common/Minimal/blocktim.c **** 
 176:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 218              		.loc 1 176 0
 219 0058 FB69     		ldr	r3, [r7, #28]
 220 005a 03F10F02 		add	r2, r3, #15
 221 005e 7B69     		ldr	r3, [r7, #20]
 222 0060 9A42     		cmp	r2, r3
 223 0062 02D2     		bcs	.L8
 177:App/Common/Minimal/blocktim.c **** 			{
 178:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 179:App/Common/Minimal/blocktim.c **** 				although we would not necessarily run as soon as we were
 180:App/Common/Minimal/blocktim.c **** 				unblocked so a margin is allowed. */
 181:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 224              		.loc 1 181 0
 225 0064 784B     		ldr	r3, .L42+4
 226 0066 0122     		movs	r2, #1
 227 0068 1A60     		str	r2, [r3]
 228              	.L8:
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 229              		.loc 1 152 0
 230 006a 3B69     		ldr	r3, [r7, #16]
 231 006c 0133     		adds	r3, r3, #1
 232 006e 3B61     		str	r3, [r7, #16]
 233              	.L5:
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 234              		.loc 1 152 0 is_stmt 0 discriminator 1
 235 0070 3B69     		ldr	r3, [r7, #16]
 236 0072 042B     		cmp	r3, #4
 237 0074 CBDD     		ble	.L9
 182:App/Common/Minimal/blocktim.c **** 			}
 183:App/Common/Minimal/blocktim.c **** 		}
 184:App/Common/Minimal/blocktim.c **** 
 185:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 186:App/Common/Minimal/blocktim.c ****         Test 2
 187:App/Common/Minimal/blocktim.c **** 
 188:App/Common/Minimal/blocktim.c ****         Simple block time wakeup test on queue sends.
 189:App/Common/Minimal/blocktim.c **** 
 190:App/Common/Minimal/blocktim.c **** 		First fill the queue.  It should be empty so all sends should pass. */
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 238              		.loc 1 191 0 is_stmt 1
 239 0076 0023     		movs	r3, #0
 240 0078 3B61     		str	r3, [r7, #16]
 241 007a 12E0     		b	.L10
 242              	.L12:
 192:App/Common/Minimal/blocktim.c **** 		{
 193:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 243              		.loc 1 193 0
 244 007c 714B     		ldr	r3, .L42
 245 007e 1A68     		ldr	r2, [r3]
 246 0080 07F11003 		add	r3, r7, #16
 247 0084 1046     		mov	r0, r2
 248 0086 1946     		mov	r1, r3
 249 0088 0022     		movs	r2, #0
 250 008a 0023     		movs	r3, #0
 251 008c FFF7FEFF 		bl	xQueueGenericSend
 252 0090 0346     		mov	r3, r0
 253 0092 012B     		cmp	r3, #1
 254 0094 02D0     		beq	.L11
 194:App/Common/Minimal/blocktim.c **** 			{
 195:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 255              		.loc 1 195 0
 256 0096 6C4B     		ldr	r3, .L42+4
 257 0098 0122     		movs	r2, #1
 258 009a 1A60     		str	r2, [r3]
 259              	.L11:
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 260              		.loc 1 191 0
 261 009c 3B69     		ldr	r3, [r7, #16]
 262 009e 0133     		adds	r3, r3, #1
 263 00a0 3B61     		str	r3, [r7, #16]
 264              	.L10:
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 265              		.loc 1 191 0 is_stmt 0 discriminator 1
 266 00a2 3B69     		ldr	r3, [r7, #16]
 267 00a4 042B     		cmp	r3, #4
 268 00a6 E9DD     		ble	.L12
 196:App/Common/Minimal/blocktim.c **** 			}
 197:App/Common/Minimal/blocktim.c **** 
 198:App/Common/Minimal/blocktim.c **** 			#if configUSE_PREEMPTION == 0
 199:App/Common/Minimal/blocktim.c **** 				taskYIELD();
 200:App/Common/Minimal/blocktim.c **** 			#endif
 201:App/Common/Minimal/blocktim.c **** 		}
 202:App/Common/Minimal/blocktim.c **** 
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 269              		.loc 1 203 0 is_stmt 1
 270 00a8 0023     		movs	r3, #0
 271 00aa 3B61     		str	r3, [r7, #16]
 272 00ac 30E0     		b	.L13
 273              	.L17:
 204:App/Common/Minimal/blocktim.c **** 		{
 205:App/Common/Minimal/blocktim.c **** 			/* The queue is full. Attempt to write to the queue using a block
 206:App/Common/Minimal/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 207:App/Common/Minimal/blocktim.c **** 			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
 274              		.loc 1 207 0
 275 00ae 3B69     		ldr	r3, [r7, #16]
 276 00b0 0A22     		movs	r2, #10
 277 00b2 02FA03F3 		lsl	r3, r2, r3
 278 00b6 FB61     		str	r3, [r7, #28]
 208:App/Common/Minimal/blocktim.c **** 
 209:App/Common/Minimal/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 279              		.loc 1 209 0
 280 00b8 FFF7FEFF 		bl	xTaskGetTickCount
 281 00bc B861     		str	r0, [r7, #24]
 210:App/Common/Minimal/blocktim.c **** 
 211:App/Common/Minimal/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 212:App/Common/Minimal/blocktim.c **** 			anything on the queue. */
 213:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 282              		.loc 1 213 0
 283 00be 614B     		ldr	r3, .L42
 284 00c0 1A68     		ldr	r2, [r3]
 285 00c2 07F11003 		add	r3, r7, #16
 286 00c6 1046     		mov	r0, r2
 287 00c8 1946     		mov	r1, r3
 288 00ca FA69     		ldr	r2, [r7, #28]
 289 00cc 0023     		movs	r3, #0
 290 00ce FFF7FEFF 		bl	xQueueGenericSend
 291 00d2 0346     		mov	r3, r0
 292 00d4 002B     		cmp	r3, #0
 293 00d6 02D0     		beq	.L14
 214:App/Common/Minimal/blocktim.c **** 			{
 215:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 294              		.loc 1 215 0
 295 00d8 5B4B     		ldr	r3, .L42+4
 296 00da 0122     		movs	r2, #1
 297 00dc 1A60     		str	r2, [r3]
 298              	.L14:
 216:App/Common/Minimal/blocktim.c **** 			}
 217:App/Common/Minimal/blocktim.c **** 
 218:App/Common/Minimal/blocktim.c **** 			/* How long were we blocked for? */
 219:App/Common/Minimal/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 299              		.loc 1 219 0
 300 00de FFF7FEFF 		bl	xTaskGetTickCount
 301 00e2 0246     		mov	r2, r0
 302 00e4 BB69     		ldr	r3, [r7, #24]
 303 00e6 D31A     		subs	r3, r2, r3
 304 00e8 7B61     		str	r3, [r7, #20]
 220:App/Common/Minimal/blocktim.c **** 
 221:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 305              		.loc 1 221 0
 306 00ea 7A69     		ldr	r2, [r7, #20]
 307 00ec FB69     		ldr	r3, [r7, #28]
 308 00ee 9A42     		cmp	r2, r3
 309 00f0 02D2     		bcs	.L15
 222:App/Common/Minimal/blocktim.c **** 			{
 223:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 224:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 310              		.loc 1 224 0
 311 00f2 554B     		ldr	r3, .L42+4
 312 00f4 0122     		movs	r2, #1
 313 00f6 1A60     		str	r2, [r3]
 314              	.L15:
 225:App/Common/Minimal/blocktim.c **** 			}
 226:App/Common/Minimal/blocktim.c **** 
 227:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 315              		.loc 1 227 0
 316 00f8 FB69     		ldr	r3, [r7, #28]
 317 00fa 03F10F02 		add	r2, r3, #15
 318 00fe 7B69     		ldr	r3, [r7, #20]
 319 0100 9A42     		cmp	r2, r3
 320 0102 02D2     		bcs	.L16
 228:App/Common/Minimal/blocktim.c **** 			{
 229:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 230:App/Common/Minimal/blocktim.c **** 				although we would not necessarily run as soon as we were
 231:App/Common/Minimal/blocktim.c **** 				unblocked so a margin is allowed. */
 232:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 321              		.loc 1 232 0
 322 0104 504B     		ldr	r3, .L42+4
 323 0106 0122     		movs	r2, #1
 324 0108 1A60     		str	r2, [r3]
 325              	.L16:
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 326              		.loc 1 203 0
 327 010a 3B69     		ldr	r3, [r7, #16]
 328 010c 0133     		adds	r3, r3, #1
 329 010e 3B61     		str	r3, [r7, #16]
 330              	.L13:
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 331              		.loc 1 203 0 is_stmt 0 discriminator 1
 332 0110 3B69     		ldr	r3, [r7, #16]
 333 0112 042B     		cmp	r3, #4
 334 0114 CBDD     		ble	.L17
 233:App/Common/Minimal/blocktim.c **** 			}
 234:App/Common/Minimal/blocktim.c **** 		}
 235:App/Common/Minimal/blocktim.c **** 
 236:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 237:App/Common/Minimal/blocktim.c ****         Test 3
 238:App/Common/Minimal/blocktim.c **** 
 239:App/Common/Minimal/blocktim.c **** 		Wake the other task, it will block attempting to post to the queue.
 240:App/Common/Minimal/blocktim.c **** 		When we read from the queue the other task will wake, but before it
 241:App/Common/Minimal/blocktim.c **** 		can run we will post to the queue again.  When the other task runs it
 242:App/Common/Minimal/blocktim.c **** 		will find the queue still full, even though it was woken.  It should
 243:App/Common/Minimal/blocktim.c **** 		recognise that its block time has not expired and return to block for
 244:App/Common/Minimal/blocktim.c **** 		the remains of its block time.
 245:App/Common/Minimal/blocktim.c **** 
 246:App/Common/Minimal/blocktim.c **** 		Wake the other task so it blocks attempting to post to the already
 247:App/Common/Minimal/blocktim.c **** 		full queue. */
 248:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 335              		.loc 1 248 0 is_stmt 1
 336 0116 4D4B     		ldr	r3, .L42+8
 337 0118 0022     		movs	r2, #0
 338 011a 1A60     		str	r2, [r3]
 249:App/Common/Minimal/blocktim.c **** 		vTaskResume( xSecondary );
 339              		.loc 1 249 0
 340 011c 4C4B     		ldr	r3, .L42+12
 341 011e 1B68     		ldr	r3, [r3]
 342 0120 1846     		mov	r0, r3
 343 0122 FFF7FEFF 		bl	vTaskResume
 250:App/Common/Minimal/blocktim.c **** 
 251:App/Common/Minimal/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 252:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 344              		.loc 1 252 0
 345 0126 02E0     		b	.L18
 346              	.L19:
 253:App/Common/Minimal/blocktim.c **** 		{
 254:App/Common/Minimal/blocktim.c **** 			/* The other task has not yet executed. */
 255:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 347              		.loc 1 255 0
 348 0128 1420     		movs	r0, #20
 349 012a FFF7FEFF 		bl	vTaskDelay
 350              	.L18:
 252:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 351              		.loc 1 252 0 discriminator 1
 352 012e 474B     		ldr	r3, .L42+8
 353 0130 1B68     		ldr	r3, [r3]
 354 0132 552B     		cmp	r3, #85
 355 0134 F8D1     		bne	.L19
 256:App/Common/Minimal/blocktim.c **** 		}
 257:App/Common/Minimal/blocktim.c **** 		/* Make sure the other task is blocked on the queue. */
 258:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 356              		.loc 1 258 0
 357 0136 1420     		movs	r0, #20
 358 0138 FFF7FEFF 		bl	vTaskDelay
 259:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 359              		.loc 1 259 0
 360 013c 434B     		ldr	r3, .L42+8
 361 013e 0022     		movs	r2, #0
 362 0140 1A60     		str	r2, [r3]
 260:App/Common/Minimal/blocktim.c **** 
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 363              		.loc 1 261 0
 364 0142 0023     		movs	r3, #0
 365 0144 3B61     		str	r3, [r7, #16]
 366 0146 3CE0     		b	.L20
 367              	.L25:
 262:App/Common/Minimal/blocktim.c **** 		{
 263:App/Common/Minimal/blocktim.c **** 			/* Now when we make space on the queue the other task should wake
 264:App/Common/Minimal/blocktim.c **** 			but not execute as this task has higher priority. */
 265:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 368              		.loc 1 265 0
 369 0148 3E4B     		ldr	r3, .L42
 370 014a 1A68     		ldr	r2, [r3]
 371 014c 07F10C03 		add	r3, r7, #12
 372 0150 1046     		mov	r0, r2
 373 0152 1946     		mov	r1, r3
 374 0154 0022     		movs	r2, #0
 375 0156 0023     		movs	r3, #0
 376 0158 FFF7FEFF 		bl	xQueueGenericReceive
 377 015c 0346     		mov	r3, r0
 378 015e 012B     		cmp	r3, #1
 379 0160 02D0     		beq	.L21
 266:App/Common/Minimal/blocktim.c **** 			{
 267:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 380              		.loc 1 267 0
 381 0162 394B     		ldr	r3, .L42+4
 382 0164 0122     		movs	r2, #1
 383 0166 1A60     		str	r2, [r3]
 384              	.L21:
 268:App/Common/Minimal/blocktim.c **** 			}
 269:App/Common/Minimal/blocktim.c **** 
 270:App/Common/Minimal/blocktim.c **** 			/* Now fill the queue again before the other task gets a chance to
 271:App/Common/Minimal/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 272:App/Common/Minimal/blocktim.c **** 			full ourselves, and the other task have set xRunIndicator. */
 273:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 385              		.loc 1 273 0
 386 0168 364B     		ldr	r3, .L42
 387 016a 1A68     		ldr	r2, [r3]
 388 016c 07F11003 		add	r3, r7, #16
 389 0170 1046     		mov	r0, r2
 390 0172 1946     		mov	r1, r3
 391 0174 0022     		movs	r2, #0
 392 0176 0023     		movs	r3, #0
 393 0178 FFF7FEFF 		bl	xQueueGenericSend
 394 017c 0346     		mov	r3, r0
 395 017e 012B     		cmp	r3, #1
 396 0180 02D0     		beq	.L22
 274:App/Common/Minimal/blocktim.c **** 			{
 275:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 397              		.loc 1 275 0
 398 0182 314B     		ldr	r3, .L42+4
 399 0184 0122     		movs	r2, #1
 400 0186 1A60     		str	r2, [r3]
 401              	.L22:
 276:App/Common/Minimal/blocktim.c **** 			}
 277:App/Common/Minimal/blocktim.c **** 
 278:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 402              		.loc 1 278 0
 403 0188 304B     		ldr	r3, .L42+8
 404 018a 1B68     		ldr	r3, [r3]
 405 018c 552B     		cmp	r3, #85
 406 018e 02D1     		bne	.L23
 279:App/Common/Minimal/blocktim.c **** 			{
 280:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed. */
 281:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 407              		.loc 1 281 0
 408 0190 2D4B     		ldr	r3, .L42+4
 409 0192 0122     		movs	r2, #1
 410 0194 1A60     		str	r2, [r3]
 411              	.L23:
 282:App/Common/Minimal/blocktim.c **** 			}
 283:App/Common/Minimal/blocktim.c **** 
 284:App/Common/Minimal/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 285:App/Common/Minimal/blocktim.c **** 			on the queue again. */
 286:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 412              		.loc 1 286 0
 413 0196 2E4B     		ldr	r3, .L42+12
 414 0198 1B68     		ldr	r3, [r3]
 415 019a 1846     		mov	r0, r3
 416 019c 0421     		movs	r1, #4
 417 019e FFF7FEFF 		bl	vTaskPrioritySet
 287:App/Common/Minimal/blocktim.c **** 
 288:App/Common/Minimal/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 289:App/Common/Minimal/blocktim.c **** 			queue function. */
 290:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 418              		.loc 1 290 0
 419 01a2 2A4B     		ldr	r3, .L42+8
 420 01a4 1B68     		ldr	r3, [r3]
 421 01a6 552B     		cmp	r3, #85
 422 01a8 02D1     		bne	.L24
 291:App/Common/Minimal/blocktim.c **** 			{
 292:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed outside of the
 293:App/Common/Minimal/blocktim.c **** 				queue function. */
 294:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 423              		.loc 1 294 0
 424 01aa 274B     		ldr	r3, .L42+4
 425 01ac 0122     		movs	r2, #1
 426 01ae 1A60     		str	r2, [r3]
 427              	.L24:
 295:App/Common/Minimal/blocktim.c **** 			}
 296:App/Common/Minimal/blocktim.c **** 
 297:App/Common/Minimal/blocktim.c **** 			/* Set the priority back down. */
 298:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 428              		.loc 1 298 0
 429 01b0 274B     		ldr	r3, .L42+12
 430 01b2 1B68     		ldr	r3, [r3]
 431 01b4 1846     		mov	r0, r3
 432 01b6 0121     		movs	r1, #1
 433 01b8 FFF7FEFF 		bl	vTaskPrioritySet
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 434              		.loc 1 261 0
 435 01bc 3B69     		ldr	r3, [r7, #16]
 436 01be 0133     		adds	r3, r3, #1
 437 01c0 3B61     		str	r3, [r7, #16]
 438              	.L20:
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 439              		.loc 1 261 0 is_stmt 0 discriminator 1
 440 01c2 3B69     		ldr	r3, [r7, #16]
 441 01c4 042B     		cmp	r3, #4
 442 01c6 BFDD     		ble	.L25
 299:App/Common/Minimal/blocktim.c **** 		}
 300:App/Common/Minimal/blocktim.c **** 
 301:App/Common/Minimal/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 302:App/Common/Minimal/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 303:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 443              		.loc 1 303 0 is_stmt 1
 444 01c8 02E0     		b	.L26
 445              	.L27:
 304:App/Common/Minimal/blocktim.c **** 		{
 305:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 446              		.loc 1 305 0
 447 01ca 1420     		movs	r0, #20
 448 01cc FFF7FEFF 		bl	vTaskDelay
 449              	.L26:
 303:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 450              		.loc 1 303 0 discriminator 1
 451 01d0 1E4B     		ldr	r3, .L42+8
 452 01d2 1B68     		ldr	r3, [r3]
 453 01d4 552B     		cmp	r3, #85
 454 01d6 F8D1     		bne	.L27
 306:App/Common/Minimal/blocktim.c **** 		}
 307:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 455              		.loc 1 307 0
 456 01d8 1420     		movs	r0, #20
 457 01da FFF7FEFF 		bl	vTaskDelay
 308:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 458              		.loc 1 308 0
 459 01de 1B4B     		ldr	r3, .L42+8
 460 01e0 0022     		movs	r2, #0
 461 01e2 1A60     		str	r2, [r3]
 309:App/Common/Minimal/blocktim.c **** 
 310:App/Common/Minimal/blocktim.c **** 
 311:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 312:App/Common/Minimal/blocktim.c ****         Test 4
 313:App/Common/Minimal/blocktim.c **** 
 314:App/Common/Minimal/blocktim.c **** 		As per test 3 - but with the send and receive the other way around.
 315:App/Common/Minimal/blocktim.c **** 		The other task blocks attempting to read from the queue.
 316:App/Common/Minimal/blocktim.c **** 
 317:App/Common/Minimal/blocktim.c **** 		Empty the queue.  We should find that it is full. */
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 462              		.loc 1 318 0
 463 01e4 0023     		movs	r3, #0
 464 01e6 3B61     		str	r3, [r7, #16]
 465 01e8 12E0     		b	.L28
 466              	.L30:
 319:App/Common/Minimal/blocktim.c **** 		{
 320:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 467              		.loc 1 320 0
 468 01ea 164B     		ldr	r3, .L42
 469 01ec 1A68     		ldr	r2, [r3]
 470 01ee 07F10C03 		add	r3, r7, #12
 471 01f2 1046     		mov	r0, r2
 472 01f4 1946     		mov	r1, r3
 473 01f6 0022     		movs	r2, #0
 474 01f8 0023     		movs	r3, #0
 475 01fa FFF7FEFF 		bl	xQueueGenericReceive
 476 01fe 0346     		mov	r3, r0
 477 0200 012B     		cmp	r3, #1
 478 0202 02D0     		beq	.L29
 321:App/Common/Minimal/blocktim.c **** 			{
 322:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 479              		.loc 1 322 0
 480 0204 104B     		ldr	r3, .L42+4
 481 0206 0122     		movs	r2, #1
 482 0208 1A60     		str	r2, [r3]
 483              	.L29:
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 484              		.loc 1 318 0
 485 020a 3B69     		ldr	r3, [r7, #16]
 486 020c 0133     		adds	r3, r3, #1
 487 020e 3B61     		str	r3, [r7, #16]
 488              	.L28:
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 489              		.loc 1 318 0 is_stmt 0 discriminator 1
 490 0210 3B69     		ldr	r3, [r7, #16]
 491 0212 042B     		cmp	r3, #4
 492 0214 E9DD     		ble	.L30
 323:App/Common/Minimal/blocktim.c **** 			}
 324:App/Common/Minimal/blocktim.c **** 		}
 325:App/Common/Minimal/blocktim.c **** 
 326:App/Common/Minimal/blocktim.c **** 		/* Wake the other task so it blocks attempting to read from  the
 327:App/Common/Minimal/blocktim.c **** 		already	empty queue. */
 328:App/Common/Minimal/blocktim.c **** 		vTaskResume( xSecondary );
 493              		.loc 1 328 0 is_stmt 1
 494 0216 0E4B     		ldr	r3, .L42+12
 495 0218 1B68     		ldr	r3, [r3]
 496 021a 1846     		mov	r0, r3
 497 021c FFF7FEFF 		bl	vTaskResume
 329:App/Common/Minimal/blocktim.c **** 
 330:App/Common/Minimal/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 331:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 498              		.loc 1 331 0
 499 0220 02E0     		b	.L31
 500              	.L32:
 332:App/Common/Minimal/blocktim.c **** 		{
 333:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 501              		.loc 1 333 0
 502 0222 1420     		movs	r0, #20
 503 0224 FFF7FEFF 		bl	vTaskDelay
 504              	.L31:
 331:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 505              		.loc 1 331 0 discriminator 1
 506 0228 084B     		ldr	r3, .L42+8
 507 022a 1B68     		ldr	r3, [r3]
 508 022c 552B     		cmp	r3, #85
 509 022e F8D1     		bne	.L32
 334:App/Common/Minimal/blocktim.c **** 		}
 335:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 510              		.loc 1 335 0
 511 0230 1420     		movs	r0, #20
 512 0232 FFF7FEFF 		bl	vTaskDelay
 336:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 513              		.loc 1 336 0
 514 0236 054B     		ldr	r3, .L42+8
 515 0238 0022     		movs	r2, #0
 516 023a 1A60     		str	r2, [r3]
 337:App/Common/Minimal/blocktim.c **** 
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 517              		.loc 1 338 0
 518 023c 0023     		movs	r3, #0
 519 023e 3B61     		str	r3, [r7, #16]
 520 0240 45E0     		b	.L33
 521              	.L43:
 522 0242 00BF     		.align	2
 523              	.L42:
 524 0244 00000000 		.word	xTestQueue
 525 0248 00000000 		.word	xErrorOccurred
 526 024c 00000000 		.word	xRunIndicator
 527 0250 00000000 		.word	xSecondary
 528              	.L38:
 339:App/Common/Minimal/blocktim.c **** 		{
 340:App/Common/Minimal/blocktim.c **** 			/* Now when we place an item on the queue the other task should
 341:App/Common/Minimal/blocktim.c **** 			wake but not execute as this task has higher priority. */
 342:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 529              		.loc 1 342 0
 530 0254 284B     		ldr	r3, .L44
 531 0256 1A68     		ldr	r2, [r3]
 532 0258 07F11003 		add	r3, r7, #16
 533 025c 1046     		mov	r0, r2
 534 025e 1946     		mov	r1, r3
 535 0260 0022     		movs	r2, #0
 536 0262 0023     		movs	r3, #0
 537 0264 FFF7FEFF 		bl	xQueueGenericSend
 538 0268 0346     		mov	r3, r0
 539 026a 012B     		cmp	r3, #1
 540 026c 02D0     		beq	.L34
 343:App/Common/Minimal/blocktim.c **** 			{
 344:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 541              		.loc 1 344 0
 542 026e 234B     		ldr	r3, .L44+4
 543 0270 0122     		movs	r2, #1
 544 0272 1A60     		str	r2, [r3]
 545              	.L34:
 345:App/Common/Minimal/blocktim.c **** 			}
 346:App/Common/Minimal/blocktim.c **** 
 347:App/Common/Minimal/blocktim.c **** 			/* Now empty the queue again before the other task gets a chance to
 348:App/Common/Minimal/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 349:App/Common/Minimal/blocktim.c **** 			empty ourselves, and the other task would be suspended. */
 350:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 546              		.loc 1 350 0
 547 0274 204B     		ldr	r3, .L44
 548 0276 1A68     		ldr	r2, [r3]
 549 0278 07F10C03 		add	r3, r7, #12
 550 027c 1046     		mov	r0, r2
 551 027e 1946     		mov	r1, r3
 552 0280 0022     		movs	r2, #0
 553 0282 0023     		movs	r3, #0
 554 0284 FFF7FEFF 		bl	xQueueGenericReceive
 555 0288 0346     		mov	r3, r0
 556 028a 012B     		cmp	r3, #1
 557 028c 02D0     		beq	.L35
 351:App/Common/Minimal/blocktim.c **** 			{
 352:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 558              		.loc 1 352 0
 559 028e 1B4B     		ldr	r3, .L44+4
 560 0290 0122     		movs	r2, #1
 561 0292 1A60     		str	r2, [r3]
 562              	.L35:
 353:App/Common/Minimal/blocktim.c **** 			}
 354:App/Common/Minimal/blocktim.c **** 
 355:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 563              		.loc 1 355 0
 564 0294 1A4B     		ldr	r3, .L44+8
 565 0296 1B68     		ldr	r3, [r3]
 566 0298 552B     		cmp	r3, #85
 567 029a 02D1     		bne	.L36
 356:App/Common/Minimal/blocktim.c **** 			{
 357:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed. */
 358:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 568              		.loc 1 358 0
 569 029c 174B     		ldr	r3, .L44+4
 570 029e 0122     		movs	r2, #1
 571 02a0 1A60     		str	r2, [r3]
 572              	.L36:
 359:App/Common/Minimal/blocktim.c **** 			}
 360:App/Common/Minimal/blocktim.c **** 
 361:App/Common/Minimal/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 362:App/Common/Minimal/blocktim.c **** 			on the queue again. */
 363:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 573              		.loc 1 363 0
 574 02a2 184B     		ldr	r3, .L44+12
 575 02a4 1B68     		ldr	r3, [r3]
 576 02a6 1846     		mov	r0, r3
 577 02a8 0421     		movs	r1, #4
 578 02aa FFF7FEFF 		bl	vTaskPrioritySet
 364:App/Common/Minimal/blocktim.c **** 
 365:App/Common/Minimal/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 366:App/Common/Minimal/blocktim.c **** 			queue function. */
 367:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 579              		.loc 1 367 0
 580 02ae 144B     		ldr	r3, .L44+8
 581 02b0 1B68     		ldr	r3, [r3]
 582 02b2 552B     		cmp	r3, #85
 583 02b4 02D1     		bne	.L37
 368:App/Common/Minimal/blocktim.c **** 			{
 369:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed outside of the
 370:App/Common/Minimal/blocktim.c **** 				queue function. */
 371:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 584              		.loc 1 371 0
 585 02b6 114B     		ldr	r3, .L44+4
 586 02b8 0122     		movs	r2, #1
 587 02ba 1A60     		str	r2, [r3]
 588              	.L37:
 372:App/Common/Minimal/blocktim.c **** 			}
 373:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 589              		.loc 1 373 0
 590 02bc 114B     		ldr	r3, .L44+12
 591 02be 1B68     		ldr	r3, [r3]
 592 02c0 1846     		mov	r0, r3
 593 02c2 0121     		movs	r1, #1
 594 02c4 FFF7FEFF 		bl	vTaskPrioritySet
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 595              		.loc 1 338 0
 596 02c8 3B69     		ldr	r3, [r7, #16]
 597 02ca 0133     		adds	r3, r3, #1
 598 02cc 3B61     		str	r3, [r7, #16]
 599              	.L33:
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 600              		.loc 1 338 0 is_stmt 0 discriminator 1
 601 02ce 3B69     		ldr	r3, [r7, #16]
 602 02d0 042B     		cmp	r3, #4
 603 02d2 BFDD     		ble	.L38
 374:App/Common/Minimal/blocktim.c **** 		}
 375:App/Common/Minimal/blocktim.c **** 
 376:App/Common/Minimal/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 377:App/Common/Minimal/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 378:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 604              		.loc 1 378 0 is_stmt 1
 605 02d4 02E0     		b	.L39
 606              	.L40:
 379:App/Common/Minimal/blocktim.c **** 		{
 380:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 607              		.loc 1 380 0
 608 02d6 1420     		movs	r0, #20
 609 02d8 FFF7FEFF 		bl	vTaskDelay
 610              	.L39:
 378:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 611              		.loc 1 378 0 discriminator 1
 612 02dc 084B     		ldr	r3, .L44+8
 613 02de 1B68     		ldr	r3, [r3]
 614 02e0 552B     		cmp	r3, #85
 615 02e2 F8D1     		bne	.L40
 381:App/Common/Minimal/blocktim.c **** 		}
 382:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 616              		.loc 1 382 0
 617 02e4 1420     		movs	r0, #20
 618 02e6 FFF7FEFF 		bl	vTaskDelay
 383:App/Common/Minimal/blocktim.c **** 
 384:App/Common/Minimal/blocktim.c **** 		xPrimaryCycles++;
 619              		.loc 1 384 0
 620 02ea 074B     		ldr	r3, .L44+16
 621 02ec 1B68     		ldr	r3, [r3]
 622 02ee 5A1C     		adds	r2, r3, #1
 623 02f0 054B     		ldr	r3, .L44+16
 624 02f2 1A60     		str	r2, [r3]
 385:App/Common/Minimal/blocktim.c **** 	}
 625              		.loc 1 385 0
 626 02f4 88E6     		b	.L41
 627              	.L45:
 628 02f6 00BF     		.align	2
 629              	.L44:
 630 02f8 00000000 		.word	xTestQueue
 631 02fc 00000000 		.word	xErrorOccurred
 632 0300 00000000 		.word	xRunIndicator
 633 0304 00000000 		.word	xSecondary
 634 0308 00000000 		.word	xPrimaryCycles
 635              		.cfi_endproc
 636              	.LFE111:
 638              		.section	.text.vSecondaryBlockTimeTestTask,"ax",%progbits
 639              		.align	2
 640              		.thumb
 641              		.thumb_func
 643              	vSecondaryBlockTimeTestTask:
 644              	.LFB112:
 386:App/Common/Minimal/blocktim.c **** }
 387:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 388:App/Common/Minimal/blocktim.c **** 
 389:App/Common/Minimal/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters )
 390:App/Common/Minimal/blocktim.c **** {
 645              		.loc 1 390 0
 646              		.cfi_startproc
 647              		@ args = 0, pretend = 0, frame = 24
 648              		@ frame_needed = 1, uses_anonymous_args = 0
 649 0000 80B5     		push	{r7, lr}
 650              	.LCFI6:
 651              		.cfi_def_cfa_offset 8
 652              		.cfi_offset 7, -8
 653              		.cfi_offset 14, -4
 654 0002 86B0     		sub	sp, sp, #24
 655              	.LCFI7:
 656              		.cfi_def_cfa_offset 32
 657 0004 00AF     		add	r7, sp, #0
 658              	.LCFI8:
 659              		.cfi_def_cfa_register 7
 660 0006 7860     		str	r0, [r7, #4]
 661              	.L53:
 391:App/Common/Minimal/blocktim.c **** portTickType xTimeWhenBlocking, xBlockedTime;
 392:App/Common/Minimal/blocktim.c **** portBASE_TYPE xData;
 393:App/Common/Minimal/blocktim.c **** 
 394:App/Common/Minimal/blocktim.c **** 	( void ) pvParameters;
 395:App/Common/Minimal/blocktim.c **** 
 396:App/Common/Minimal/blocktim.c **** 	for( ;; )
 397:App/Common/Minimal/blocktim.c **** 	{
 398:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 399:App/Common/Minimal/blocktim.c ****         Test 1 and 2
 400:App/Common/Minimal/blocktim.c **** 
 401:App/Common/Minimal/blocktim.c **** 		This task does does not participate in these tests. */
 402:App/Common/Minimal/blocktim.c **** 		vTaskSuspend( NULL );
 662              		.loc 1 402 0
 663 0008 0020     		movs	r0, #0
 664 000a FFF7FEFF 		bl	vTaskSuspend
 403:App/Common/Minimal/blocktim.c **** 
 404:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 405:App/Common/Minimal/blocktim.c ****         Test 3
 406:App/Common/Minimal/blocktim.c **** 
 407:App/Common/Minimal/blocktim.c **** 		The first thing we do is attempt to read from the queue.  It should be
 408:App/Common/Minimal/blocktim.c **** 		full so we block.  Note the time before we block so we can check the
 409:App/Common/Minimal/blocktim.c **** 		wake time is as per that expected. */
 410:App/Common/Minimal/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 665              		.loc 1 410 0
 666 000e FFF7FEFF 		bl	xTaskGetTickCount
 667 0012 7861     		str	r0, [r7, #20]
 411:App/Common/Minimal/blocktim.c **** 
 412:App/Common/Minimal/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not sent
 413:App/Common/Minimal/blocktim.c **** 		anything to the queue. */
 414:App/Common/Minimal/blocktim.c **** 		xData = 0;
 668              		.loc 1 414 0
 669 0014 0023     		movs	r3, #0
 670 0016 FB60     		str	r3, [r7, #12]
 415:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 671              		.loc 1 415 0
 672 0018 2D4B     		ldr	r3, .L54
 673 001a 5522     		movs	r2, #85
 674 001c 1A60     		str	r2, [r3]
 416:App/Common/Minimal/blocktim.c **** 		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 675              		.loc 1 416 0
 676 001e 2D4B     		ldr	r3, .L54+4
 677 0020 1A68     		ldr	r2, [r3]
 678 0022 07F10C03 		add	r3, r7, #12
 679 0026 1046     		mov	r0, r2
 680 0028 1946     		mov	r1, r3
 681 002a AF22     		movs	r2, #175
 682 002c 0023     		movs	r3, #0
 683 002e FFF7FEFF 		bl	xQueueGenericSend
 684 0032 0346     		mov	r3, r0
 685 0034 002B     		cmp	r3, #0
 686 0036 02D0     		beq	.L47
 417:App/Common/Minimal/blocktim.c **** 		{
 418:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 687              		.loc 1 418 0
 688 0038 274B     		ldr	r3, .L54+8
 689 003a 0122     		movs	r2, #1
 690 003c 1A60     		str	r2, [r3]
 691              	.L47:
 419:App/Common/Minimal/blocktim.c **** 		}
 420:App/Common/Minimal/blocktim.c **** 
 421:App/Common/Minimal/blocktim.c **** 		/* How long were we inside the send function? */
 422:App/Common/Minimal/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 692              		.loc 1 422 0
 693 003e FFF7FEFF 		bl	xTaskGetTickCount
 694 0042 0246     		mov	r2, r0
 695 0044 7B69     		ldr	r3, [r7, #20]
 696 0046 D31A     		subs	r3, r2, r3
 697 0048 3B61     		str	r3, [r7, #16]
 423:App/Common/Minimal/blocktim.c **** 
 424:App/Common/Minimal/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 425:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 698              		.loc 1 425 0
 699 004a 3B69     		ldr	r3, [r7, #16]
 700 004c AE2B     		cmp	r3, #174
 701 004e 02D8     		bhi	.L48
 426:App/Common/Minimal/blocktim.c **** 		{
 427:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 702              		.loc 1 427 0
 703 0050 214B     		ldr	r3, .L54+8
 704 0052 0122     		movs	r2, #1
 705 0054 1A60     		str	r2, [r3]
 706              	.L48:
 428:App/Common/Minimal/blocktim.c **** 		}
 429:App/Common/Minimal/blocktim.c **** 
 430:App/Common/Minimal/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 431:App/Common/Minimal/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as
 432:App/Common/Minimal/blocktim.c **** 		soon as we unblocked. */
 433:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 707              		.loc 1 433 0
 708 0056 3B69     		ldr	r3, [r7, #16]
 709 0058 BE2B     		cmp	r3, #190
 710 005a 02D9     		bls	.L49
 434:App/Common/Minimal/blocktim.c **** 		{
 435:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 711              		.loc 1 435 0
 712 005c 1E4B     		ldr	r3, .L54+8
 713 005e 0122     		movs	r2, #1
 714 0060 1A60     		str	r2, [r3]
 715              	.L49:
 436:App/Common/Minimal/blocktim.c **** 		}
 437:App/Common/Minimal/blocktim.c **** 
 438:App/Common/Minimal/blocktim.c **** 		/* Suspend ready for test 3. */
 439:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 716              		.loc 1 439 0
 717 0062 1B4B     		ldr	r3, .L54
 718 0064 5522     		movs	r2, #85
 719 0066 1A60     		str	r2, [r3]
 440:App/Common/Minimal/blocktim.c **** 		vTaskSuspend( NULL );
 720              		.loc 1 440 0
 721 0068 0020     		movs	r0, #0
 722 006a FFF7FEFF 		bl	vTaskSuspend
 441:App/Common/Minimal/blocktim.c **** 
 442:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 443:App/Common/Minimal/blocktim.c ****         Test 4
 444:App/Common/Minimal/blocktim.c **** 
 445:App/Common/Minimal/blocktim.c **** 		As per test three, but with the send and receive reversed. */
 446:App/Common/Minimal/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 723              		.loc 1 446 0
 724 006e FFF7FEFF 		bl	xTaskGetTickCount
 725 0072 7861     		str	r0, [r7, #20]
 447:App/Common/Minimal/blocktim.c **** 
 448:App/Common/Minimal/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not received
 449:App/Common/Minimal/blocktim.c **** 		anything on the queue. */
 450:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 726              		.loc 1 450 0
 727 0074 164B     		ldr	r3, .L54
 728 0076 5522     		movs	r2, #85
 729 0078 1A60     		str	r2, [r3]
 451:App/Common/Minimal/blocktim.c **** 		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 730              		.loc 1 451 0
 731 007a 164B     		ldr	r3, .L54+4
 732 007c 1A68     		ldr	r2, [r3]
 733 007e 07F10C03 		add	r3, r7, #12
 734 0082 1046     		mov	r0, r2
 735 0084 1946     		mov	r1, r3
 736 0086 AF22     		movs	r2, #175
 737 0088 0023     		movs	r3, #0
 738 008a FFF7FEFF 		bl	xQueueGenericReceive
 739 008e 0346     		mov	r3, r0
 740 0090 002B     		cmp	r3, #0
 741 0092 02D0     		beq	.L50
 452:App/Common/Minimal/blocktim.c **** 		{
 453:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 742              		.loc 1 453 0
 743 0094 104B     		ldr	r3, .L54+8
 744 0096 0122     		movs	r2, #1
 745 0098 1A60     		str	r2, [r3]
 746              	.L50:
 454:App/Common/Minimal/blocktim.c **** 		}
 455:App/Common/Minimal/blocktim.c **** 
 456:App/Common/Minimal/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 747              		.loc 1 456 0
 748 009a FFF7FEFF 		bl	xTaskGetTickCount
 749 009e 0246     		mov	r2, r0
 750 00a0 7B69     		ldr	r3, [r7, #20]
 751 00a2 D31A     		subs	r3, r2, r3
 752 00a4 3B61     		str	r3, [r7, #16]
 457:App/Common/Minimal/blocktim.c **** 
 458:App/Common/Minimal/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 459:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 753              		.loc 1 459 0
 754 00a6 3B69     		ldr	r3, [r7, #16]
 755 00a8 AE2B     		cmp	r3, #174
 756 00aa 02D8     		bhi	.L51
 460:App/Common/Minimal/blocktim.c **** 		{
 461:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 757              		.loc 1 461 0
 758 00ac 0A4B     		ldr	r3, .L54+8
 759 00ae 0122     		movs	r2, #1
 760 00b0 1A60     		str	r2, [r3]
 761              	.L51:
 462:App/Common/Minimal/blocktim.c **** 		}
 463:App/Common/Minimal/blocktim.c **** 
 464:App/Common/Minimal/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 465:App/Common/Minimal/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as soon
 466:App/Common/Minimal/blocktim.c **** 		as we unblocked. */
 467:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 762              		.loc 1 467 0
 763 00b2 3B69     		ldr	r3, [r7, #16]
 764 00b4 BE2B     		cmp	r3, #190
 765 00b6 02D9     		bls	.L52
 468:App/Common/Minimal/blocktim.c **** 		{
 469:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 766              		.loc 1 469 0
 767 00b8 074B     		ldr	r3, .L54+8
 768 00ba 0122     		movs	r2, #1
 769 00bc 1A60     		str	r2, [r3]
 770              	.L52:
 470:App/Common/Minimal/blocktim.c **** 		}
 471:App/Common/Minimal/blocktim.c **** 
 472:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 771              		.loc 1 472 0
 772 00be 044B     		ldr	r3, .L54
 773 00c0 5522     		movs	r2, #85
 774 00c2 1A60     		str	r2, [r3]
 473:App/Common/Minimal/blocktim.c **** 
 474:App/Common/Minimal/blocktim.c **** 		xSecondaryCycles++;
 775              		.loc 1 474 0
 776 00c4 054B     		ldr	r3, .L54+12
 777 00c6 1B68     		ldr	r3, [r3]
 778 00c8 5A1C     		adds	r2, r3, #1
 779 00ca 044B     		ldr	r3, .L54+12
 780 00cc 1A60     		str	r2, [r3]
 475:App/Common/Minimal/blocktim.c **** 	}
 781              		.loc 1 475 0
 782 00ce 9BE7     		b	.L53
 783              	.L55:
 784              		.align	2
 785              	.L54:
 786 00d0 00000000 		.word	xRunIndicator
 787 00d4 00000000 		.word	xTestQueue
 788 00d8 00000000 		.word	xErrorOccurred
 789 00dc 00000000 		.word	xSecondaryCycles
 790              		.cfi_endproc
 791              	.LFE112:
 793              		.section	.text.xAreBlockTimeTestTasksStillRunning,"ax",%progbits
 794              		.align	2
 795              		.global	xAreBlockTimeTestTasksStillRunning
 796              		.thumb
 797              		.thumb_func
 799              	xAreBlockTimeTestTasksStillRunning:
 800              	.LFB113:
 476:App/Common/Minimal/blocktim.c **** }
 477:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 478:App/Common/Minimal/blocktim.c **** 
 479:App/Common/Minimal/blocktim.c **** portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
 480:App/Common/Minimal/blocktim.c **** {
 801              		.loc 1 480 0
 802              		.cfi_startproc
 803              		@ args = 0, pretend = 0, frame = 8
 804              		@ frame_needed = 1, uses_anonymous_args = 0
 805              		@ link register save eliminated.
 806 0000 80B4     		push	{r7}
 807              	.LCFI9:
 808              		.cfi_def_cfa_offset 4
 809              		.cfi_offset 7, -4
 810 0002 83B0     		sub	sp, sp, #12
 811              	.LCFI10:
 812              		.cfi_def_cfa_offset 16
 813 0004 00AF     		add	r7, sp, #0
 814              	.LCFI11:
 815              		.cfi_def_cfa_register 7
 481:App/Common/Minimal/blocktim.c **** static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
 482:App/Common/Minimal/blocktim.c **** portBASE_TYPE xReturn = pdPASS;
 816              		.loc 1 482 0
 817 0006 0123     		movs	r3, #1
 818 0008 7B60     		str	r3, [r7, #4]
 483:App/Common/Minimal/blocktim.c **** 
 484:App/Common/Minimal/blocktim.c **** 	/* Have both tasks performed at least one cycle since this function was
 485:App/Common/Minimal/blocktim.c **** 	last called? */
 486:App/Common/Minimal/blocktim.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 819              		.loc 1 486 0
 820 000a 124B     		ldr	r3, .L61
 821 000c 1A68     		ldr	r2, [r3]
 822 000e 124B     		ldr	r3, .L61+4
 823 0010 1B68     		ldr	r3, [r3]
 824 0012 9A42     		cmp	r2, r3
 825 0014 01D1     		bne	.L57
 487:App/Common/Minimal/blocktim.c **** 	{
 488:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 826              		.loc 1 488 0
 827 0016 0023     		movs	r3, #0
 828 0018 7B60     		str	r3, [r7, #4]
 829              	.L57:
 489:App/Common/Minimal/blocktim.c **** 	}
 490:App/Common/Minimal/blocktim.c **** 
 491:App/Common/Minimal/blocktim.c **** 	if( xSecondaryCycles == xLastSecondaryCycleCount )
 830              		.loc 1 491 0
 831 001a 104B     		ldr	r3, .L61+8
 832 001c 1A68     		ldr	r2, [r3]
 833 001e 104B     		ldr	r3, .L61+12
 834 0020 1B68     		ldr	r3, [r3]
 835 0022 9A42     		cmp	r2, r3
 836 0024 01D1     		bne	.L58
 492:App/Common/Minimal/blocktim.c **** 	{
 493:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 837              		.loc 1 493 0
 838 0026 0023     		movs	r3, #0
 839 0028 7B60     		str	r3, [r7, #4]
 840              	.L58:
 494:App/Common/Minimal/blocktim.c **** 	}
 495:App/Common/Minimal/blocktim.c **** 
 496:App/Common/Minimal/blocktim.c **** 	if( xErrorOccurred == pdTRUE )
 841              		.loc 1 496 0
 842 002a 0E4B     		ldr	r3, .L61+16
 843 002c 1B68     		ldr	r3, [r3]
 844 002e 012B     		cmp	r3, #1
 845 0030 01D1     		bne	.L59
 497:App/Common/Minimal/blocktim.c **** 	{
 498:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 846              		.loc 1 498 0
 847 0032 0023     		movs	r3, #0
 848 0034 7B60     		str	r3, [r7, #4]
 849              	.L59:
 499:App/Common/Minimal/blocktim.c **** 	}
 500:App/Common/Minimal/blocktim.c **** 
 501:App/Common/Minimal/blocktim.c **** 	xLastSecondaryCycleCount = xSecondaryCycles;
 850              		.loc 1 501 0
 851 0036 094B     		ldr	r3, .L61+8
 852 0038 1A68     		ldr	r2, [r3]
 853 003a 094B     		ldr	r3, .L61+12
 854 003c 1A60     		str	r2, [r3]
 502:App/Common/Minimal/blocktim.c **** 	xLastPrimaryCycleCount = xPrimaryCycles;
 855              		.loc 1 502 0
 856 003e 054B     		ldr	r3, .L61
 857 0040 1A68     		ldr	r2, [r3]
 858 0042 054B     		ldr	r3, .L61+4
 859 0044 1A60     		str	r2, [r3]
 503:App/Common/Minimal/blocktim.c **** 
 504:App/Common/Minimal/blocktim.c **** 	return xReturn;
 860              		.loc 1 504 0
 861 0046 7B68     		ldr	r3, [r7, #4]
 505:App/Common/Minimal/blocktim.c **** }
 862              		.loc 1 505 0
 863 0048 1846     		mov	r0, r3
 864 004a 0C37     		adds	r7, r7, #12
 865 004c BD46     		mov	sp, r7
 866              		@ sp needed
 867 004e 5DF8047B 		ldr	r7, [sp], #4
 868 0052 7047     		bx	lr
 869              	.L62:
 870              		.align	2
 871              	.L61:
 872 0054 00000000 		.word	xPrimaryCycles
 873 0058 00000000 		.word	xLastPrimaryCycleCount.7684
 874 005c 00000000 		.word	xSecondaryCycles
 875 0060 00000000 		.word	xLastSecondaryCycleCount.7685
 876 0064 00000000 		.word	xErrorOccurred
 877              		.cfi_endproc
 878              	.LFE113:
 880              		.section	.bss.xLastPrimaryCycleCount.7684,"aw",%nobits
 881              		.align	2
 884              	xLastPrimaryCycleCount.7684:
 885 0000 00000000 		.space	4
 886              		.section	.bss.xLastSecondaryCycleCount.7685,"aw",%nobits
 887              		.align	2
 890              	xLastSecondaryCycleCount.7685:
 891 0000 00000000 		.space	4
 892              		.text
 893              	.Letext0:
 894              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 895              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 896              		.file 4 "Source/include/task.h"
 897              		.file 5 "Source/include/queue.h"
 898              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 blocktim.c
     /tmp/ccwVu0CE.s:20     .bss.xTestQueue:00000000 $d
     /tmp/ccwVu0CE.s:23     .bss.xTestQueue:00000000 xTestQueue
     /tmp/ccwVu0CE.s:26     .bss.xSecondary:00000000 $d
     /tmp/ccwVu0CE.s:29     .bss.xSecondary:00000000 xSecondary
     /tmp/ccwVu0CE.s:32     .bss.xPrimaryCycles:00000000 $d
     /tmp/ccwVu0CE.s:35     .bss.xPrimaryCycles:00000000 xPrimaryCycles
     /tmp/ccwVu0CE.s:38     .bss.xSecondaryCycles:00000000 $d
     /tmp/ccwVu0CE.s:41     .bss.xSecondaryCycles:00000000 xSecondaryCycles
     /tmp/ccwVu0CE.s:44     .bss.xErrorOccurred:00000000 $d
     /tmp/ccwVu0CE.s:47     .bss.xErrorOccurred:00000000 xErrorOccurred
     /tmp/ccwVu0CE.s:50     .bss.xRunIndicator:00000000 $d
     /tmp/ccwVu0CE.s:53     .bss.xRunIndicator:00000000 xRunIndicator
     /tmp/ccwVu0CE.s:56     .rodata:00000000 $d
     /tmp/ccwVu0CE.s:66     .text.vCreateBlockTimeTasks:00000000 $t
     /tmp/ccwVu0CE.s:71     .text.vCreateBlockTimeTasks:00000000 vCreateBlockTimeTasks
     /tmp/ccwVu0CE.s:138    .text.vCreateBlockTimeTasks:00000060 $d
     /tmp/ccwVu0CE.s:153    .text.vPrimaryBlockTimeTestTask:00000000 vPrimaryBlockTimeTestTask
     /tmp/ccwVu0CE.s:643    .text.vSecondaryBlockTimeTestTask:00000000 vSecondaryBlockTimeTestTask
     /tmp/ccwVu0CE.s:149    .text.vPrimaryBlockTimeTestTask:00000000 $t
     /tmp/ccwVu0CE.s:524    .text.vPrimaryBlockTimeTestTask:00000244 $d
     /tmp/ccwVu0CE.s:530    .text.vPrimaryBlockTimeTestTask:00000254 $t
     /tmp/ccwVu0CE.s:630    .text.vPrimaryBlockTimeTestTask:000002f8 $d
     /tmp/ccwVu0CE.s:639    .text.vSecondaryBlockTimeTestTask:00000000 $t
     /tmp/ccwVu0CE.s:786    .text.vSecondaryBlockTimeTestTask:000000d0 $d
     /tmp/ccwVu0CE.s:794    .text.xAreBlockTimeTestTasksStillRunning:00000000 $t
     /tmp/ccwVu0CE.s:799    .text.xAreBlockTimeTestTasksStillRunning:00000000 xAreBlockTimeTestTasksStillRunning
     /tmp/ccwVu0CE.s:872    .text.xAreBlockTimeTestTasksStillRunning:00000054 $d
     /tmp/ccwVu0CE.s:884    .bss.xLastPrimaryCycleCount.7684:00000000 xLastPrimaryCycleCount.7684
     /tmp/ccwVu0CE.s:890    .bss.xLastSecondaryCycleCount.7685:00000000 xLastSecondaryCycleCount.7685
     /tmp/ccwVu0CE.s:881    .bss.xLastPrimaryCycleCount.7684:00000000 $d
     /tmp/ccwVu0CE.s:887    .bss.xLastSecondaryCycleCount.7685:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericCreate
vQueueAddToRegistry
xTaskGenericCreate
xTaskGetTickCount
xQueueGenericReceive
xQueueGenericSend
vTaskResume
vTaskDelay
vTaskPrioritySet
vTaskSuspend
