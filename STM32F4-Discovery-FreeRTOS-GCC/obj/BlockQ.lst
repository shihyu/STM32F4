   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"BlockQ.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.sBlockingConsumerCount,"aw",%nobits
  20              		.align	2
  23              	sBlockingConsumerCount:
  24 0000 00000000 		.space	6
  24      0000
  25 0006 0000     		.section	.bss.sBlockingProducerCount,"aw",%nobits
  26              		.align	2
  29              	sBlockingProducerCount:
  30 0000 00000000 		.space	6
  30      0000
  31 0006 0000     		.section	.rodata
  32              		.align	2
  33              	.LC0:
  34 0000 51436F6E 		.ascii	"QConsB1\000"
  34      73423100 
  35              		.align	2
  36              	.LC1:
  37 0008 5150726F 		.ascii	"QProdB2\000"
  37      64423200 
  38              		.align	2
  39              	.LC2:
  40 0010 51436F6E 		.ascii	"QConsB3\000"
  40      73423300 
  41              		.align	2
  42              	.LC3:
  43 0018 5150726F 		.ascii	"QProdB4\000"
  43      64423400 
  44              		.align	2
  45              	.LC4:
  46 0020 5150726F 		.ascii	"QProdB5\000"
  46      64423500 
  47              		.align	2
  48              	.LC5:
  49 0028 51436F6E 		.ascii	"QConsB6\000"
  49      73423600 
  50              		.section	.text.vStartBlockingQueueTasks,"ax",%progbits
  51              		.align	2
  52              		.global	vStartBlockingQueueTasks
  53              		.thumb
  54              		.thumb_func
  56              	vStartBlockingQueueTasks:
  57              	.LFB110:
  58              		.file 1 "App/Common/Minimal/BlockQ.c"
   1:App/Common/Minimal/BlockQ.c **** /*
   2:App/Common/Minimal/BlockQ.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/BlockQ.c ****     All rights reserved
   4:App/Common/Minimal/BlockQ.c **** 
   5:App/Common/Minimal/BlockQ.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/BlockQ.c **** 
   7:App/Common/Minimal/BlockQ.c ****     ***************************************************************************
   8:App/Common/Minimal/BlockQ.c ****      *                                                                       *
   9:App/Common/Minimal/BlockQ.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/BlockQ.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/BlockQ.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  13:App/Common/Minimal/BlockQ.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/BlockQ.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/BlockQ.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  17:App/Common/Minimal/BlockQ.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  19:App/Common/Minimal/BlockQ.c ****     ***************************************************************************
  20:App/Common/Minimal/BlockQ.c **** 
  21:App/Common/Minimal/BlockQ.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/BlockQ.c **** 
  23:App/Common/Minimal/BlockQ.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/BlockQ.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/BlockQ.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/BlockQ.c **** 
  27:App/Common/Minimal/BlockQ.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/BlockQ.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/BlockQ.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/BlockQ.c ****     >>! kernel.
  31:App/Common/Minimal/BlockQ.c **** 
  32:App/Common/Minimal/BlockQ.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/BlockQ.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/BlockQ.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/BlockQ.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/BlockQ.c **** 
  37:App/Common/Minimal/BlockQ.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/BlockQ.c **** 
  39:App/Common/Minimal/BlockQ.c ****     ***************************************************************************
  40:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  41:App/Common/Minimal/BlockQ.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/BlockQ.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  44:App/Common/Minimal/BlockQ.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/BlockQ.c ****      *                                                                       *
  46:App/Common/Minimal/BlockQ.c ****     ***************************************************************************
  47:App/Common/Minimal/BlockQ.c **** 
  48:App/Common/Minimal/BlockQ.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/BlockQ.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/BlockQ.c **** 
  51:App/Common/Minimal/BlockQ.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/BlockQ.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/BlockQ.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/BlockQ.c **** 
  55:App/Common/Minimal/BlockQ.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/BlockQ.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/BlockQ.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/BlockQ.c **** 
  59:App/Common/Minimal/BlockQ.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/BlockQ.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/BlockQ.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/BlockQ.c **** 
  63:App/Common/Minimal/BlockQ.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/BlockQ.c **** */
  65:App/Common/Minimal/BlockQ.c **** 
  66:App/Common/Minimal/BlockQ.c **** /*
  67:App/Common/Minimal/BlockQ.c ****  * Creates six tasks that operate on three queues as follows:
  68:App/Common/Minimal/BlockQ.c ****  *
  69:App/Common/Minimal/BlockQ.c ****  * The first two tasks send and receive an incrementing number to/from a queue.
  70:App/Common/Minimal/BlockQ.c ****  * One task acts as a producer and the other as the consumer.  The consumer is a
  71:App/Common/Minimal/BlockQ.c ****  * higher priority than the producer and is set to block on queue reads.  The queue
  72:App/Common/Minimal/BlockQ.c ****  * only has space for one item - as soon as the producer posts a message on the
  73:App/Common/Minimal/BlockQ.c ****  * queue the consumer will unblock, pre-empt the producer, and remove the item.
  74:App/Common/Minimal/BlockQ.c ****  *
  75:App/Common/Minimal/BlockQ.c ****  * The second two tasks work the other way around.  Again the queue used only has
  76:App/Common/Minimal/BlockQ.c ****  * enough space for one item.  This time the consumer has a lower priority than the
  77:App/Common/Minimal/BlockQ.c ****  * producer.  The producer will try to post on the queue blocking when the queue is
  78:App/Common/Minimal/BlockQ.c ****  * full.  When the consumer wakes it will remove the item from the queue, causing
  79:App/Common/Minimal/BlockQ.c ****  * the producer to unblock, pre-empt the consumer, and immediately re-fill the
  80:App/Common/Minimal/BlockQ.c ****  * queue.
  81:App/Common/Minimal/BlockQ.c ****  *
  82:App/Common/Minimal/BlockQ.c ****  * The last two tasks use the same queue producer and consumer functions.  This time the queue has
  83:App/Common/Minimal/BlockQ.c ****  * enough space for lots of items and the tasks operate at the same priority.  The
  84:App/Common/Minimal/BlockQ.c ****  * producer will execute, placing items into the queue.  The consumer will start
  85:App/Common/Minimal/BlockQ.c ****  * executing when either the queue becomes full (causing the producer to block) or
  86:App/Common/Minimal/BlockQ.c ****  * a context switch occurs (tasks of the same priority will time slice).
  87:App/Common/Minimal/BlockQ.c ****  *
  88:App/Common/Minimal/BlockQ.c ****  */
  89:App/Common/Minimal/BlockQ.c **** 
  90:App/Common/Minimal/BlockQ.c **** #include <stdlib.h>
  91:App/Common/Minimal/BlockQ.c **** 
  92:App/Common/Minimal/BlockQ.c **** /* Scheduler include files. */
  93:App/Common/Minimal/BlockQ.c **** #include "FreeRTOS.h"
  94:App/Common/Minimal/BlockQ.c **** #include "task.h"
  95:App/Common/Minimal/BlockQ.c **** #include "queue.h"
  96:App/Common/Minimal/BlockQ.c **** 
  97:App/Common/Minimal/BlockQ.c **** /* Demo program include files. */
  98:App/Common/Minimal/BlockQ.c **** #include "BlockQ.h"
  99:App/Common/Minimal/BlockQ.c **** 
 100:App/Common/Minimal/BlockQ.c **** #define blckqSTACK_SIZE		configMINIMAL_STACK_SIZE
 101:App/Common/Minimal/BlockQ.c **** #define blckqNUM_TASK_SETS	( 3 )
 102:App/Common/Minimal/BlockQ.c **** 
 103:App/Common/Minimal/BlockQ.c **** /* Structure used to pass parameters to the blocking queue tasks. */
 104:App/Common/Minimal/BlockQ.c **** typedef struct BLOCKING_QUEUE_PARAMETERS
 105:App/Common/Minimal/BlockQ.c **** {
 106:App/Common/Minimal/BlockQ.c **** 	xQueueHandle xQueue;					/*< The queue to be used by the task. */
 107:App/Common/Minimal/BlockQ.c **** 	portTickType xBlockTime;				/*< The block time to use on queue reads/writes. */
 108:App/Common/Minimal/BlockQ.c **** 	volatile short *psCheckVariable;	/*< Incremented on each successful cycle to check the task is sti
 109:App/Common/Minimal/BlockQ.c **** } xBlockingQueueParameters;
 110:App/Common/Minimal/BlockQ.c **** 
 111:App/Common/Minimal/BlockQ.c **** /* Task function that creates an incrementing number and posts it on a queue. */
 112:App/Common/Minimal/BlockQ.c **** static portTASK_FUNCTION_PROTO( vBlockingQueueProducer, pvParameters );
 113:App/Common/Minimal/BlockQ.c **** 
 114:App/Common/Minimal/BlockQ.c **** /* Task function that removes the incrementing number from a queue and checks that
 115:App/Common/Minimal/BlockQ.c **** it is the expected number. */
 116:App/Common/Minimal/BlockQ.c **** static portTASK_FUNCTION_PROTO( vBlockingQueueConsumer, pvParameters );
 117:App/Common/Minimal/BlockQ.c **** 
 118:App/Common/Minimal/BlockQ.c **** /* Variables which are incremented each time an item is removed from a queue, and
 119:App/Common/Minimal/BlockQ.c **** found to be the expected value.
 120:App/Common/Minimal/BlockQ.c **** These are used to check that the tasks are still running. */
 121:App/Common/Minimal/BlockQ.c **** static volatile short sBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsi
 122:App/Common/Minimal/BlockQ.c **** 
 123:App/Common/Minimal/BlockQ.c **** /* Variable which are incremented each time an item is posted on a queue.   These
 124:App/Common/Minimal/BlockQ.c **** are used to check that the tasks are still running. */
 125:App/Common/Minimal/BlockQ.c **** static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsi
 126:App/Common/Minimal/BlockQ.c **** 
 127:App/Common/Minimal/BlockQ.c **** /*-----------------------------------------------------------*/
 128:App/Common/Minimal/BlockQ.c **** 
 129:App/Common/Minimal/BlockQ.c **** void vStartBlockingQueueTasks( unsigned portBASE_TYPE uxPriority )
 130:App/Common/Minimal/BlockQ.c **** {
  59              		.loc 1 130 0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 48
  62              		@ frame_needed = 1, uses_anonymous_args = 0
  63 0000 80B5     		push	{r7, lr}
  64              	.LCFI0:
  65              		.cfi_def_cfa_offset 8
  66              		.cfi_offset 7, -8
  67              		.cfi_offset 14, -4
  68 0002 90B0     		sub	sp, sp, #64
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 72
  71 0004 04AF     		add	r7, sp, #16
  72              	.LCFI2:
  73              		.cfi_def_cfa 7, 56
  74 0006 7860     		str	r0, [r7, #4]
 131:App/Common/Minimal/BlockQ.c **** xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
 132:App/Common/Minimal/BlockQ.c **** xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
 133:App/Common/Minimal/BlockQ.c **** xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
 134:App/Common/Minimal/BlockQ.c **** const unsigned portBASE_TYPE uxQueueSize1 = 1, uxQueueSize5 = 5;
  75              		.loc 1 134 0
  76 0008 0123     		movs	r3, #1
  77 000a FB62     		str	r3, [r7, #44]
  78 000c 0523     		movs	r3, #5
  79 000e BB62     		str	r3, [r7, #40]
 135:App/Common/Minimal/BlockQ.c **** const portTickType xBlockTime = ( portTickType ) 1000 / portTICK_RATE_MS;
  80              		.loc 1 135 0
  81 0010 4FF47A73 		mov	r3, #1000
  82 0014 7B62     		str	r3, [r7, #36]
 136:App/Common/Minimal/BlockQ.c **** const portTickType xDontBlock = ( portTickType ) 0;
  83              		.loc 1 136 0
  84 0016 0023     		movs	r3, #0
  85 0018 3B62     		str	r3, [r7, #32]
 137:App/Common/Minimal/BlockQ.c **** 
 138:App/Common/Minimal/BlockQ.c **** 	/* Create the first two tasks as described at the top of the file. */
 139:App/Common/Minimal/BlockQ.c **** 	
 140:App/Common/Minimal/BlockQ.c **** 	/* First create the structure used to pass parameters to the consumer tasks. */
 141:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
  86              		.loc 1 141 0
  87 001a 0C20     		movs	r0, #12
  88 001c FFF7FEFF 		bl	pvPortMalloc
  89 0020 F861     		str	r0, [r7, #28]
 142:App/Common/Minimal/BlockQ.c **** 
 143:App/Common/Minimal/BlockQ.c **** 	/* Create the queue used by the first two tasks to pass the incrementing number.
 144:App/Common/Minimal/BlockQ.c **** 	Pass a pointer to the queue in the parameter structure. */
 145:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsign
  90              		.loc 1 145 0
  91 0022 F86A     		ldr	r0, [r7, #44]
  92 0024 0221     		movs	r1, #2
  93 0026 0022     		movs	r2, #0
  94 0028 FFF7FEFF 		bl	xQueueGenericCreate
  95 002c 0246     		mov	r2, r0
  96 002e FB69     		ldr	r3, [r7, #28]
  97 0030 1A60     		str	r2, [r3]
 146:App/Common/Minimal/BlockQ.c **** 
 147:App/Common/Minimal/BlockQ.c **** 	/* The consumer is created first so gets a block time as described above. */
 148:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters1->xBlockTime = xBlockTime;
  98              		.loc 1 148 0
  99 0032 FB69     		ldr	r3, [r7, #28]
 100 0034 7A6A     		ldr	r2, [r7, #36]
 101 0036 5A60     		str	r2, [r3, #4]
 149:App/Common/Minimal/BlockQ.c **** 
 150:App/Common/Minimal/BlockQ.c **** 	/* Pass in the variable that this task is going to increment so we can check it
 151:App/Common/Minimal/BlockQ.c **** 	is still running. */
 152:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
 102              		.loc 1 152 0
 103 0038 FB69     		ldr	r3, [r7, #28]
 104 003a 534A     		ldr	r2, .L2
 105 003c 9A60     		str	r2, [r3, #8]
 153:App/Common/Minimal/BlockQ.c **** 		
 154:App/Common/Minimal/BlockQ.c **** 	/* Create the structure used to pass parameters to the producer task. */
 155:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
 106              		.loc 1 155 0
 107 003e 0C20     		movs	r0, #12
 108 0040 FFF7FEFF 		bl	pvPortMalloc
 109 0044 B861     		str	r0, [r7, #24]
 156:App/Common/Minimal/BlockQ.c **** 
 157:App/Common/Minimal/BlockQ.c **** 	/* Pass the queue to this task also, using the parameter structure. */
 158:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
 110              		.loc 1 158 0
 111 0046 FB69     		ldr	r3, [r7, #28]
 112 0048 1A68     		ldr	r2, [r3]
 113 004a BB69     		ldr	r3, [r7, #24]
 114 004c 1A60     		str	r2, [r3]
 159:App/Common/Minimal/BlockQ.c **** 
 160:App/Common/Minimal/BlockQ.c **** 	/* The producer is not going to block - as soon as it posts the consumer will
 161:App/Common/Minimal/BlockQ.c **** 	wake and remove the item so the producer should always have room to post. */
 162:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters2->xBlockTime = xDontBlock;
 115              		.loc 1 162 0
 116 004e BB69     		ldr	r3, [r7, #24]
 117 0050 3A6A     		ldr	r2, [r7, #32]
 118 0052 5A60     		str	r2, [r3, #4]
 163:App/Common/Minimal/BlockQ.c **** 
 164:App/Common/Minimal/BlockQ.c **** 	/* Pass in the variable that this task is going to increment so we can check
 165:App/Common/Minimal/BlockQ.c **** 	it is still running. */
 166:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
 119              		.loc 1 166 0
 120 0054 BB69     		ldr	r3, [r7, #24]
 121 0056 4D4A     		ldr	r2, .L2+4
 122 0058 9A60     		str	r2, [r3, #8]
 167:App/Common/Minimal/BlockQ.c **** 
 168:App/Common/Minimal/BlockQ.c **** 
 169:App/Common/Minimal/BlockQ.c **** 	/* Note the producer has a lower priority than the consumer when the tasks are
 170:App/Common/Minimal/BlockQ.c **** 	spawned. */
 171:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQu
 123              		.loc 1 171 0
 124 005a 7B68     		ldr	r3, [r7, #4]
 125 005c 0093     		str	r3, [sp]
 126 005e 0023     		movs	r3, #0
 127 0060 0193     		str	r3, [sp, #4]
 128 0062 0023     		movs	r3, #0
 129 0064 0293     		str	r3, [sp, #8]
 130 0066 0023     		movs	r3, #0
 131 0068 0393     		str	r3, [sp, #12]
 132 006a 4948     		ldr	r0, .L2+8
 133 006c 4949     		ldr	r1, .L2+12
 134 006e 8222     		movs	r2, #130
 135 0070 FB69     		ldr	r3, [r7, #28]
 136 0072 FFF7FEFF 		bl	xTaskGenericCreate
 172:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQu
 137              		.loc 1 172 0
 138 0076 0023     		movs	r3, #0
 139 0078 0093     		str	r3, [sp]
 140 007a 0023     		movs	r3, #0
 141 007c 0193     		str	r3, [sp, #4]
 142 007e 0023     		movs	r3, #0
 143 0080 0293     		str	r3, [sp, #8]
 144 0082 0023     		movs	r3, #0
 145 0084 0393     		str	r3, [sp, #12]
 146 0086 4448     		ldr	r0, .L2+16
 147 0088 4449     		ldr	r1, .L2+20
 148 008a 8222     		movs	r2, #130
 149 008c BB69     		ldr	r3, [r7, #24]
 150 008e FFF7FEFF 		bl	xTaskGenericCreate
 173:App/Common/Minimal/BlockQ.c **** 
 174:App/Common/Minimal/BlockQ.c **** 	
 175:App/Common/Minimal/BlockQ.c **** 
 176:App/Common/Minimal/BlockQ.c **** 	/* Create the second two tasks as described at the top of the file.   This uses
 177:App/Common/Minimal/BlockQ.c **** 	the same mechanism but reverses the task priorities. */
 178:App/Common/Minimal/BlockQ.c **** 
 179:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
 151              		.loc 1 179 0
 152 0092 0C20     		movs	r0, #12
 153 0094 FFF7FEFF 		bl	pvPortMalloc
 154 0098 7861     		str	r0, [r7, #20]
 180:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsign
 155              		.loc 1 180 0
 156 009a F86A     		ldr	r0, [r7, #44]
 157 009c 0221     		movs	r1, #2
 158 009e 0022     		movs	r2, #0
 159 00a0 FFF7FEFF 		bl	xQueueGenericCreate
 160 00a4 0246     		mov	r2, r0
 161 00a6 7B69     		ldr	r3, [r7, #20]
 162 00a8 1A60     		str	r2, [r3]
 181:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters3->xBlockTime = xDontBlock;
 163              		.loc 1 181 0
 164 00aa 7B69     		ldr	r3, [r7, #20]
 165 00ac 3A6A     		ldr	r2, [r7, #32]
 166 00ae 5A60     		str	r2, [r3, #4]
 182:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
 167              		.loc 1 182 0
 168 00b0 7B69     		ldr	r3, [r7, #20]
 169 00b2 3B4A     		ldr	r2, .L2+24
 170 00b4 9A60     		str	r2, [r3, #8]
 183:App/Common/Minimal/BlockQ.c **** 
 184:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
 171              		.loc 1 184 0
 172 00b6 0C20     		movs	r0, #12
 173 00b8 FFF7FEFF 		bl	pvPortMalloc
 174 00bc 3861     		str	r0, [r7, #16]
 185:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
 175              		.loc 1 185 0
 176 00be 7B69     		ldr	r3, [r7, #20]
 177 00c0 1A68     		ldr	r2, [r3]
 178 00c2 3B69     		ldr	r3, [r7, #16]
 179 00c4 1A60     		str	r2, [r3]
 186:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters4->xBlockTime = xBlockTime;
 180              		.loc 1 186 0
 181 00c6 3B69     		ldr	r3, [r7, #16]
 182 00c8 7A6A     		ldr	r2, [r7, #36]
 183 00ca 5A60     		str	r2, [r3, #4]
 187:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
 184              		.loc 1 187 0
 185 00cc 3B69     		ldr	r3, [r7, #16]
 186 00ce 354A     		ldr	r2, .L2+28
 187 00d0 9A60     		str	r2, [r3, #8]
 188:App/Common/Minimal/BlockQ.c **** 
 189:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB3", blckqSTACK_SIZE, ( void * ) pxQu
 188              		.loc 1 189 0
 189 00d2 0023     		movs	r3, #0
 190 00d4 0093     		str	r3, [sp]
 191 00d6 0023     		movs	r3, #0
 192 00d8 0193     		str	r3, [sp, #4]
 193 00da 0023     		movs	r3, #0
 194 00dc 0293     		str	r3, [sp, #8]
 195 00de 0023     		movs	r3, #0
 196 00e0 0393     		str	r3, [sp, #12]
 197 00e2 2B48     		ldr	r0, .L2+8
 198 00e4 3049     		ldr	r1, .L2+32
 199 00e6 8222     		movs	r2, #130
 200 00e8 7B69     		ldr	r3, [r7, #20]
 201 00ea FFF7FEFF 		bl	xTaskGenericCreate
 190:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB4", blckqSTACK_SIZE, ( void * ) pxQu
 202              		.loc 1 190 0
 203 00ee 7B68     		ldr	r3, [r7, #4]
 204 00f0 0093     		str	r3, [sp]
 205 00f2 0023     		movs	r3, #0
 206 00f4 0193     		str	r3, [sp, #4]
 207 00f6 0023     		movs	r3, #0
 208 00f8 0293     		str	r3, [sp, #8]
 209 00fa 0023     		movs	r3, #0
 210 00fc 0393     		str	r3, [sp, #12]
 211 00fe 2648     		ldr	r0, .L2+16
 212 0100 2A49     		ldr	r1, .L2+36
 213 0102 8222     		movs	r2, #130
 214 0104 3B69     		ldr	r3, [r7, #16]
 215 0106 FFF7FEFF 		bl	xTaskGenericCreate
 191:App/Common/Minimal/BlockQ.c **** 
 192:App/Common/Minimal/BlockQ.c **** 
 193:App/Common/Minimal/BlockQ.c **** 
 194:App/Common/Minimal/BlockQ.c **** 	/* Create the last two tasks as described above.  The mechanism is again just
 195:App/Common/Minimal/BlockQ.c **** 	the same.  This time both parameter structures are given a block time. */
 196:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
 216              		.loc 1 196 0
 217 010a 0C20     		movs	r0, #12
 218 010c FFF7FEFF 		bl	pvPortMalloc
 219 0110 F860     		str	r0, [r7, #12]
 197:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsign
 220              		.loc 1 197 0
 221 0112 B86A     		ldr	r0, [r7, #40]
 222 0114 0221     		movs	r1, #2
 223 0116 0022     		movs	r2, #0
 224 0118 FFF7FEFF 		bl	xQueueGenericCreate
 225 011c 0246     		mov	r2, r0
 226 011e FB68     		ldr	r3, [r7, #12]
 227 0120 1A60     		str	r2, [r3]
 198:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters5->xBlockTime = xBlockTime;
 228              		.loc 1 198 0
 229 0122 FB68     		ldr	r3, [r7, #12]
 230 0124 7A6A     		ldr	r2, [r7, #36]
 231 0126 5A60     		str	r2, [r3, #4]
 199:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
 232              		.loc 1 199 0
 233 0128 FB68     		ldr	r3, [r7, #12]
 234 012a 214A     		ldr	r2, .L2+40
 235 012c 9A60     		str	r2, [r3, #8]
 200:App/Common/Minimal/BlockQ.c **** 
 201:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters
 236              		.loc 1 201 0
 237 012e 0C20     		movs	r0, #12
 238 0130 FFF7FEFF 		bl	pvPortMalloc
 239 0134 B860     		str	r0, [r7, #8]
 202:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
 240              		.loc 1 202 0
 241 0136 FB68     		ldr	r3, [r7, #12]
 242 0138 1A68     		ldr	r2, [r3]
 243 013a BB68     		ldr	r3, [r7, #8]
 244 013c 1A60     		str	r2, [r3]
 203:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters6->xBlockTime = xBlockTime;
 245              		.loc 1 203 0
 246 013e BB68     		ldr	r3, [r7, #8]
 247 0140 7A6A     		ldr	r2, [r7, #36]
 248 0142 5A60     		str	r2, [r3, #4]
 204:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	
 249              		.loc 1 204 0
 250 0144 BB68     		ldr	r3, [r7, #8]
 251 0146 1B4A     		ldr	r2, .L2+44
 252 0148 9A60     		str	r2, [r3, #8]
 205:App/Common/Minimal/BlockQ.c **** 
 206:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQu
 253              		.loc 1 206 0
 254 014a 0023     		movs	r3, #0
 255 014c 0093     		str	r3, [sp]
 256 014e 0023     		movs	r3, #0
 257 0150 0193     		str	r3, [sp, #4]
 258 0152 0023     		movs	r3, #0
 259 0154 0293     		str	r3, [sp, #8]
 260 0156 0023     		movs	r3, #0
 261 0158 0393     		str	r3, [sp, #12]
 262 015a 0F48     		ldr	r0, .L2+16
 263 015c 1649     		ldr	r1, .L2+48
 264 015e 8222     		movs	r2, #130
 265 0160 FB68     		ldr	r3, [r7, #12]
 266 0162 FFF7FEFF 		bl	xTaskGenericCreate
 207:App/Common/Minimal/BlockQ.c **** 	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQu
 267              		.loc 1 207 0
 268 0166 0023     		movs	r3, #0
 269 0168 0093     		str	r3, [sp]
 270 016a 0023     		movs	r3, #0
 271 016c 0193     		str	r3, [sp, #4]
 272 016e 0023     		movs	r3, #0
 273 0170 0293     		str	r3, [sp, #8]
 274 0172 0023     		movs	r3, #0
 275 0174 0393     		str	r3, [sp, #12]
 276 0176 0648     		ldr	r0, .L2+8
 277 0178 1049     		ldr	r1, .L2+52
 278 017a 8222     		movs	r2, #130
 279 017c BB68     		ldr	r3, [r7, #8]
 280 017e FFF7FEFF 		bl	xTaskGenericCreate
 208:App/Common/Minimal/BlockQ.c **** }
 281              		.loc 1 208 0
 282 0182 3037     		adds	r7, r7, #48
 283 0184 BD46     		mov	sp, r7
 284              		@ sp needed
 285 0186 80BD     		pop	{r7, pc}
 286              	.L3:
 287              		.align	2
 288              	.L2:
 289 0188 00000000 		.word	sBlockingConsumerCount
 290 018c 00000000 		.word	sBlockingProducerCount
 291 0190 00000000 		.word	vBlockingQueueConsumer
 292 0194 00000000 		.word	.LC0
 293 0198 00000000 		.word	vBlockingQueueProducer
 294 019c 08000000 		.word	.LC1
 295 01a0 02000000 		.word	sBlockingProducerCount+2
 296 01a4 02000000 		.word	sBlockingConsumerCount+2
 297 01a8 10000000 		.word	.LC2
 298 01ac 18000000 		.word	.LC3
 299 01b0 04000000 		.word	sBlockingProducerCount+4
 300 01b4 04000000 		.word	sBlockingConsumerCount+4
 301 01b8 20000000 		.word	.LC4
 302 01bc 28000000 		.word	.LC5
 303              		.cfi_endproc
 304              	.LFE110:
 306              		.section	.text.vBlockingQueueProducer,"ax",%progbits
 307              		.align	2
 308              		.thumb
 309              		.thumb_func
 311              	vBlockingQueueProducer:
 312              	.LFB111:
 209:App/Common/Minimal/BlockQ.c **** /*-----------------------------------------------------------*/
 210:App/Common/Minimal/BlockQ.c **** 
 211:App/Common/Minimal/BlockQ.c **** static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
 212:App/Common/Minimal/BlockQ.c **** {
 313              		.loc 1 212 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 24
 316              		@ frame_needed = 1, uses_anonymous_args = 0
 317 0000 80B5     		push	{r7, lr}
 318              	.LCFI3:
 319              		.cfi_def_cfa_offset 8
 320              		.cfi_offset 7, -8
 321              		.cfi_offset 14, -4
 322 0002 86B0     		sub	sp, sp, #24
 323              	.LCFI4:
 324              		.cfi_def_cfa_offset 32
 325 0004 00AF     		add	r7, sp, #0
 326              	.LCFI5:
 327              		.cfi_def_cfa_register 7
 328 0006 7860     		str	r0, [r7, #4]
 213:App/Common/Minimal/BlockQ.c **** unsigned short usValue = 0;
 329              		.loc 1 213 0
 330 0008 0023     		movs	r3, #0
 331 000a FB81     		strh	r3, [r7, #14]	@ movhi
 214:App/Common/Minimal/BlockQ.c **** xBlockingQueueParameters *pxQueueParameters;
 215:App/Common/Minimal/BlockQ.c **** short sErrorEverOccurred = pdFALSE;
 332              		.loc 1 215 0
 333 000c 0023     		movs	r3, #0
 334 000e FB82     		strh	r3, [r7, #22]	@ movhi
 216:App/Common/Minimal/BlockQ.c **** 
 217:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 335              		.loc 1 217 0
 336 0010 7B68     		ldr	r3, [r7, #4]
 337 0012 3B61     		str	r3, [r7, #16]
 338              	.L8:
 218:App/Common/Minimal/BlockQ.c **** 
 219:App/Common/Minimal/BlockQ.c **** 	for( ;; )
 220:App/Common/Minimal/BlockQ.c **** 	{		
 221:App/Common/Minimal/BlockQ.c **** 		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) !
 339              		.loc 1 221 0
 340 0014 3B69     		ldr	r3, [r7, #16]
 341 0016 1968     		ldr	r1, [r3]
 342 0018 3B69     		ldr	r3, [r7, #16]
 343 001a 5B68     		ldr	r3, [r3, #4]
 344 001c 07F10E02 		add	r2, r7, #14
 345 0020 0846     		mov	r0, r1
 346 0022 1146     		mov	r1, r2
 347 0024 1A46     		mov	r2, r3
 348 0026 0023     		movs	r3, #0
 349 0028 FFF7FEFF 		bl	xQueueGenericSend
 350 002c 0346     		mov	r3, r0
 351 002e 012B     		cmp	r3, #1
 352 0030 02D0     		beq	.L5
 222:App/Common/Minimal/BlockQ.c **** 		{
 223:App/Common/Minimal/BlockQ.c **** 			sErrorEverOccurred = pdTRUE;
 353              		.loc 1 223 0
 354 0032 0123     		movs	r3, #1
 355 0034 FB82     		strh	r3, [r7, #22]	@ movhi
 224:App/Common/Minimal/BlockQ.c **** 		}
 225:App/Common/Minimal/BlockQ.c **** 		else
 226:App/Common/Minimal/BlockQ.c **** 		{
 227:App/Common/Minimal/BlockQ.c **** 			/* We have successfully posted a message, so increment the variable
 228:App/Common/Minimal/BlockQ.c **** 			used to check we are still running. */
 229:App/Common/Minimal/BlockQ.c **** 			if( sErrorEverOccurred == pdFALSE )
 230:App/Common/Minimal/BlockQ.c **** 			{
 231:App/Common/Minimal/BlockQ.c **** 				( *pxQueueParameters->psCheckVariable )++;
 232:App/Common/Minimal/BlockQ.c **** 			}
 233:App/Common/Minimal/BlockQ.c **** 
 234:App/Common/Minimal/BlockQ.c **** 			/* Increment the variable we are going to post next time round.  The
 235:App/Common/Minimal/BlockQ.c **** 			consumer will expect the numbers to	follow in numerical order. */
 236:App/Common/Minimal/BlockQ.c **** 			++usValue;
 237:App/Common/Minimal/BlockQ.c **** 		}
 238:App/Common/Minimal/BlockQ.c **** 	}
 356              		.loc 1 238 0
 357 0036 EDE7     		b	.L8
 358              	.L5:
 229:App/Common/Minimal/BlockQ.c **** 			if( sErrorEverOccurred == pdFALSE )
 359              		.loc 1 229 0
 360 0038 B7F91630 		ldrsh	r3, [r7, #22]
 361 003c 002B     		cmp	r3, #0
 362 003e 07D1     		bne	.L7
 231:App/Common/Minimal/BlockQ.c **** 				( *pxQueueParameters->psCheckVariable )++;
 363              		.loc 1 231 0
 364 0040 3B69     		ldr	r3, [r7, #16]
 365 0042 9A68     		ldr	r2, [r3, #8]
 366 0044 1388     		ldrh	r3, [r2]	@ movhi
 367 0046 9BB2     		uxth	r3, r3
 368 0048 9BB2     		uxth	r3, r3
 369 004a 0133     		adds	r3, r3, #1
 370 004c 9BB2     		uxth	r3, r3
 371 004e 1380     		strh	r3, [r2]	@ movhi
 372              	.L7:
 236:App/Common/Minimal/BlockQ.c **** 			++usValue;
 373              		.loc 1 236 0
 374 0050 FB89     		ldrh	r3, [r7, #14]
 375 0052 0133     		adds	r3, r3, #1
 376 0054 9BB2     		uxth	r3, r3
 377 0056 FB81     		strh	r3, [r7, #14]	@ movhi
 378              		.loc 1 238 0
 379 0058 DCE7     		b	.L8
 380              		.cfi_endproc
 381              	.LFE111:
 383 005a 00BF     		.section	.text.vBlockingQueueConsumer,"ax",%progbits
 384              		.align	2
 385              		.thumb
 386              		.thumb_func
 388              	vBlockingQueueConsumer:
 389              	.LFB112:
 239:App/Common/Minimal/BlockQ.c **** }
 240:App/Common/Minimal/BlockQ.c **** /*-----------------------------------------------------------*/
 241:App/Common/Minimal/BlockQ.c **** 
 242:App/Common/Minimal/BlockQ.c **** static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
 243:App/Common/Minimal/BlockQ.c **** {
 390              		.loc 1 243 0
 391              		.cfi_startproc
 392              		@ args = 0, pretend = 0, frame = 24
 393              		@ frame_needed = 1, uses_anonymous_args = 0
 394 0000 80B5     		push	{r7, lr}
 395              	.LCFI6:
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 7, -8
 398              		.cfi_offset 14, -4
 399 0002 86B0     		sub	sp, sp, #24
 400              	.LCFI7:
 401              		.cfi_def_cfa_offset 32
 402 0004 00AF     		add	r7, sp, #0
 403              	.LCFI8:
 404              		.cfi_def_cfa_register 7
 405 0006 7860     		str	r0, [r7, #4]
 244:App/Common/Minimal/BlockQ.c **** unsigned short usData, usExpectedValue = 0;
 406              		.loc 1 244 0
 407 0008 0023     		movs	r3, #0
 408 000a FB82     		strh	r3, [r7, #22]	@ movhi
 245:App/Common/Minimal/BlockQ.c **** xBlockingQueueParameters *pxQueueParameters;
 246:App/Common/Minimal/BlockQ.c **** short sErrorEverOccurred = pdFALSE;
 409              		.loc 1 246 0
 410 000c 0023     		movs	r3, #0
 411 000e BB82     		strh	r3, [r7, #20]	@ movhi
 247:App/Common/Minimal/BlockQ.c **** 
 248:App/Common/Minimal/BlockQ.c **** 	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 412              		.loc 1 248 0
 413 0010 7B68     		ldr	r3, [r7, #4]
 414 0012 3B61     		str	r3, [r7, #16]
 415              	.L13:
 249:App/Common/Minimal/BlockQ.c **** 
 250:App/Common/Minimal/BlockQ.c **** 	for( ;; )
 251:App/Common/Minimal/BlockQ.c **** 	{	
 252:App/Common/Minimal/BlockQ.c **** 		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS 
 416              		.loc 1 252 0
 417 0014 3B69     		ldr	r3, [r7, #16]
 418 0016 1968     		ldr	r1, [r3]
 419 0018 3B69     		ldr	r3, [r7, #16]
 420 001a 5B68     		ldr	r3, [r3, #4]
 421 001c 07F10E02 		add	r2, r7, #14
 422 0020 0846     		mov	r0, r1
 423 0022 1146     		mov	r1, r2
 424 0024 1A46     		mov	r2, r3
 425 0026 0023     		movs	r3, #0
 426 0028 FFF7FEFF 		bl	xQueueGenericReceive
 427 002c 0346     		mov	r3, r0
 428 002e 012B     		cmp	r3, #1
 429 0030 18D1     		bne	.L10
 253:App/Common/Minimal/BlockQ.c **** 		{
 254:App/Common/Minimal/BlockQ.c **** 			if( usData != usExpectedValue )
 430              		.loc 1 254 0
 431 0032 FB89     		ldrh	r3, [r7, #14]
 432 0034 FA8A     		ldrh	r2, [r7, #22]
 433 0036 9A42     		cmp	r2, r3
 434 0038 04D0     		beq	.L11
 255:App/Common/Minimal/BlockQ.c **** 			{
 256:App/Common/Minimal/BlockQ.c **** 				/* Catch-up. */
 257:App/Common/Minimal/BlockQ.c **** 				usExpectedValue = usData;
 435              		.loc 1 257 0
 436 003a FB89     		ldrh	r3, [r7, #14]	@ movhi
 437 003c FB82     		strh	r3, [r7, #22]	@ movhi
 258:App/Common/Minimal/BlockQ.c **** 
 259:App/Common/Minimal/BlockQ.c **** 				sErrorEverOccurred = pdTRUE;
 438              		.loc 1 259 0
 439 003e 0123     		movs	r3, #1
 440 0040 BB82     		strh	r3, [r7, #20]	@ movhi
 441 0042 0FE0     		b	.L10
 442              	.L11:
 260:App/Common/Minimal/BlockQ.c **** 			}
 261:App/Common/Minimal/BlockQ.c **** 			else
 262:App/Common/Minimal/BlockQ.c **** 			{
 263:App/Common/Minimal/BlockQ.c **** 				/* We have successfully received a message, so increment the
 264:App/Common/Minimal/BlockQ.c **** 				variable used to check we are still running. */	
 265:App/Common/Minimal/BlockQ.c **** 				if( sErrorEverOccurred == pdFALSE )
 443              		.loc 1 265 0
 444 0044 B7F91430 		ldrsh	r3, [r7, #20]
 445 0048 002B     		cmp	r3, #0
 446 004a 07D1     		bne	.L12
 266:App/Common/Minimal/BlockQ.c **** 				{
 267:App/Common/Minimal/BlockQ.c **** 					( *pxQueueParameters->psCheckVariable )++;
 447              		.loc 1 267 0
 448 004c 3B69     		ldr	r3, [r7, #16]
 449 004e 9A68     		ldr	r2, [r3, #8]
 450 0050 1388     		ldrh	r3, [r2]	@ movhi
 451 0052 9BB2     		uxth	r3, r3
 452 0054 9BB2     		uxth	r3, r3
 453 0056 0133     		adds	r3, r3, #1
 454 0058 9BB2     		uxth	r3, r3
 455 005a 1380     		strh	r3, [r2]	@ movhi
 456              	.L12:
 268:App/Common/Minimal/BlockQ.c **** 				}
 269:App/Common/Minimal/BlockQ.c **** 							
 270:App/Common/Minimal/BlockQ.c **** 				/* Increment the value we expect to remove from the queue next time
 271:App/Common/Minimal/BlockQ.c **** 				round. */
 272:App/Common/Minimal/BlockQ.c **** 				++usExpectedValue;
 457              		.loc 1 272 0
 458 005c FB8A     		ldrh	r3, [r7, #22]	@ movhi
 459 005e 0133     		adds	r3, r3, #1
 460 0060 FB82     		strh	r3, [r7, #22]	@ movhi
 273:App/Common/Minimal/BlockQ.c **** 			}			
 274:App/Common/Minimal/BlockQ.c **** 		}		
 275:App/Common/Minimal/BlockQ.c **** 	}
 461              		.loc 1 275 0
 462 0062 D7E7     		b	.L13
 463              	.L10:
 464 0064 D6E7     		b	.L13
 465              		.cfi_endproc
 466              	.LFE112:
 468              		.section	.text.xAreBlockingQueuesStillRunning,"ax",%progbits
 469              		.align	2
 470              		.global	xAreBlockingQueuesStillRunning
 471              		.thumb
 472              		.thumb_func
 474              	xAreBlockingQueuesStillRunning:
 475              	.LFB113:
 276:App/Common/Minimal/BlockQ.c **** }
 277:App/Common/Minimal/BlockQ.c **** /*-----------------------------------------------------------*/
 278:App/Common/Minimal/BlockQ.c **** 
 279:App/Common/Minimal/BlockQ.c **** /* This is called to check that all the created tasks are still running. */
 280:App/Common/Minimal/BlockQ.c **** portBASE_TYPE xAreBlockingQueuesStillRunning( void )
 281:App/Common/Minimal/BlockQ.c **** {
 476              		.loc 1 281 0
 477              		.cfi_startproc
 478              		@ args = 0, pretend = 0, frame = 8
 479              		@ frame_needed = 1, uses_anonymous_args = 0
 480              		@ link register save eliminated.
 481 0000 80B4     		push	{r7}
 482              	.LCFI9:
 483              		.cfi_def_cfa_offset 4
 484              		.cfi_offset 7, -4
 485 0002 83B0     		sub	sp, sp, #12
 486              	.LCFI10:
 487              		.cfi_def_cfa_offset 16
 488 0004 00AF     		add	r7, sp, #0
 489              	.LCFI11:
 490              		.cfi_def_cfa_register 7
 282:App/Common/Minimal/BlockQ.c **** static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned 
 283:App/Common/Minimal/BlockQ.c **** static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned 
 284:App/Common/Minimal/BlockQ.c **** portBASE_TYPE xReturn = pdPASS, xTasks;
 491              		.loc 1 284 0
 492 0006 0123     		movs	r3, #1
 493 0008 7B60     		str	r3, [r7, #4]
 285:App/Common/Minimal/BlockQ.c **** 
 286:App/Common/Minimal/BlockQ.c **** 	/* Not too worried about mutual exclusion on these variables as they are 16
 287:App/Common/Minimal/BlockQ.c **** 	bits and we are only reading them. We also only care to see if they have
 288:App/Common/Minimal/BlockQ.c **** 	changed or not.
 289:App/Common/Minimal/BlockQ.c **** 	
 290:App/Common/Minimal/BlockQ.c **** 	Loop through each check variable to and return pdFALSE if any are found not
 291:App/Common/Minimal/BlockQ.c **** 	to have changed since the last call. */
 292:App/Common/Minimal/BlockQ.c **** 
 293:App/Common/Minimal/BlockQ.c **** 	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 494              		.loc 1 293 0
 495 000a 0023     		movs	r3, #0
 496 000c 3B60     		str	r3, [r7]
 497 000e 32E0     		b	.L15
 498              	.L18:
 294:App/Common/Minimal/BlockQ.c **** 	{
 295:App/Common/Minimal/BlockQ.c **** 		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
 499              		.loc 1 295 0
 500 0010 1E4B     		ldr	r3, .L20
 501 0012 3A68     		ldr	r2, [r7]
 502 0014 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 503 0018 9AB2     		uxth	r2, r3
 504 001a 1D4B     		ldr	r3, .L20+4
 505 001c 3968     		ldr	r1, [r7]
 506 001e 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 507 0022 12B2     		sxth	r2, r2
 508 0024 1BB2     		sxth	r3, r3
 509 0026 9A42     		cmp	r2, r3
 510 0028 01D1     		bne	.L16
 296:App/Common/Minimal/BlockQ.c **** 		{
 297:App/Common/Minimal/BlockQ.c **** 			xReturn = pdFALSE;
 511              		.loc 1 297 0
 512 002a 0023     		movs	r3, #0
 513 002c 7B60     		str	r3, [r7, #4]
 514              	.L16:
 298:App/Common/Minimal/BlockQ.c **** 		}
 299:App/Common/Minimal/BlockQ.c **** 		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
 515              		.loc 1 299 0
 516 002e 174B     		ldr	r3, .L20
 517 0030 3A68     		ldr	r2, [r7]
 518 0032 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 519 0036 99B2     		uxth	r1, r3
 520 0038 154B     		ldr	r3, .L20+4
 521 003a 3A68     		ldr	r2, [r7]
 522 003c 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 300:App/Common/Minimal/BlockQ.c **** 
 301:App/Common/Minimal/BlockQ.c **** 
 302:App/Common/Minimal/BlockQ.c **** 		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
 523              		.loc 1 302 0
 524 0040 144B     		ldr	r3, .L20+8
 525 0042 3A68     		ldr	r2, [r7]
 526 0044 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 527 0048 9AB2     		uxth	r2, r3
 528 004a 134B     		ldr	r3, .L20+12
 529 004c 3968     		ldr	r1, [r7]
 530 004e 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 531 0052 12B2     		sxth	r2, r2
 532 0054 1BB2     		sxth	r3, r3
 533 0056 9A42     		cmp	r2, r3
 534 0058 01D1     		bne	.L17
 303:App/Common/Minimal/BlockQ.c **** 		{
 304:App/Common/Minimal/BlockQ.c **** 			xReturn = pdFALSE;
 535              		.loc 1 304 0
 536 005a 0023     		movs	r3, #0
 537 005c 7B60     		str	r3, [r7, #4]
 538              	.L17:
 305:App/Common/Minimal/BlockQ.c **** 		}
 306:App/Common/Minimal/BlockQ.c **** 		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
 539              		.loc 1 306 0
 540 005e 0D4B     		ldr	r3, .L20+8
 541 0060 3A68     		ldr	r2, [r7]
 542 0062 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 543 0066 99B2     		uxth	r1, r3
 544 0068 0B4B     		ldr	r3, .L20+12
 545 006a 3A68     		ldr	r2, [r7]
 546 006c 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 293:App/Common/Minimal/BlockQ.c **** 	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 547              		.loc 1 293 0
 548 0070 3B68     		ldr	r3, [r7]
 549 0072 0133     		adds	r3, r3, #1
 550 0074 3B60     		str	r3, [r7]
 551              	.L15:
 293:App/Common/Minimal/BlockQ.c **** 	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 552              		.loc 1 293 0 is_stmt 0 discriminator 1
 553 0076 3B68     		ldr	r3, [r7]
 554 0078 022B     		cmp	r3, #2
 555 007a C9DD     		ble	.L18
 307:App/Common/Minimal/BlockQ.c **** 	}
 308:App/Common/Minimal/BlockQ.c **** 
 309:App/Common/Minimal/BlockQ.c **** 	return xReturn;
 556              		.loc 1 309 0 is_stmt 1
 557 007c 7B68     		ldr	r3, [r7, #4]
 310:App/Common/Minimal/BlockQ.c **** }
 558              		.loc 1 310 0
 559 007e 1846     		mov	r0, r3
 560 0080 0C37     		adds	r7, r7, #12
 561 0082 BD46     		mov	sp, r7
 562              		@ sp needed
 563 0084 5DF8047B 		ldr	r7, [sp], #4
 564 0088 7047     		bx	lr
 565              	.L21:
 566 008a 00BF     		.align	2
 567              	.L20:
 568 008c 00000000 		.word	sBlockingConsumerCount
 569 0090 00000000 		.word	sLastBlockingConsumerCount.8234
 570 0094 00000000 		.word	sBlockingProducerCount
 571 0098 00000000 		.word	sLastBlockingProducerCount.8235
 572              		.cfi_endproc
 573              	.LFE113:
 575              		.section	.bss.sLastBlockingConsumerCount.8234,"aw",%nobits
 576              		.align	2
 579              	sLastBlockingConsumerCount.8234:
 580 0000 00000000 		.space	6
 580      0000
 581 0006 0000     		.section	.bss.sLastBlockingProducerCount.8235,"aw",%nobits
 582              		.align	2
 585              	sLastBlockingProducerCount.8235:
 586 0000 00000000 		.space	6
 586      0000
 587 0006 0000     		.text
 588              	.Letext0:
 589              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 590              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 591              		.file 4 "Source/include/queue.h"
 592              		.file 5 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 BlockQ.c
     /tmp/cclBkaPz.s:20     .bss.sBlockingConsumerCount:00000000 $d
     /tmp/cclBkaPz.s:23     .bss.sBlockingConsumerCount:00000000 sBlockingConsumerCount
     /tmp/cclBkaPz.s:26     .bss.sBlockingProducerCount:00000000 $d
     /tmp/cclBkaPz.s:29     .bss.sBlockingProducerCount:00000000 sBlockingProducerCount
     /tmp/cclBkaPz.s:32     .rodata:00000000 $d
     /tmp/cclBkaPz.s:51     .text.vStartBlockingQueueTasks:00000000 $t
     /tmp/cclBkaPz.s:56     .text.vStartBlockingQueueTasks:00000000 vStartBlockingQueueTasks
     /tmp/cclBkaPz.s:289    .text.vStartBlockingQueueTasks:00000188 $d
     /tmp/cclBkaPz.s:388    .text.vBlockingQueueConsumer:00000000 vBlockingQueueConsumer
     /tmp/cclBkaPz.s:311    .text.vBlockingQueueProducer:00000000 vBlockingQueueProducer
     /tmp/cclBkaPz.s:307    .text.vBlockingQueueProducer:00000000 $t
     /tmp/cclBkaPz.s:384    .text.vBlockingQueueConsumer:00000000 $t
     /tmp/cclBkaPz.s:469    .text.xAreBlockingQueuesStillRunning:00000000 $t
     /tmp/cclBkaPz.s:474    .text.xAreBlockingQueuesStillRunning:00000000 xAreBlockingQueuesStillRunning
     /tmp/cclBkaPz.s:568    .text.xAreBlockingQueuesStillRunning:0000008c $d
     /tmp/cclBkaPz.s:579    .bss.sLastBlockingConsumerCount.8234:00000000 sLastBlockingConsumerCount.8234
     /tmp/cclBkaPz.s:585    .bss.sLastBlockingProducerCount.8235:00000000 sLastBlockingProducerCount.8235
     /tmp/cclBkaPz.s:576    .bss.sLastBlockingConsumerCount.8234:00000000 $d
     /tmp/cclBkaPz.s:582    .bss.sLastBlockingProducerCount.8235:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
xQueueGenericCreate
xTaskGenericCreate
xQueueGenericSend
xQueueGenericReceive
