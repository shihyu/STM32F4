   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"timers.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xActiveTimerList1,"aw",%nobits
  20              		.align	2
  23              	xActiveTimerList1:
  24 0000 00000000 		.space	20
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.section	.bss.xActiveTimerList2,"aw",%nobits
  26              		.align	2
  29              	xActiveTimerList2:
  30 0000 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.pxCurrentTimerList,"aw",%nobits
  32              		.align	2
  35              	pxCurrentTimerList:
  36 0000 00000000 		.space	4
  37              		.section	.bss.pxOverflowTimerList,"aw",%nobits
  38              		.align	2
  41              	pxOverflowTimerList:
  42 0000 00000000 		.space	4
  43              		.section	.bss.xTimerQueue,"aw",%nobits
  44              		.align	2
  47              	xTimerQueue:
  48 0000 00000000 		.space	4
  49              		.section	.rodata
  50              		.align	2
  51              	.LC0:
  52 0000 546D7220 		.ascii	"Tmr Svc\000"
  52      53766300 
  53              		.section	.text.xTimerCreateTimerTask,"ax",%progbits
  54              		.align	2
  55              		.global	xTimerCreateTimerTask
  56              		.thumb
  57              		.thumb_func
  59              	xTimerCreateTimerTask:
  60              	.LFB110:
  61              		.file 1 "Source/timers.c"
   1:Source/timers.c **** /*
   2:Source/timers.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/timers.c ****     All rights reserved
   4:Source/timers.c **** 
   5:Source/timers.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/timers.c **** 
   7:Source/timers.c ****     ***************************************************************************
   8:Source/timers.c ****      *                                                                       *
   9:Source/timers.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/timers.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/timers.c ****      *    platform software that has become a de facto standard.             *
  12:Source/timers.c ****      *                                                                       *
  13:Source/timers.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/timers.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/timers.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/timers.c ****      *                                                                       *
  17:Source/timers.c ****      *    Thank you!                                                         *
  18:Source/timers.c ****      *                                                                       *
  19:Source/timers.c ****     ***************************************************************************
  20:Source/timers.c **** 
  21:Source/timers.c ****     This file is part of the FreeRTOS distribution.
  22:Source/timers.c **** 
  23:Source/timers.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/timers.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/timers.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/timers.c **** 
  27:Source/timers.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/timers.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/timers.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/timers.c ****     >>! kernel.
  31:Source/timers.c **** 
  32:Source/timers.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/timers.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/timers.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/timers.c ****     link: http://www.freertos.org/a00114.html
  36:Source/timers.c **** 
  37:Source/timers.c ****     1 tab == 4 spaces!
  38:Source/timers.c **** 
  39:Source/timers.c ****     ***************************************************************************
  40:Source/timers.c ****      *                                                                       *
  41:Source/timers.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/timers.c ****      *    not run, what could be wrong?"                                     *
  43:Source/timers.c ****      *                                                                       *
  44:Source/timers.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/timers.c ****      *                                                                       *
  46:Source/timers.c ****     ***************************************************************************
  47:Source/timers.c **** 
  48:Source/timers.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/timers.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/timers.c **** 
  51:Source/timers.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/timers.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/timers.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/timers.c **** 
  55:Source/timers.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/timers.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/timers.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/timers.c **** 
  59:Source/timers.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/timers.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/timers.c ****     mission critical applications that require provable dependability.
  62:Source/timers.c **** 
  63:Source/timers.c ****     1 tab == 4 spaces!
  64:Source/timers.c **** */
  65:Source/timers.c **** 
  66:Source/timers.c **** /* Standard includes. */
  67:Source/timers.c **** #include <stdlib.h>
  68:Source/timers.c **** 
  69:Source/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:Source/timers.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:Source/timers.c **** task.h is included from an application file. */
  72:Source/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:Source/timers.c **** 
  74:Source/timers.c **** #include "FreeRTOS.h"
  75:Source/timers.c **** #include "task.h"
  76:Source/timers.c **** #include "queue.h"
  77:Source/timers.c **** #include "timers.h"
  78:Source/timers.c **** 
  79:Source/timers.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  80:Source/timers.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  81:Source/timers.c **** header files above, but not in this file, in order to generate the correct
  82:Source/timers.c **** privileged Vs unprivileged linkage and placement. */
  83:Source/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  84:Source/timers.c **** 
  85:Source/timers.c **** 
  86:Source/timers.c **** /* This entire source file will be skipped if the application is not configured
  87:Source/timers.c **** to include software timer functionality.  This #if is closed at the very bottom
  88:Source/timers.c **** of this file.  If you want to include software timer functionality then ensure
  89:Source/timers.c **** configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  90:Source/timers.c **** #if ( configUSE_TIMERS == 1 )
  91:Source/timers.c **** 
  92:Source/timers.c **** /* Misc definitions. */
  93:Source/timers.c **** #define tmrNO_DELAY		( portTickType ) 0U
  94:Source/timers.c **** 
  95:Source/timers.c **** /* The definition of the timers themselves. */
  96:Source/timers.c **** typedef struct tmrTimerControl
  97:Source/timers.c **** {
  98:Source/timers.c **** 	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included 
  99:Source/timers.c **** 	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for ev
 100:Source/timers.c **** 	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
 101:Source/timers.c **** 	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically rest
 102:Source/timers.c **** 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified 
 103:Source/timers.c **** 	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expire
 104:Source/timers.c **** } xTIMER;
 105:Source/timers.c **** 
 106:Source/timers.c **** /* The definition of messages that can be sent and received on the timer
 107:Source/timers.c **** queue. */
 108:Source/timers.c **** typedef struct tmrTimerQueueMessage
 109:Source/timers.c **** {
 110:Source/timers.c **** 	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
 111:Source/timers.c **** 	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, w
 112:Source/timers.c **** 	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
 113:Source/timers.c **** } xTIMER_MESSAGE;
 114:Source/timers.c **** 
 115:Source/timers.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 116:Source/timers.c **** static variables must be declared volatile. */
 117:Source/timers.c **** 
 118:Source/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
 119:Source/timers.c **** time order, with the nearest expiry time at the front of the list.  Only the
 120:Source/timers.c **** timer service task is allowed to access xActiveTimerList. */
 121:Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList1;
 122:Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList2;
 123:Source/timers.c **** PRIVILEGED_DATA static xList *pxCurrentTimerList;
 124:Source/timers.c **** PRIVILEGED_DATA static xList *pxOverflowTimerList;
 125:Source/timers.c **** 
 126:Source/timers.c **** /* A queue that is used to send commands to the timer service task. */
 127:Source/timers.c **** PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
 128:Source/timers.c **** 
 129:Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 130:Source/timers.c **** 
 131:Source/timers.c **** 	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
 132:Source/timers.c **** 
 133:Source/timers.c **** #endif
 134:Source/timers.c **** 
 135:Source/timers.c **** /*lint +e956 */
 136:Source/timers.c **** 
 137:Source/timers.c **** /*-----------------------------------------------------------*/
 138:Source/timers.c **** 
 139:Source/timers.c **** /*
 140:Source/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 141:Source/timers.c ****  * been initialised already.
 142:Source/timers.c ****  */
 143:Source/timers.c **** static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 144:Source/timers.c **** 
 145:Source/timers.c **** /*
 146:Source/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 147:Source/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 148:Source/timers.c ****  * xTimerQueue queue.
 149:Source/timers.c ****  */
 150:Source/timers.c **** static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
 151:Source/timers.c **** 
 152:Source/timers.c **** /*
 153:Source/timers.c ****  * Called by the timer service task to interpret and process a command it
 154:Source/timers.c ****  * received on the timer queue.
 155:Source/timers.c ****  */
 156:Source/timers.c **** static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 157:Source/timers.c **** 
 158:Source/timers.c **** /*
 159:Source/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 160:Source/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 161:Source/timers.c ****  */
 162:Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 163:Source/timers.c **** 
 164:Source/timers.c **** /*
 165:Source/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 166:Source/timers.c ****  * auto reload timer, then call its callback.
 167:Source/timers.c ****  */
 168:Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGE
 169:Source/timers.c **** 
 170:Source/timers.c **** /*
 171:Source/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 172:Source/timers.c ****  * current timer list does not still reference some timers.
 173:Source/timers.c ****  */
 174:Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
 175:Source/timers.c **** 
 176:Source/timers.c **** /*
 177:Source/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 178:Source/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 179:Source/timers.c ****  */
 180:Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION
 181:Source/timers.c **** 
 182:Source/timers.c **** /*
 183:Source/timers.c ****  * If the timer list contains any active timers then return the expire time of
 184:Source/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 185:Source/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 186:Source/timers.c ****  * to pdTRUE.
 187:Source/timers.c ****  */
 188:Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
 189:Source/timers.c **** 
 190:Source/timers.c **** /*
 191:Source/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 192:Source/timers.c ****  * until either a timer does expire or a command is received.
 193:Source/timers.c ****  */
 194:Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 195:Source/timers.c **** 
 196:Source/timers.c **** /*-----------------------------------------------------------*/
 197:Source/timers.c **** 
 198:Source/timers.c **** portBASE_TYPE xTimerCreateTimerTask( void )
 199:Source/timers.c **** {
  62              		.loc 1 199 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66 0000 80B5     		push	{r7, lr}
  67              	.LCFI0:
  68              		.cfi_def_cfa_offset 8
  69              		.cfi_offset 7, -8
  70              		.cfi_offset 14, -4
  71 0002 86B0     		sub	sp, sp, #24
  72              	.LCFI1:
  73              		.cfi_def_cfa_offset 32
  74 0004 04AF     		add	r7, sp, #16
  75              	.LCFI2:
  76              		.cfi_def_cfa 7, 16
 200:Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
  77              		.loc 1 200 0
  78 0006 0023     		movs	r3, #0
  79 0008 7B60     		str	r3, [r7, #4]
 201:Source/timers.c **** 
 202:Source/timers.c **** 	/* This function is called when the scheduler is started if
 203:Source/timers.c **** 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 204:Source/timers.c **** 	timer service task has been created/initialised.  If timers have already
 205:Source/timers.c **** 	been created then the initialisation will already have been performed. */
 206:Source/timers.c **** 	prvCheckForValidListAndQueue();
  80              		.loc 1 206 0
  81 000a FFF7FEFF 		bl	prvCheckForValidListAndQueue
 207:Source/timers.c **** 
 208:Source/timers.c **** 	if( xTimerQueue != NULL )
  82              		.loc 1 208 0
  83 000e 0F4B     		ldr	r3, .L6
  84 0010 1B68     		ldr	r3, [r3]
  85 0012 002B     		cmp	r3, #0
  86 0014 0FD0     		beq	.L2
 209:Source/timers.c **** 	{
 210:Source/timers.c **** 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 211:Source/timers.c **** 		{
 212:Source/timers.c **** 			/* Create the timer task, storing its handle in xTimerTaskHandle so
 213:Source/timers.c **** 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
 214:Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
 215:Source/timers.c **** 		}
 216:Source/timers.c **** 		#else
 217:Source/timers.c **** 		{
 218:Source/timers.c **** 			/* Create the timer task without storing its handle. */
 219:Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
  87              		.loc 1 219 0
  88 0016 0223     		movs	r3, #2
  89 0018 0093     		str	r3, [sp]
  90 001a 0023     		movs	r3, #0
  91 001c 0193     		str	r3, [sp, #4]
  92 001e 0023     		movs	r3, #0
  93 0020 0293     		str	r3, [sp, #8]
  94 0022 0023     		movs	r3, #0
  95 0024 0393     		str	r3, [sp, #12]
  96 0026 0A48     		ldr	r0, .L6+4
  97 0028 0A49     		ldr	r1, .L6+8
  98 002a 4FF48272 		mov	r2, #260
  99 002e 0023     		movs	r3, #0
 100 0030 FFF7FEFF 		bl	xTaskGenericCreate
 101 0034 7860     		str	r0, [r7, #4]
 102              	.L2:
 220:Source/timers.c **** 		}
 221:Source/timers.c **** 		#endif
 222:Source/timers.c **** 	}
 223:Source/timers.c **** 
 224:Source/timers.c **** 	configASSERT( xReturn );
 103              		.loc 1 224 0
 104 0036 7B68     		ldr	r3, [r7, #4]
 105 0038 002B     		cmp	r3, #0
 106 003a 02D1     		bne	.L3
 107              		.loc 1 224 0 is_stmt 0 discriminator 1
 108 003c FFF7FEFF 		bl	ulPortSetInterruptMask
 109              	.L4:
 110 0040 FEE7     		b	.L4
 111              	.L3:
 225:Source/timers.c **** 	return xReturn;
 112              		.loc 1 225 0 is_stmt 1
 113 0042 7B68     		ldr	r3, [r7, #4]
 226:Source/timers.c **** }
 114              		.loc 1 226 0
 115 0044 1846     		mov	r0, r3
 116 0046 0837     		adds	r7, r7, #8
 117 0048 BD46     		mov	sp, r7
 118              		@ sp needed
 119 004a 80BD     		pop	{r7, pc}
 120              	.L7:
 121              		.align	2
 122              	.L6:
 123 004c 00000000 		.word	xTimerQueue
 124 0050 00000000 		.word	prvTimerTask
 125 0054 00000000 		.word	.LC0
 126              		.cfi_endproc
 127              	.LFE110:
 129              		.section	.text.xTimerCreate,"ax",%progbits
 130              		.align	2
 131              		.global	xTimerCreate
 132              		.thumb
 133              		.thumb_func
 135              	xTimerCreate:
 136              	.LFB111:
 227:Source/timers.c **** /*-----------------------------------------------------------*/
 228:Source/timers.c **** 
 229:Source/timers.c **** xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks,
 230:Source/timers.c **** {
 137              		.loc 1 230 0
 138              		.cfi_startproc
 139              		@ args = 4, pretend = 0, frame = 24
 140              		@ frame_needed = 1, uses_anonymous_args = 0
 141 0000 80B5     		push	{r7, lr}
 142              	.LCFI3:
 143              		.cfi_def_cfa_offset 8
 144              		.cfi_offset 7, -8
 145              		.cfi_offset 14, -4
 146 0002 86B0     		sub	sp, sp, #24
 147              	.LCFI4:
 148              		.cfi_def_cfa_offset 32
 149 0004 00AF     		add	r7, sp, #0
 150              	.LCFI5:
 151              		.cfi_def_cfa_register 7
 152 0006 F860     		str	r0, [r7, #12]
 153 0008 B960     		str	r1, [r7, #8]
 154 000a 7A60     		str	r2, [r7, #4]
 155 000c 3B60     		str	r3, [r7]
 231:Source/timers.c **** xTIMER *pxNewTimer;
 232:Source/timers.c **** 
 233:Source/timers.c **** 	/* Allocate the timer structure. */
 234:Source/timers.c **** 	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 156              		.loc 1 234 0
 157 000e BB68     		ldr	r3, [r7, #8]
 158 0010 002B     		cmp	r3, #0
 159 0012 02D1     		bne	.L9
 235:Source/timers.c **** 	{
 236:Source/timers.c **** 		pxNewTimer = NULL;
 160              		.loc 1 236 0
 161 0014 0023     		movs	r3, #0
 162 0016 7B61     		str	r3, [r7, #20]
 163 0018 1CE0     		b	.L10
 164              	.L9:
 237:Source/timers.c **** 	}
 238:Source/timers.c **** 	else
 239:Source/timers.c **** 	{
 240:Source/timers.c **** 		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 165              		.loc 1 240 0
 166 001a 2820     		movs	r0, #40
 167 001c FFF7FEFF 		bl	pvPortMalloc
 168 0020 7861     		str	r0, [r7, #20]
 241:Source/timers.c **** 		if( pxNewTimer != NULL )
 169              		.loc 1 241 0
 170 0022 7B69     		ldr	r3, [r7, #20]
 171 0024 002B     		cmp	r3, #0
 172 0026 15D0     		beq	.L10
 242:Source/timers.c **** 		{
 243:Source/timers.c **** 			/* Ensure the infrastructure used by the timer service task has been
 244:Source/timers.c **** 			created/initialised. */
 245:Source/timers.c **** 			prvCheckForValidListAndQueue();
 173              		.loc 1 245 0
 174 0028 FFF7FEFF 		bl	prvCheckForValidListAndQueue
 246:Source/timers.c **** 
 247:Source/timers.c **** 			/* Initialise the timer structure members using the function parameters. */
 248:Source/timers.c **** 			pxNewTimer->pcTimerName = pcTimerName;
 175              		.loc 1 248 0
 176 002c 7B69     		ldr	r3, [r7, #20]
 177 002e FA68     		ldr	r2, [r7, #12]
 178 0030 1A60     		str	r2, [r3]
 249:Source/timers.c **** 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 179              		.loc 1 249 0
 180 0032 7B69     		ldr	r3, [r7, #20]
 181 0034 BA68     		ldr	r2, [r7, #8]
 182 0036 9A61     		str	r2, [r3, #24]
 250:Source/timers.c **** 			pxNewTimer->uxAutoReload = uxAutoReload;
 183              		.loc 1 250 0
 184 0038 7B69     		ldr	r3, [r7, #20]
 185 003a 7A68     		ldr	r2, [r7, #4]
 186 003c DA61     		str	r2, [r3, #28]
 251:Source/timers.c **** 			pxNewTimer->pvTimerID = pvTimerID;
 187              		.loc 1 251 0
 188 003e 7B69     		ldr	r3, [r7, #20]
 189 0040 3A68     		ldr	r2, [r7]
 190 0042 1A62     		str	r2, [r3, #32]
 252:Source/timers.c **** 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 191              		.loc 1 252 0
 192 0044 7B69     		ldr	r3, [r7, #20]
 193 0046 3A6A     		ldr	r2, [r7, #32]
 194 0048 5A62     		str	r2, [r3, #36]
 253:Source/timers.c **** 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 195              		.loc 1 253 0
 196 004a 7B69     		ldr	r3, [r7, #20]
 197 004c 0433     		adds	r3, r3, #4
 198 004e 1846     		mov	r0, r3
 199 0050 FFF7FEFF 		bl	vListInitialiseItem
 200              	.L10:
 254:Source/timers.c **** 
 255:Source/timers.c **** 			traceTIMER_CREATE( pxNewTimer );
 256:Source/timers.c **** 		}
 257:Source/timers.c **** 		else
 258:Source/timers.c **** 		{
 259:Source/timers.c **** 			traceTIMER_CREATE_FAILED();
 260:Source/timers.c **** 		}
 261:Source/timers.c **** 	}
 262:Source/timers.c **** 
 263:Source/timers.c **** 	/* 0 is not a valid value for xTimerPeriodInTicks. */
 264:Source/timers.c **** 	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 201              		.loc 1 264 0
 202 0054 BB68     		ldr	r3, [r7, #8]
 203 0056 002B     		cmp	r3, #0
 204 0058 02D1     		bne	.L11
 205              		.loc 1 264 0 is_stmt 0 discriminator 1
 206 005a FFF7FEFF 		bl	ulPortSetInterruptMask
 207              	.L12:
 208 005e FEE7     		b	.L12
 209              	.L11:
 265:Source/timers.c **** 
 266:Source/timers.c **** 	return ( xTimerHandle ) pxNewTimer;
 210              		.loc 1 266 0 is_stmt 1
 211 0060 7B69     		ldr	r3, [r7, #20]
 267:Source/timers.c **** }
 212              		.loc 1 267 0
 213 0062 1846     		mov	r0, r3
 214 0064 1837     		adds	r7, r7, #24
 215 0066 BD46     		mov	sp, r7
 216              		@ sp needed
 217 0068 80BD     		pop	{r7, pc}
 218              		.cfi_endproc
 219              	.LFE111:
 221 006a 00BF     		.section	.text.xTimerGenericCommand,"ax",%progbits
 222              		.align	2
 223              		.global	xTimerGenericCommand
 224              		.thumb
 225              		.thumb_func
 227              	xTimerGenericCommand:
 228              	.LFB112:
 268:Source/timers.c **** /*-----------------------------------------------------------*/
 269:Source/timers.c **** 
 270:Source/timers.c **** portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOp
 271:Source/timers.c **** {
 229              		.loc 1 271 0
 230              		.cfi_startproc
 231              		@ args = 4, pretend = 0, frame = 32
 232              		@ frame_needed = 1, uses_anonymous_args = 0
 233 0000 80B5     		push	{r7, lr}
 234              	.LCFI6:
 235              		.cfi_def_cfa_offset 8
 236              		.cfi_offset 7, -8
 237              		.cfi_offset 14, -4
 238 0002 88B0     		sub	sp, sp, #32
 239              	.LCFI7:
 240              		.cfi_def_cfa_offset 40
 241 0004 00AF     		add	r7, sp, #0
 242              	.LCFI8:
 243              		.cfi_def_cfa_register 7
 244 0006 F860     		str	r0, [r7, #12]
 245 0008 B960     		str	r1, [r7, #8]
 246 000a 7A60     		str	r2, [r7, #4]
 247 000c 3B60     		str	r3, [r7]
 272:Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
 248              		.loc 1 272 0
 249 000e 0023     		movs	r3, #0
 250 0010 FB61     		str	r3, [r7, #28]
 273:Source/timers.c **** xTIMER_MESSAGE xMessage;
 274:Source/timers.c **** 
 275:Source/timers.c **** 	/* Send a message to the timer service task to perform a particular action
 276:Source/timers.c **** 	on a particular timer definition. */
 277:Source/timers.c **** 	if( xTimerQueue != NULL )
 251              		.loc 1 277 0
 252 0012 1D4B     		ldr	r3, .L20
 253 0014 1B68     		ldr	r3, [r3]
 254 0016 002B     		cmp	r3, #0
 255 0018 30D0     		beq	.L15
 278:Source/timers.c **** 	{
 279:Source/timers.c **** 		/* Send a command to the timer service task to start the xTimer timer. */
 280:Source/timers.c **** 		xMessage.xMessageID = xCommandID;
 256              		.loc 1 280 0
 257 001a BB68     		ldr	r3, [r7, #8]
 258 001c 3B61     		str	r3, [r7, #16]
 281:Source/timers.c **** 		xMessage.xMessageValue = xOptionalValue;
 259              		.loc 1 281 0
 260 001e 7B68     		ldr	r3, [r7, #4]
 261 0020 7B61     		str	r3, [r7, #20]
 282:Source/timers.c **** 		xMessage.pxTimer = ( xTIMER * ) xTimer;
 262              		.loc 1 282 0
 263 0022 FB68     		ldr	r3, [r7, #12]
 264 0024 BB61     		str	r3, [r7, #24]
 283:Source/timers.c **** 
 284:Source/timers.c **** 		if( pxHigherPriorityTaskWoken == NULL )
 265              		.loc 1 284 0
 266 0026 3B68     		ldr	r3, [r7]
 267 0028 002B     		cmp	r3, #0
 268 002a 1CD1     		bne	.L16
 285:Source/timers.c **** 		{
 286:Source/timers.c **** 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 269              		.loc 1 286 0
 270 002c FFF7FEFF 		bl	xTaskGetSchedulerState
 271 0030 0346     		mov	r3, r0
 272 0032 012B     		cmp	r3, #1
 273 0034 0BD1     		bne	.L17
 287:Source/timers.c **** 			{
 288:Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 274              		.loc 1 288 0
 275 0036 144B     		ldr	r3, .L20
 276 0038 1A68     		ldr	r2, [r3]
 277 003a 07F11003 		add	r3, r7, #16
 278 003e 1046     		mov	r0, r2
 279 0040 1946     		mov	r1, r3
 280 0042 BA6A     		ldr	r2, [r7, #40]
 281 0044 0023     		movs	r3, #0
 282 0046 FFF7FEFF 		bl	xQueueGenericSend
 283 004a F861     		str	r0, [r7, #28]
 284 004c 16E0     		b	.L15
 285              	.L17:
 289:Source/timers.c **** 			}
 290:Source/timers.c **** 			else
 291:Source/timers.c **** 			{
 292:Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 286              		.loc 1 292 0
 287 004e 0E4B     		ldr	r3, .L20
 288 0050 1A68     		ldr	r2, [r3]
 289 0052 07F11003 		add	r3, r7, #16
 290 0056 1046     		mov	r0, r2
 291 0058 1946     		mov	r1, r3
 292 005a 0022     		movs	r2, #0
 293 005c 0023     		movs	r3, #0
 294 005e FFF7FEFF 		bl	xQueueGenericSend
 295 0062 F861     		str	r0, [r7, #28]
 296 0064 0AE0     		b	.L15
 297              	.L16:
 293:Source/timers.c **** 			}
 294:Source/timers.c **** 		}
 295:Source/timers.c **** 		else
 296:Source/timers.c **** 		{
 297:Source/timers.c **** 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 298              		.loc 1 297 0
 299 0066 084B     		ldr	r3, .L20
 300 0068 1A68     		ldr	r2, [r3]
 301 006a 07F11003 		add	r3, r7, #16
 302 006e 1046     		mov	r0, r2
 303 0070 1946     		mov	r1, r3
 304 0072 3A68     		ldr	r2, [r7]
 305 0074 0023     		movs	r3, #0
 306 0076 FFF7FEFF 		bl	xQueueGenericSendFromISR
 307 007a F861     		str	r0, [r7, #28]
 308              	.L15:
 298:Source/timers.c **** 		}
 299:Source/timers.c **** 
 300:Source/timers.c **** 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 301:Source/timers.c **** 	}
 302:Source/timers.c **** 
 303:Source/timers.c **** 	return xReturn;
 309              		.loc 1 303 0
 310 007c FB69     		ldr	r3, [r7, #28]
 304:Source/timers.c **** }
 311              		.loc 1 304 0
 312 007e 1846     		mov	r0, r3
 313 0080 2037     		adds	r7, r7, #32
 314 0082 BD46     		mov	sp, r7
 315              		@ sp needed
 316 0084 80BD     		pop	{r7, pc}
 317              	.L21:
 318 0086 00BF     		.align	2
 319              	.L20:
 320 0088 00000000 		.word	xTimerQueue
 321              		.cfi_endproc
 322              	.LFE112:
 324              		.section	.text.prvProcessExpiredTimer,"ax",%progbits
 325              		.align	2
 326              		.thumb
 327              		.thumb_func
 329              	prvProcessExpiredTimer:
 330              	.LFB113:
 305:Source/timers.c **** /*-----------------------------------------------------------*/
 306:Source/timers.c **** 
 307:Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 308:Source/timers.c **** 
 309:Source/timers.c **** 	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
 310:Source/timers.c **** 	{
 311:Source/timers.c **** 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 312:Source/timers.c **** 		started, then xTimerTaskHandle will be NULL. */
 313:Source/timers.c **** 		configASSERT( ( xTimerTaskHandle != NULL ) );
 314:Source/timers.c **** 		return xTimerTaskHandle;
 315:Source/timers.c **** 	}
 316:Source/timers.c **** 
 317:Source/timers.c **** #endif
 318:Source/timers.c **** /*-----------------------------------------------------------*/
 319:Source/timers.c **** 
 320:Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
 321:Source/timers.c **** {
 331              		.loc 1 321 0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 16
 334              		@ frame_needed = 1, uses_anonymous_args = 0
 335 0000 80B5     		push	{r7, lr}
 336              	.LCFI9:
 337              		.cfi_def_cfa_offset 8
 338              		.cfi_offset 7, -8
 339              		.cfi_offset 14, -4
 340 0002 86B0     		sub	sp, sp, #24
 341              	.LCFI10:
 342              		.cfi_def_cfa_offset 32
 343 0004 02AF     		add	r7, sp, #8
 344              	.LCFI11:
 345              		.cfi_def_cfa 7, 24
 346 0006 7860     		str	r0, [r7, #4]
 347 0008 3960     		str	r1, [r7]
 322:Source/timers.c **** xTIMER *pxTimer;
 323:Source/timers.c **** portBASE_TYPE xResult;
 324:Source/timers.c **** 
 325:Source/timers.c **** 	/* Remove the timer from the list of active timers.  A check has already
 326:Source/timers.c **** 	been performed to ensure the list is not empty. */
 327:Source/timers.c **** 	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 348              		.loc 1 327 0
 349 000a 184B     		ldr	r3, .L25
 350 000c 1B68     		ldr	r3, [r3]
 351 000e DB68     		ldr	r3, [r3, #12]
 352 0010 DB68     		ldr	r3, [r3, #12]
 353 0012 FB60     		str	r3, [r7, #12]
 328:Source/timers.c **** 	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 354              		.loc 1 328 0
 355 0014 FB68     		ldr	r3, [r7, #12]
 356 0016 0433     		adds	r3, r3, #4
 357 0018 1846     		mov	r0, r3
 358 001a FFF7FEFF 		bl	uxListRemove
 329:Source/timers.c **** 	traceTIMER_EXPIRED( pxTimer );
 330:Source/timers.c **** 
 331:Source/timers.c **** 	/* If the timer is an auto reload timer then calculate the next
 332:Source/timers.c **** 	expiry time and re-insert the timer in the list of active timers. */
 333:Source/timers.c **** 	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 359              		.loc 1 333 0
 360 001e FB68     		ldr	r3, [r7, #12]
 361 0020 DB69     		ldr	r3, [r3, #28]
 362 0022 012B     		cmp	r3, #1
 363 0024 1BD1     		bne	.L23
 334:Source/timers.c **** 	{
 335:Source/timers.c **** 		/* This is the only time a timer is inserted into a list using
 336:Source/timers.c **** 		a time relative to anything other than the current time.  It
 337:Source/timers.c **** 		will therefore be inserted into the correct list relative to
 338:Source/timers.c **** 		the time this task thinks it is now, even if a command to
 339:Source/timers.c **** 		switch lists due to a tick count overflow is already waiting in
 340:Source/timers.c **** 		the timer queue. */
 341:Source/timers.c **** 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTim
 364              		.loc 1 341 0
 365 0026 FB68     		ldr	r3, [r7, #12]
 366 0028 9A69     		ldr	r2, [r3, #24]
 367 002a 7B68     		ldr	r3, [r7, #4]
 368 002c 1344     		add	r3, r3, r2
 369 002e F868     		ldr	r0, [r7, #12]
 370 0030 1946     		mov	r1, r3
 371 0032 3A68     		ldr	r2, [r7]
 372 0034 7B68     		ldr	r3, [r7, #4]
 373 0036 FFF7FEFF 		bl	prvInsertTimerInActiveList
 374 003a 0346     		mov	r3, r0
 375 003c 012B     		cmp	r3, #1
 376 003e 0ED1     		bne	.L23
 342:Source/timers.c **** 		{
 343:Source/timers.c **** 			/* The timer expired before it was added to the active timer
 344:Source/timers.c **** 			list.  Reload it now.  */
 345:Source/timers.c **** 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 377              		.loc 1 345 0
 378 0040 0023     		movs	r3, #0
 379 0042 0093     		str	r3, [sp]
 380 0044 F868     		ldr	r0, [r7, #12]
 381 0046 0021     		movs	r1, #0
 382 0048 7A68     		ldr	r2, [r7, #4]
 383 004a 0023     		movs	r3, #0
 384 004c FFF7FEFF 		bl	xTimerGenericCommand
 385 0050 B860     		str	r0, [r7, #8]
 346:Source/timers.c **** 			configASSERT( xResult );
 386              		.loc 1 346 0
 387 0052 BB68     		ldr	r3, [r7, #8]
 388 0054 002B     		cmp	r3, #0
 389 0056 02D1     		bne	.L23
 390              		.loc 1 346 0 is_stmt 0 discriminator 1
 391 0058 FFF7FEFF 		bl	ulPortSetInterruptMask
 392              	.L24:
 393 005c FEE7     		b	.L24
 394              	.L23:
 347:Source/timers.c **** 			( void ) xResult;
 348:Source/timers.c **** 		}
 349:Source/timers.c **** 	}
 350:Source/timers.c **** 
 351:Source/timers.c **** 	/* Call the timer callback. */
 352:Source/timers.c **** 	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 395              		.loc 1 352 0 is_stmt 1
 396 005e FB68     		ldr	r3, [r7, #12]
 397 0060 5B6A     		ldr	r3, [r3, #36]
 398 0062 F868     		ldr	r0, [r7, #12]
 399 0064 9847     		blx	r3
 353:Source/timers.c **** }
 400              		.loc 1 353 0
 401 0066 1037     		adds	r7, r7, #16
 402 0068 BD46     		mov	sp, r7
 403              		@ sp needed
 404 006a 80BD     		pop	{r7, pc}
 405              	.L26:
 406              		.align	2
 407              	.L25:
 408 006c 00000000 		.word	pxCurrentTimerList
 409              		.cfi_endproc
 410              	.LFE113:
 412              		.section	.text.prvTimerTask,"ax",%progbits
 413              		.align	2
 414              		.thumb
 415              		.thumb_func
 417              	prvTimerTask:
 418              	.LFB114:
 354:Source/timers.c **** /*-----------------------------------------------------------*/
 355:Source/timers.c **** 
 356:Source/timers.c **** static void prvTimerTask( void *pvParameters )
 357:Source/timers.c **** {
 419              		.loc 1 357 0
 420              		.cfi_startproc
 421              		@ args = 0, pretend = 0, frame = 16
 422              		@ frame_needed = 1, uses_anonymous_args = 0
 423 0000 80B5     		push	{r7, lr}
 424              	.LCFI12:
 425              		.cfi_def_cfa_offset 8
 426              		.cfi_offset 7, -8
 427              		.cfi_offset 14, -4
 428 0002 84B0     		sub	sp, sp, #16
 429              	.LCFI13:
 430              		.cfi_def_cfa_offset 24
 431 0004 00AF     		add	r7, sp, #0
 432              	.LCFI14:
 433              		.cfi_def_cfa_register 7
 434 0006 7860     		str	r0, [r7, #4]
 435              	.L28:
 358:Source/timers.c **** portTickType xNextExpireTime;
 359:Source/timers.c **** portBASE_TYPE xListWasEmpty;
 360:Source/timers.c **** 
 361:Source/timers.c **** 	/* Just to avoid compiler warnings. */
 362:Source/timers.c **** 	( void ) pvParameters;
 363:Source/timers.c **** 
 364:Source/timers.c **** 	for( ;; )
 365:Source/timers.c **** 	{
 366:Source/timers.c **** 		/* Query the timers list to see if it contains any timers, and if so,
 367:Source/timers.c **** 		obtain the time at which the next timer will expire. */
 368:Source/timers.c **** 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 436              		.loc 1 368 0 discriminator 1
 437 0008 07F10803 		add	r3, r7, #8
 438 000c 1846     		mov	r0, r3
 439 000e FFF7FEFF 		bl	prvGetNextExpireTime
 440 0012 F860     		str	r0, [r7, #12]
 369:Source/timers.c **** 
 370:Source/timers.c **** 		/* If a timer has expired, process it.  Otherwise, block this task
 371:Source/timers.c **** 		until either a timer does expire, or a command is received. */
 372:Source/timers.c **** 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 441              		.loc 1 372 0 discriminator 1
 442 0014 BB68     		ldr	r3, [r7, #8]
 443 0016 F868     		ldr	r0, [r7, #12]
 444 0018 1946     		mov	r1, r3
 445 001a FFF7FEFF 		bl	prvProcessTimerOrBlockTask
 373:Source/timers.c **** 
 374:Source/timers.c **** 		/* Empty the command queue. */
 375:Source/timers.c **** 		prvProcessReceivedCommands();
 446              		.loc 1 375 0 discriminator 1
 447 001e FFF7FEFF 		bl	prvProcessReceivedCommands
 376:Source/timers.c **** 	}
 448              		.loc 1 376 0 discriminator 1
 449 0022 F1E7     		b	.L28
 450              		.cfi_endproc
 451              	.LFE114:
 453              		.section	.text.prvProcessTimerOrBlockTask,"ax",%progbits
 454              		.align	2
 455              		.thumb
 456              		.thumb_func
 458              	prvProcessTimerOrBlockTask:
 459              	.LFB115:
 377:Source/timers.c **** }
 378:Source/timers.c **** /*-----------------------------------------------------------*/
 379:Source/timers.c **** 
 380:Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 381:Source/timers.c **** {
 460              		.loc 1 381 0
 461              		.cfi_startproc
 462              		@ args = 0, pretend = 0, frame = 16
 463              		@ frame_needed = 1, uses_anonymous_args = 0
 464 0000 80B5     		push	{r7, lr}
 465              	.LCFI15:
 466              		.cfi_def_cfa_offset 8
 467              		.cfi_offset 7, -8
 468              		.cfi_offset 14, -4
 469 0002 84B0     		sub	sp, sp, #16
 470              	.LCFI16:
 471              		.cfi_def_cfa_offset 24
 472 0004 00AF     		add	r7, sp, #0
 473              	.LCFI17:
 474              		.cfi_def_cfa_register 7
 475 0006 7860     		str	r0, [r7, #4]
 476 0008 3960     		str	r1, [r7]
 382:Source/timers.c **** portTickType xTimeNow;
 383:Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched;
 384:Source/timers.c **** 
 385:Source/timers.c **** 	vTaskSuspendAll();
 477              		.loc 1 385 0
 478 000a FFF7FEFF 		bl	vTaskSuspendAll
 386:Source/timers.c **** 	{
 387:Source/timers.c **** 		/* Obtain the time now to make an assessment as to whether the timer
 388:Source/timers.c **** 		has expired or not.  If obtaining the time causes the lists to switch
 389:Source/timers.c **** 		then don't process this timer as any timers that remained in the list
 390:Source/timers.c **** 		when the lists were switched will have been processed within the
 391:Source/timers.c **** 		prvSampelTimeNow() function. */
 392:Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 479              		.loc 1 392 0
 480 000e 07F10803 		add	r3, r7, #8
 481 0012 1846     		mov	r0, r3
 482 0014 FFF7FEFF 		bl	prvSampleTimeNow
 483 0018 F860     		str	r0, [r7, #12]
 393:Source/timers.c **** 		if( xTimerListsWereSwitched == pdFALSE )
 484              		.loc 1 393 0
 485 001a BB68     		ldr	r3, [r7, #8]
 486 001c 002B     		cmp	r3, #0
 487 001e 1ED1     		bne	.L30
 394:Source/timers.c **** 		{
 395:Source/timers.c **** 			/* The tick count has not overflowed, has the timer expired? */
 396:Source/timers.c **** 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 488              		.loc 1 396 0
 489 0020 3B68     		ldr	r3, [r7]
 490 0022 002B     		cmp	r3, #0
 491 0024 0AD1     		bne	.L31
 492              		.loc 1 396 0 is_stmt 0 discriminator 1
 493 0026 7A68     		ldr	r2, [r7, #4]
 494 0028 FB68     		ldr	r3, [r7, #12]
 495 002a 9A42     		cmp	r2, r3
 496 002c 06D8     		bhi	.L31
 397:Source/timers.c **** 			{
 398:Source/timers.c **** 				( void ) xTaskResumeAll();
 497              		.loc 1 398 0 is_stmt 1
 498 002e FFF7FEFF 		bl	xTaskResumeAll
 399:Source/timers.c **** 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 499              		.loc 1 399 0
 500 0032 7868     		ldr	r0, [r7, #4]
 501 0034 F968     		ldr	r1, [r7, #12]
 502 0036 FFF7FEFF 		bl	prvProcessExpiredTimer
 503 003a 12E0     		b	.L29
 504              	.L31:
 400:Source/timers.c **** 			}
 401:Source/timers.c **** 			else
 402:Source/timers.c **** 			{
 403:Source/timers.c **** 				/* The tick count has not overflowed, and the next expire
 404:Source/timers.c **** 				time has not been reached yet.  This task should therefore
 405:Source/timers.c **** 				block to wait for the next expire time or a command to be
 406:Source/timers.c **** 				received - whichever comes first.  The following line cannot
 407:Source/timers.c **** 				be reached unless xNextExpireTime > xTimeNow, except in the
 408:Source/timers.c **** 				case when the current timer list is empty. */
 409:Source/timers.c **** 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 505              		.loc 1 409 0
 506 003c 0A4B     		ldr	r3, .L34
 507 003e 1A68     		ldr	r2, [r3]
 508 0040 7968     		ldr	r1, [r7, #4]
 509 0042 FB68     		ldr	r3, [r7, #12]
 510 0044 CB1A     		subs	r3, r1, r3
 511 0046 1046     		mov	r0, r2
 512 0048 1946     		mov	r1, r3
 513 004a FFF7FEFF 		bl	vQueueWaitForMessageRestricted
 410:Source/timers.c **** 
 411:Source/timers.c **** 				if( xTaskResumeAll() == pdFALSE )
 514              		.loc 1 411 0
 515 004e FFF7FEFF 		bl	xTaskResumeAll
 516 0052 0346     		mov	r3, r0
 517 0054 002B     		cmp	r3, #0
 518 0056 04D1     		bne	.L29
 412:Source/timers.c **** 				{
 413:Source/timers.c **** 					/* Yield to wait for either a command to arrive, or the block time
 414:Source/timers.c **** 					to expire.  If a command arrived between the critical section being
 415:Source/timers.c **** 					exited and this yield then the yield will not cause the task
 416:Source/timers.c **** 					to block. */
 417:Source/timers.c **** 					portYIELD_WITHIN_API();
 519              		.loc 1 417 0
 520 0058 FFF7FEFF 		bl	vPortYield
 521 005c 01E0     		b	.L29
 522              	.L30:
 418:Source/timers.c **** 				}
 419:Source/timers.c **** 			}
 420:Source/timers.c **** 		}
 421:Source/timers.c **** 		else
 422:Source/timers.c **** 		{
 423:Source/timers.c **** 			( void ) xTaskResumeAll();
 523              		.loc 1 423 0
 524 005e FFF7FEFF 		bl	xTaskResumeAll
 525              	.L29:
 424:Source/timers.c **** 		}
 425:Source/timers.c **** 	}
 426:Source/timers.c **** }
 526              		.loc 1 426 0
 527 0062 1037     		adds	r7, r7, #16
 528 0064 BD46     		mov	sp, r7
 529              		@ sp needed
 530 0066 80BD     		pop	{r7, pc}
 531              	.L35:
 532              		.align	2
 533              	.L34:
 534 0068 00000000 		.word	xTimerQueue
 535              		.cfi_endproc
 536              	.LFE115:
 538              		.section	.text.prvGetNextExpireTime,"ax",%progbits
 539              		.align	2
 540              		.thumb
 541              		.thumb_func
 543              	prvGetNextExpireTime:
 544              	.LFB116:
 427:Source/timers.c **** /*-----------------------------------------------------------*/
 428:Source/timers.c **** 
 429:Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
 430:Source/timers.c **** {
 545              		.loc 1 430 0
 546              		.cfi_startproc
 547              		@ args = 0, pretend = 0, frame = 16
 548              		@ frame_needed = 1, uses_anonymous_args = 0
 549              		@ link register save eliminated.
 550 0000 80B4     		push	{r7}
 551              	.LCFI18:
 552              		.cfi_def_cfa_offset 4
 553              		.cfi_offset 7, -4
 554 0002 85B0     		sub	sp, sp, #20
 555              	.LCFI19:
 556              		.cfi_def_cfa_offset 24
 557 0004 00AF     		add	r7, sp, #0
 558              	.LCFI20:
 559              		.cfi_def_cfa_register 7
 560 0006 7860     		str	r0, [r7, #4]
 431:Source/timers.c **** portTickType xNextExpireTime;
 432:Source/timers.c **** 
 433:Source/timers.c **** 	/* Timers are listed in expiry time order, with the head of the list
 434:Source/timers.c **** 	referencing the task that will expire first.  Obtain the time at which
 435:Source/timers.c **** 	the timer with the nearest expiry time will expire.  If there are no
 436:Source/timers.c **** 	active timers then just set the next expire time to 0.  That will cause
 437:Source/timers.c **** 	this task to unblock when the tick count overflows, at which point the
 438:Source/timers.c **** 	timer lists will be switched and the next expiry time can be
 439:Source/timers.c **** 	re-assessed.  */
 440:Source/timers.c **** 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 561              		.loc 1 440 0
 562 0008 0E4B     		ldr	r3, .L40
 563 000a 1B68     		ldr	r3, [r3]
 564 000c 1B68     		ldr	r3, [r3]
 565 000e 002B     		cmp	r3, #0
 566 0010 14BF     		ite	ne
 567 0012 0023     		movne	r3, #0
 568 0014 0123     		moveq	r3, #1
 569 0016 DBB2     		uxtb	r3, r3
 570 0018 1A46     		mov	r2, r3
 571 001a 7B68     		ldr	r3, [r7, #4]
 572 001c 1A60     		str	r2, [r3]
 441:Source/timers.c **** 	if( *pxListWasEmpty == pdFALSE )
 573              		.loc 1 441 0
 574 001e 7B68     		ldr	r3, [r7, #4]
 575 0020 1B68     		ldr	r3, [r3]
 576 0022 002B     		cmp	r3, #0
 577 0024 05D1     		bne	.L37
 442:Source/timers.c **** 	{
 443:Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 578              		.loc 1 443 0
 579 0026 074B     		ldr	r3, .L40
 580 0028 1B68     		ldr	r3, [r3]
 581 002a DB68     		ldr	r3, [r3, #12]
 582 002c 1B68     		ldr	r3, [r3]
 583 002e FB60     		str	r3, [r7, #12]
 584 0030 01E0     		b	.L38
 585              	.L37:
 444:Source/timers.c **** 	}
 445:Source/timers.c **** 	else
 446:Source/timers.c **** 	{
 447:Source/timers.c **** 		/* Ensure the task unblocks when the tick count rolls over. */
 448:Source/timers.c **** 		xNextExpireTime = ( portTickType ) 0U;
 586              		.loc 1 448 0
 587 0032 0023     		movs	r3, #0
 588 0034 FB60     		str	r3, [r7, #12]
 589              	.L38:
 449:Source/timers.c **** 	}
 450:Source/timers.c **** 
 451:Source/timers.c **** 	return xNextExpireTime;
 590              		.loc 1 451 0
 591 0036 FB68     		ldr	r3, [r7, #12]
 452:Source/timers.c **** }
 592              		.loc 1 452 0
 593 0038 1846     		mov	r0, r3
 594 003a 1437     		adds	r7, r7, #20
 595 003c BD46     		mov	sp, r7
 596              		@ sp needed
 597 003e 5DF8047B 		ldr	r7, [sp], #4
 598 0042 7047     		bx	lr
 599              	.L41:
 600              		.align	2
 601              	.L40:
 602 0044 00000000 		.word	pxCurrentTimerList
 603              		.cfi_endproc
 604              	.LFE116:
 606              		.section	.text.prvSampleTimeNow,"ax",%progbits
 607              		.align	2
 608              		.thumb
 609              		.thumb_func
 611              	prvSampleTimeNow:
 612              	.LFB117:
 453:Source/timers.c **** /*-----------------------------------------------------------*/
 454:Source/timers.c **** 
 455:Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
 456:Source/timers.c **** {
 613              		.loc 1 456 0
 614              		.cfi_startproc
 615              		@ args = 0, pretend = 0, frame = 16
 616              		@ frame_needed = 1, uses_anonymous_args = 0
 617 0000 80B5     		push	{r7, lr}
 618              	.LCFI21:
 619              		.cfi_def_cfa_offset 8
 620              		.cfi_offset 7, -8
 621              		.cfi_offset 14, -4
 622 0002 84B0     		sub	sp, sp, #16
 623              	.LCFI22:
 624              		.cfi_def_cfa_offset 24
 625 0004 00AF     		add	r7, sp, #0
 626              	.LCFI23:
 627              		.cfi_def_cfa_register 7
 628 0006 7860     		str	r0, [r7, #4]
 457:Source/timers.c **** portTickType xTimeNow;
 458:Source/timers.c **** PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only 
 459:Source/timers.c **** 
 460:Source/timers.c **** 	xTimeNow = xTaskGetTickCount();
 629              		.loc 1 460 0
 630 0008 FFF7FEFF 		bl	xTaskGetTickCount
 631 000c F860     		str	r0, [r7, #12]
 461:Source/timers.c **** 
 462:Source/timers.c **** 	if( xTimeNow < xLastTime )
 632              		.loc 1 462 0
 633 000e 0C4B     		ldr	r3, .L46
 634 0010 1B68     		ldr	r3, [r3]
 635 0012 FA68     		ldr	r2, [r7, #12]
 636 0014 9A42     		cmp	r2, r3
 637 0016 08D2     		bcs	.L43
 463:Source/timers.c **** 	{
 464:Source/timers.c **** 		prvSwitchTimerLists( xLastTime );
 638              		.loc 1 464 0
 639 0018 094B     		ldr	r3, .L46
 640 001a 1B68     		ldr	r3, [r3]
 641 001c 1846     		mov	r0, r3
 642 001e FFF7FEFF 		bl	prvSwitchTimerLists
 465:Source/timers.c **** 		*pxTimerListsWereSwitched = pdTRUE;
 643              		.loc 1 465 0
 644 0022 7B68     		ldr	r3, [r7, #4]
 645 0024 0122     		movs	r2, #1
 646 0026 1A60     		str	r2, [r3]
 647 0028 02E0     		b	.L44
 648              	.L43:
 466:Source/timers.c **** 	}
 467:Source/timers.c **** 	else
 468:Source/timers.c **** 	{
 469:Source/timers.c **** 		*pxTimerListsWereSwitched = pdFALSE;
 649              		.loc 1 469 0
 650 002a 7B68     		ldr	r3, [r7, #4]
 651 002c 0022     		movs	r2, #0
 652 002e 1A60     		str	r2, [r3]
 653              	.L44:
 470:Source/timers.c **** 	}
 471:Source/timers.c **** 
 472:Source/timers.c **** 	xLastTime = xTimeNow;
 654              		.loc 1 472 0
 655 0030 034B     		ldr	r3, .L46
 656 0032 FA68     		ldr	r2, [r7, #12]
 657 0034 1A60     		str	r2, [r3]
 473:Source/timers.c **** 
 474:Source/timers.c **** 	return xTimeNow;
 658              		.loc 1 474 0
 659 0036 FB68     		ldr	r3, [r7, #12]
 475:Source/timers.c **** }
 660              		.loc 1 475 0
 661 0038 1846     		mov	r0, r3
 662 003a 1037     		adds	r7, r7, #16
 663 003c BD46     		mov	sp, r7
 664              		@ sp needed
 665 003e 80BD     		pop	{r7, pc}
 666              	.L47:
 667              		.align	2
 668              	.L46:
 669 0040 00000000 		.word	xLastTime.8302
 670              		.cfi_endproc
 671              	.LFE117:
 673              		.section	.text.prvInsertTimerInActiveList,"ax",%progbits
 674              		.align	2
 675              		.thumb
 676              		.thumb_func
 678              	prvInsertTimerInActiveList:
 679              	.LFB118:
 476:Source/timers.c **** /*-----------------------------------------------------------*/
 477:Source/timers.c **** 
 478:Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 479:Source/timers.c **** {
 680              		.loc 1 479 0
 681              		.cfi_startproc
 682              		@ args = 0, pretend = 0, frame = 24
 683              		@ frame_needed = 1, uses_anonymous_args = 0
 684 0000 80B5     		push	{r7, lr}
 685              	.LCFI24:
 686              		.cfi_def_cfa_offset 8
 687              		.cfi_offset 7, -8
 688              		.cfi_offset 14, -4
 689 0002 86B0     		sub	sp, sp, #24
 690              	.LCFI25:
 691              		.cfi_def_cfa_offset 32
 692 0004 00AF     		add	r7, sp, #0
 693              	.LCFI26:
 694              		.cfi_def_cfa_register 7
 695 0006 F860     		str	r0, [r7, #12]
 696 0008 B960     		str	r1, [r7, #8]
 697 000a 7A60     		str	r2, [r7, #4]
 698 000c 3B60     		str	r3, [r7]
 480:Source/timers.c **** portBASE_TYPE xProcessTimerNow = pdFALSE;
 699              		.loc 1 480 0
 700 000e 0023     		movs	r3, #0
 701 0010 7B61     		str	r3, [r7, #20]
 481:Source/timers.c **** 
 482:Source/timers.c **** 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 702              		.loc 1 482 0
 703 0012 FB68     		ldr	r3, [r7, #12]
 704 0014 BA68     		ldr	r2, [r7, #8]
 705 0016 5A60     		str	r2, [r3, #4]
 483:Source/timers.c **** 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 706              		.loc 1 483 0
 707 0018 FB68     		ldr	r3, [r7, #12]
 708 001a FA68     		ldr	r2, [r7, #12]
 709 001c 1A61     		str	r2, [r3, #16]
 484:Source/timers.c **** 
 485:Source/timers.c **** 	if( xNextExpiryTime <= xTimeNow )
 710              		.loc 1 485 0
 711 001e BA68     		ldr	r2, [r7, #8]
 712 0020 7B68     		ldr	r3, [r7, #4]
 713 0022 9A42     		cmp	r2, r3
 714 0024 12D8     		bhi	.L49
 486:Source/timers.c **** 	{
 487:Source/timers.c **** 		/* Has the expiry time elapsed between the command to start/reset a
 488:Source/timers.c **** 		timer was issued, and the time the command was processed? */
 489:Source/timers.c **** 		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 715              		.loc 1 489 0
 716 0026 7A68     		ldr	r2, [r7, #4]
 717 0028 3B68     		ldr	r3, [r7]
 718 002a D21A     		subs	r2, r2, r3
 719 002c FB68     		ldr	r3, [r7, #12]
 720 002e 9B69     		ldr	r3, [r3, #24]
 721 0030 9A42     		cmp	r2, r3
 722 0032 02D3     		bcc	.L50
 490:Source/timers.c **** 		{
 491:Source/timers.c **** 			/* The time between a command being issued and the command being
 492:Source/timers.c **** 			processed actually exceeds the timers period.  */
 493:Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 723              		.loc 1 493 0
 724 0034 0123     		movs	r3, #1
 725 0036 7B61     		str	r3, [r7, #20]
 726 0038 1BE0     		b	.L52
 727              	.L50:
 494:Source/timers.c **** 		}
 495:Source/timers.c **** 		else
 496:Source/timers.c **** 		{
 497:Source/timers.c **** 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 728              		.loc 1 497 0
 729 003a 104B     		ldr	r3, .L55
 730 003c 1A68     		ldr	r2, [r3]
 731 003e FB68     		ldr	r3, [r7, #12]
 732 0040 0433     		adds	r3, r3, #4
 733 0042 1046     		mov	r0, r2
 734 0044 1946     		mov	r1, r3
 735 0046 FFF7FEFF 		bl	vListInsert
 736 004a 12E0     		b	.L52
 737              	.L49:
 498:Source/timers.c **** 		}
 499:Source/timers.c **** 	}
 500:Source/timers.c **** 	else
 501:Source/timers.c **** 	{
 502:Source/timers.c **** 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 738              		.loc 1 502 0
 739 004c 7A68     		ldr	r2, [r7, #4]
 740 004e 3B68     		ldr	r3, [r7]
 741 0050 9A42     		cmp	r2, r3
 742 0052 06D2     		bcs	.L53
 743              		.loc 1 502 0 is_stmt 0 discriminator 1
 744 0054 BA68     		ldr	r2, [r7, #8]
 745 0056 3B68     		ldr	r3, [r7]
 746 0058 9A42     		cmp	r2, r3
 747 005a 02D3     		bcc	.L53
 503:Source/timers.c **** 		{
 504:Source/timers.c **** 			/* If, since the command was issued, the tick count has overflowed
 505:Source/timers.c **** 			but the expiry time has not, then the timer must have already passed
 506:Source/timers.c **** 			its expiry time and should be processed immediately. */
 507:Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 748              		.loc 1 507 0 is_stmt 1
 749 005c 0123     		movs	r3, #1
 750 005e 7B61     		str	r3, [r7, #20]
 751 0060 07E0     		b	.L52
 752              	.L53:
 508:Source/timers.c **** 		}
 509:Source/timers.c **** 		else
 510:Source/timers.c **** 		{
 511:Source/timers.c **** 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 753              		.loc 1 511 0
 754 0062 074B     		ldr	r3, .L55+4
 755 0064 1A68     		ldr	r2, [r3]
 756 0066 FB68     		ldr	r3, [r7, #12]
 757 0068 0433     		adds	r3, r3, #4
 758 006a 1046     		mov	r0, r2
 759 006c 1946     		mov	r1, r3
 760 006e FFF7FEFF 		bl	vListInsert
 761              	.L52:
 512:Source/timers.c **** 		}
 513:Source/timers.c **** 	}
 514:Source/timers.c **** 
 515:Source/timers.c **** 	return xProcessTimerNow;
 762              		.loc 1 515 0
 763 0072 7B69     		ldr	r3, [r7, #20]
 516:Source/timers.c **** }
 764              		.loc 1 516 0
 765 0074 1846     		mov	r0, r3
 766 0076 1837     		adds	r7, r7, #24
 767 0078 BD46     		mov	sp, r7
 768              		@ sp needed
 769 007a 80BD     		pop	{r7, pc}
 770              	.L56:
 771              		.align	2
 772              	.L55:
 773 007c 00000000 		.word	pxOverflowTimerList
 774 0080 00000000 		.word	pxCurrentTimerList
 775              		.cfi_endproc
 776              	.LFE118:
 778              		.section	.text.prvProcessReceivedCommands,"ax",%progbits
 779              		.align	2
 780              		.thumb
 781              		.thumb_func
 783              	prvProcessReceivedCommands:
 784              	.LFB119:
 517:Source/timers.c **** /*-----------------------------------------------------------*/
 518:Source/timers.c **** 
 519:Source/timers.c **** static void	prvProcessReceivedCommands( void )
 520:Source/timers.c **** {
 785              		.loc 1 520 0
 786              		.cfi_startproc
 787              		@ args = 0, pretend = 0, frame = 32
 788              		@ frame_needed = 1, uses_anonymous_args = 0
 789 0000 80B5     		push	{r7, lr}
 790              	.LCFI27:
 791              		.cfi_def_cfa_offset 8
 792              		.cfi_offset 7, -8
 793              		.cfi_offset 14, -4
 794 0002 8AB0     		sub	sp, sp, #40
 795              	.LCFI28:
 796              		.cfi_def_cfa_offset 48
 797 0004 02AF     		add	r7, sp, #8
 798              	.LCFI29:
 799              		.cfi_def_cfa 7, 40
 521:Source/timers.c **** xTIMER_MESSAGE xMessage;
 522:Source/timers.c **** xTIMER *pxTimer;
 523:Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched, xResult;
 524:Source/timers.c **** portTickType xTimeNow;
 525:Source/timers.c **** 
 526:Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does
 800              		.loc 1 526 0
 801 0006 60E0     		b	.L58
 802              	.L70:
 527:Source/timers.c **** 	{
 528:Source/timers.c **** 		pxTimer = xMessage.pxTimer;
 803              		.loc 1 528 0
 804 0008 3B69     		ldr	r3, [r7, #16]
 805 000a FB61     		str	r3, [r7, #28]
 529:Source/timers.c **** 
 530:Source/timers.c **** 		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 806              		.loc 1 530 0
 807 000c FB69     		ldr	r3, [r7, #28]
 808 000e 5B69     		ldr	r3, [r3, #20]
 809 0010 002B     		cmp	r3, #0
 810 0012 04D0     		beq	.L59
 531:Source/timers.c **** 		{
 532:Source/timers.c **** 			/* The timer is in a list, remove it. */
 533:Source/timers.c **** 			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 811              		.loc 1 533 0
 812 0014 FB69     		ldr	r3, [r7, #28]
 813 0016 0433     		adds	r3, r3, #4
 814 0018 1846     		mov	r0, r3
 815 001a FFF7FEFF 		bl	uxListRemove
 816              	.L59:
 534:Source/timers.c **** 		}
 535:Source/timers.c **** 
 536:Source/timers.c **** 		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
 537:Source/timers.c **** 
 538:Source/timers.c **** 		/* In this case the xTimerListsWereSwitched parameter is not used, but 
 539:Source/timers.c **** 		it must be present in the function call.  prvSampleTimeNow() must be 
 540:Source/timers.c **** 		called after the message is received from xTimerQueue so there is no 
 541:Source/timers.c **** 		possibility of a higher priority task adding a message to the message
 542:Source/timers.c **** 		queue with a time that is ahead of the timer daemon task (because it
 543:Source/timers.c **** 		pre-empted the timer daemon task after the xTimeNow value was set). */
 544:Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 817              		.loc 1 544 0
 818 001e 3B1D     		adds	r3, r7, #4
 819 0020 1846     		mov	r0, r3
 820 0022 FFF7FEFF 		bl	prvSampleTimeNow
 821 0026 B861     		str	r0, [r7, #24]
 545:Source/timers.c **** 
 546:Source/timers.c **** 		switch( xMessage.xMessageID )
 822              		.loc 1 546 0
 823 0028 BB68     		ldr	r3, [r7, #8]
 824 002a 032B     		cmp	r3, #3
 825 002c 4CD8     		bhi	.L71
 826 002e 01A2     		adr	r2, .L62
 827 0030 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 828              		.p2align 2
 829              	.L62:
 830 0034 45000000 		.word	.L61+1
 831 0038 C9000000 		.word	.L71+1
 832 003c 97000000 		.word	.L64+1
 833 0040 C1000000 		.word	.L65+1
 834              	.L61:
 547:Source/timers.c **** 		{
 548:Source/timers.c **** 			case tmrCOMMAND_START :
 549:Source/timers.c **** 				/* Start or restart a timer. */
 550:Source/timers.c **** 				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks
 835              		.loc 1 550 0
 836 0044 FA68     		ldr	r2, [r7, #12]
 837 0046 FB69     		ldr	r3, [r7, #28]
 838 0048 9B69     		ldr	r3, [r3, #24]
 839 004a 1A44     		add	r2, r2, r3
 840 004c FB68     		ldr	r3, [r7, #12]
 841 004e F869     		ldr	r0, [r7, #28]
 842 0050 1146     		mov	r1, r2
 843 0052 BA69     		ldr	r2, [r7, #24]
 844 0054 FFF7FEFF 		bl	prvInsertTimerInActiveList
 845 0058 0346     		mov	r3, r0
 846 005a 012B     		cmp	r3, #1
 847 005c 1AD1     		bne	.L66
 551:Source/timers.c **** 				{
 552:Source/timers.c **** 					/* The timer expired before it was added to the active timer
 553:Source/timers.c **** 					list.  Process it now. */
 554:Source/timers.c **** 					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 848              		.loc 1 554 0
 849 005e FB69     		ldr	r3, [r7, #28]
 850 0060 5B6A     		ldr	r3, [r3, #36]
 851 0062 F869     		ldr	r0, [r7, #28]
 852 0064 9847     		blx	r3
 555:Source/timers.c **** 
 556:Source/timers.c **** 					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 853              		.loc 1 556 0
 854 0066 FB69     		ldr	r3, [r7, #28]
 855 0068 DB69     		ldr	r3, [r3, #28]
 856 006a 012B     		cmp	r3, #1
 857 006c 12D1     		bne	.L66
 557:Source/timers.c **** 					{
 558:Source/timers.c **** 						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->
 858              		.loc 1 558 0
 859 006e FA68     		ldr	r2, [r7, #12]
 860 0070 FB69     		ldr	r3, [r7, #28]
 861 0072 9B69     		ldr	r3, [r3, #24]
 862 0074 1344     		add	r3, r3, r2
 863 0076 0022     		movs	r2, #0
 864 0078 0092     		str	r2, [sp]
 865 007a F869     		ldr	r0, [r7, #28]
 866 007c 0021     		movs	r1, #0
 867 007e 1A46     		mov	r2, r3
 868 0080 0023     		movs	r3, #0
 869 0082 FFF7FEFF 		bl	xTimerGenericCommand
 870 0086 7861     		str	r0, [r7, #20]
 559:Source/timers.c **** 						configASSERT( xResult );
 871              		.loc 1 559 0
 872 0088 7B69     		ldr	r3, [r7, #20]
 873 008a 002B     		cmp	r3, #0
 874 008c 02D1     		bne	.L66
 875              		.loc 1 559 0 is_stmt 0 discriminator 1
 876 008e FFF7FEFF 		bl	ulPortSetInterruptMask
 877              	.L67:
 878 0092 FEE7     		b	.L67
 879              	.L66:
 560:Source/timers.c **** 						( void ) xResult;
 561:Source/timers.c **** 					}
 562:Source/timers.c **** 				}
 563:Source/timers.c **** 				break;
 880              		.loc 1 563 0 is_stmt 1
 881 0094 19E0     		b	.L58
 882              	.L64:
 564:Source/timers.c **** 
 565:Source/timers.c **** 			case tmrCOMMAND_STOP :
 566:Source/timers.c **** 				/* The timer has already been removed from the active list.
 567:Source/timers.c **** 				There is nothing to do here. */
 568:Source/timers.c **** 				break;
 569:Source/timers.c **** 
 570:Source/timers.c **** 			case tmrCOMMAND_CHANGE_PERIOD :
 571:Source/timers.c **** 				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 883              		.loc 1 571 0
 884 0096 FA68     		ldr	r2, [r7, #12]
 885 0098 FB69     		ldr	r3, [r7, #28]
 886 009a 9A61     		str	r2, [r3, #24]
 572:Source/timers.c **** 				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 887              		.loc 1 572 0
 888 009c FB69     		ldr	r3, [r7, #28]
 889 009e 9B69     		ldr	r3, [r3, #24]
 890 00a0 002B     		cmp	r3, #0
 891 00a2 02D1     		bne	.L68
 892              		.loc 1 572 0 is_stmt 0 discriminator 1
 893 00a4 FFF7FEFF 		bl	ulPortSetInterruptMask
 894              	.L69:
 895 00a8 FEE7     		b	.L69
 896              	.L68:
 573:Source/timers.c **** 
 574:Source/timers.c **** 				/* The new period does not really have a reference, and can be
 575:Source/timers.c **** 				longer or shorter than the old one.  The command time is 
 576:Source/timers.c **** 				therefore set to the current time, and as the period cannot be
 577:Source/timers.c **** 				zero the next expiry time can only be in the future, meaning
 578:Source/timers.c **** 				(unlike for the xTimerStart() case above) there is no fail case
 579:Source/timers.c **** 				that needs to be handled here. */
 580:Source/timers.c **** 				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTim
 897              		.loc 1 580 0 is_stmt 1
 898 00aa FB69     		ldr	r3, [r7, #28]
 899 00ac 9A69     		ldr	r2, [r3, #24]
 900 00ae BB69     		ldr	r3, [r7, #24]
 901 00b0 1344     		add	r3, r3, r2
 902 00b2 F869     		ldr	r0, [r7, #28]
 903 00b4 1946     		mov	r1, r3
 904 00b6 BA69     		ldr	r2, [r7, #24]
 905 00b8 BB69     		ldr	r3, [r7, #24]
 906 00ba FFF7FEFF 		bl	prvInsertTimerInActiveList
 581:Source/timers.c **** 				break;
 907              		.loc 1 581 0
 908 00be 04E0     		b	.L58
 909              	.L65:
 582:Source/timers.c **** 
 583:Source/timers.c **** 			case tmrCOMMAND_DELETE :
 584:Source/timers.c **** 				/* The timer has already been removed from the active list,
 585:Source/timers.c **** 				just free up the memory. */
 586:Source/timers.c **** 				vPortFree( pxTimer );
 910              		.loc 1 586 0
 911 00c0 F869     		ldr	r0, [r7, #28]
 912 00c2 FFF7FEFF 		bl	vPortFree
 587:Source/timers.c **** 				break;
 913              		.loc 1 587 0
 914 00c6 00E0     		b	.L58
 915              	.L71:
 588:Source/timers.c **** 
 589:Source/timers.c **** 			default	:
 590:Source/timers.c **** 				/* Don't expect to get here. */
 591:Source/timers.c **** 				break;
 916              		.loc 1 591 0
 917 00c8 00BF     		nop
 918              	.L58:
 526:Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does
 919              		.loc 1 526 0 discriminator 1
 920 00ca 084B     		ldr	r3, .L72
 921 00cc 1A68     		ldr	r2, [r3]
 922 00ce 07F10803 		add	r3, r7, #8
 923 00d2 1046     		mov	r0, r2
 924 00d4 1946     		mov	r1, r3
 925 00d6 0022     		movs	r2, #0
 926 00d8 0023     		movs	r3, #0
 927 00da FFF7FEFF 		bl	xQueueGenericReceive
 928 00de 0346     		mov	r3, r0
 929 00e0 002B     		cmp	r3, #0
 930 00e2 91D1     		bne	.L70
 592:Source/timers.c **** 		}
 593:Source/timers.c **** 	}
 594:Source/timers.c **** }
 931              		.loc 1 594 0
 932 00e4 2037     		adds	r7, r7, #32
 933 00e6 BD46     		mov	sp, r7
 934              		@ sp needed
 935 00e8 80BD     		pop	{r7, pc}
 936              	.L73:
 937 00ea 00BF     		.align	2
 938              	.L72:
 939 00ec 00000000 		.word	xTimerQueue
 940              		.cfi_endproc
 941              	.LFE119:
 943              		.section	.text.prvSwitchTimerLists,"ax",%progbits
 944              		.align	2
 945              		.thumb
 946              		.thumb_func
 948              	prvSwitchTimerLists:
 949              	.LFB120:
 595:Source/timers.c **** /*-----------------------------------------------------------*/
 596:Source/timers.c **** 
 597:Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime )
 598:Source/timers.c **** {
 950              		.loc 1 598 0
 951              		.cfi_startproc
 952              		@ args = 0, pretend = 0, frame = 32
 953              		@ frame_needed = 1, uses_anonymous_args = 0
 954 0000 80B5     		push	{r7, lr}
 955              	.LCFI30:
 956              		.cfi_def_cfa_offset 8
 957              		.cfi_offset 7, -8
 958              		.cfi_offset 14, -4
 959 0002 8AB0     		sub	sp, sp, #40
 960              	.LCFI31:
 961              		.cfi_def_cfa_offset 48
 962 0004 02AF     		add	r7, sp, #8
 963              	.LCFI32:
 964              		.cfi_def_cfa 7, 40
 965 0006 7860     		str	r0, [r7, #4]
 599:Source/timers.c **** portTickType xNextExpireTime, xReloadTime;
 600:Source/timers.c **** xList *pxTemp;
 601:Source/timers.c **** xTIMER *pxTimer;
 602:Source/timers.c **** portBASE_TYPE xResult;
 603:Source/timers.c **** 
 604:Source/timers.c **** 	/* Remove compiler warnings if configASSERT() is not defined. */
 605:Source/timers.c **** 	( void ) xLastTime;
 606:Source/timers.c **** 
 607:Source/timers.c **** 	/* The tick count has overflowed.  The timer lists must be switched.
 608:Source/timers.c **** 	If there are any timers still referenced from the current timer list
 609:Source/timers.c **** 	then they must have expired and should be processed before the lists
 610:Source/timers.c **** 	are switched. */
 611:Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 966              		.loc 1 611 0
 967 0008 3DE0     		b	.L75
 968              	.L78:
 612:Source/timers.c **** 	{
 613:Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 969              		.loc 1 613 0
 970 000a 284B     		ldr	r3, .L79
 971 000c 1B68     		ldr	r3, [r3]
 972 000e DB68     		ldr	r3, [r3, #12]
 973 0010 1B68     		ldr	r3, [r3]
 974 0012 FB61     		str	r3, [r7, #28]
 614:Source/timers.c **** 
 615:Source/timers.c **** 		/* Remove the timer from the list. */
 616:Source/timers.c **** 		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 975              		.loc 1 616 0
 976 0014 254B     		ldr	r3, .L79
 977 0016 1B68     		ldr	r3, [r3]
 978 0018 DB68     		ldr	r3, [r3, #12]
 979 001a DB68     		ldr	r3, [r3, #12]
 980 001c BB61     		str	r3, [r7, #24]
 617:Source/timers.c **** 		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 981              		.loc 1 617 0
 982 001e BB69     		ldr	r3, [r7, #24]
 983 0020 0433     		adds	r3, r3, #4
 984 0022 1846     		mov	r0, r3
 985 0024 FFF7FEFF 		bl	uxListRemove
 618:Source/timers.c **** 
 619:Source/timers.c **** 		/* Execute its callback, then send a command to restart the timer if
 620:Source/timers.c **** 		it is an auto-reload timer.  It cannot be restarted here as the lists
 621:Source/timers.c **** 		have not yet been switched. */
 622:Source/timers.c **** 		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 986              		.loc 1 622 0
 987 0028 BB69     		ldr	r3, [r7, #24]
 988 002a 5B6A     		ldr	r3, [r3, #36]
 989 002c B869     		ldr	r0, [r7, #24]
 990 002e 9847     		blx	r3
 623:Source/timers.c **** 
 624:Source/timers.c **** 		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 991              		.loc 1 624 0
 992 0030 BB69     		ldr	r3, [r7, #24]
 993 0032 DB69     		ldr	r3, [r3, #28]
 994 0034 012B     		cmp	r3, #1
 995 0036 26D1     		bne	.L75
 625:Source/timers.c **** 		{
 626:Source/timers.c **** 			/* Calculate the reload value, and if the reload value results in
 627:Source/timers.c **** 			the timer going into the same timer list then it has already expired
 628:Source/timers.c **** 			and the timer should be re-inserted into the current list so it is
 629:Source/timers.c **** 			processed again within this loop.  Otherwise a command should be sent
 630:Source/timers.c **** 			to restart the timer to ensure it is only inserted into a list after
 631:Source/timers.c **** 			the lists have been swapped. */
 632:Source/timers.c **** 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 996              		.loc 1 632 0
 997 0038 BB69     		ldr	r3, [r7, #24]
 998 003a 9A69     		ldr	r2, [r3, #24]
 999 003c FB69     		ldr	r3, [r7, #28]
 1000 003e 1344     		add	r3, r3, r2
 1001 0040 7B61     		str	r3, [r7, #20]
 633:Source/timers.c **** 			if( xReloadTime > xNextExpireTime )
 1002              		.loc 1 633 0
 1003 0042 7A69     		ldr	r2, [r7, #20]
 1004 0044 FB69     		ldr	r3, [r7, #28]
 1005 0046 9A42     		cmp	r2, r3
 1006 0048 0ED9     		bls	.L76
 634:Source/timers.c **** 			{
 635:Source/timers.c **** 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 1007              		.loc 1 635 0
 1008 004a BB69     		ldr	r3, [r7, #24]
 1009 004c 7A69     		ldr	r2, [r7, #20]
 1010 004e 5A60     		str	r2, [r3, #4]
 636:Source/timers.c **** 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 1011              		.loc 1 636 0
 1012 0050 BB69     		ldr	r3, [r7, #24]
 1013 0052 BA69     		ldr	r2, [r7, #24]
 1014 0054 1A61     		str	r2, [r3, #16]
 637:Source/timers.c **** 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 1015              		.loc 1 637 0
 1016 0056 154B     		ldr	r3, .L79
 1017 0058 1A68     		ldr	r2, [r3]
 1018 005a BB69     		ldr	r3, [r7, #24]
 1019 005c 0433     		adds	r3, r3, #4
 1020 005e 1046     		mov	r0, r2
 1021 0060 1946     		mov	r1, r3
 1022 0062 FFF7FEFF 		bl	vListInsert
 1023 0066 0EE0     		b	.L75
 1024              	.L76:
 638:Source/timers.c **** 			}
 639:Source/timers.c **** 			else
 640:Source/timers.c **** 			{
 641:Source/timers.c **** 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY )
 1025              		.loc 1 641 0
 1026 0068 0023     		movs	r3, #0
 1027 006a 0093     		str	r3, [sp]
 1028 006c B869     		ldr	r0, [r7, #24]
 1029 006e 0021     		movs	r1, #0
 1030 0070 FA69     		ldr	r2, [r7, #28]
 1031 0072 0023     		movs	r3, #0
 1032 0074 FFF7FEFF 		bl	xTimerGenericCommand
 1033 0078 3861     		str	r0, [r7, #16]
 642:Source/timers.c **** 				configASSERT( xResult );
 1034              		.loc 1 642 0
 1035 007a 3B69     		ldr	r3, [r7, #16]
 1036 007c 002B     		cmp	r3, #0
 1037 007e 02D1     		bne	.L75
 1038              		.loc 1 642 0 is_stmt 0 discriminator 1
 1039 0080 FFF7FEFF 		bl	ulPortSetInterruptMask
 1040              	.L77:
 1041 0084 FEE7     		b	.L77
 1042              	.L75:
 611:Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 1043              		.loc 1 611 0 is_stmt 1 discriminator 1
 1044 0086 094B     		ldr	r3, .L79
 1045 0088 1B68     		ldr	r3, [r3]
 1046 008a 1B68     		ldr	r3, [r3]
 1047 008c 002B     		cmp	r3, #0
 1048 008e BCD1     		bne	.L78
 643:Source/timers.c **** 				( void ) xResult;
 644:Source/timers.c **** 			}
 645:Source/timers.c **** 		}
 646:Source/timers.c **** 	}
 647:Source/timers.c **** 
 648:Source/timers.c **** 	pxTemp = pxCurrentTimerList;
 1049              		.loc 1 648 0
 1050 0090 064B     		ldr	r3, .L79
 1051 0092 1B68     		ldr	r3, [r3]
 1052 0094 FB60     		str	r3, [r7, #12]
 649:Source/timers.c **** 	pxCurrentTimerList = pxOverflowTimerList;
 1053              		.loc 1 649 0
 1054 0096 064B     		ldr	r3, .L79+4
 1055 0098 1A68     		ldr	r2, [r3]
 1056 009a 044B     		ldr	r3, .L79
 1057 009c 1A60     		str	r2, [r3]
 650:Source/timers.c **** 	pxOverflowTimerList = pxTemp;
 1058              		.loc 1 650 0
 1059 009e 044B     		ldr	r3, .L79+4
 1060 00a0 FA68     		ldr	r2, [r7, #12]
 1061 00a2 1A60     		str	r2, [r3]
 651:Source/timers.c **** }
 1062              		.loc 1 651 0
 1063 00a4 2037     		adds	r7, r7, #32
 1064 00a6 BD46     		mov	sp, r7
 1065              		@ sp needed
 1066 00a8 80BD     		pop	{r7, pc}
 1067              	.L80:
 1068 00aa 00BF     		.align	2
 1069              	.L79:
 1070 00ac 00000000 		.word	pxCurrentTimerList
 1071 00b0 00000000 		.word	pxOverflowTimerList
 1072              		.cfi_endproc
 1073              	.LFE120:
 1075              		.section	.text.prvCheckForValidListAndQueue,"ax",%progbits
 1076              		.align	2
 1077              		.thumb
 1078              		.thumb_func
 1080              	prvCheckForValidListAndQueue:
 1081              	.LFB121:
 652:Source/timers.c **** /*-----------------------------------------------------------*/
 653:Source/timers.c **** 
 654:Source/timers.c **** static void prvCheckForValidListAndQueue( void )
 655:Source/timers.c **** {
 1082              		.loc 1 655 0
 1083              		.cfi_startproc
 1084              		@ args = 0, pretend = 0, frame = 0
 1085              		@ frame_needed = 1, uses_anonymous_args = 0
 1086 0000 80B5     		push	{r7, lr}
 1087              	.LCFI33:
 1088              		.cfi_def_cfa_offset 8
 1089              		.cfi_offset 7, -8
 1090              		.cfi_offset 14, -4
 1091 0002 00AF     		add	r7, sp, #0
 1092              	.LCFI34:
 1093              		.cfi_def_cfa_register 7
 656:Source/timers.c **** 	/* Check that the list from which active timers are referenced, and the
 657:Source/timers.c **** 	queue used to communicate with the timer service, have been
 658:Source/timers.c **** 	initialised. */
 659:Source/timers.c **** 	taskENTER_CRITICAL();
 1094              		.loc 1 659 0
 1095 0004 FFF7FEFF 		bl	vPortEnterCritical
 660:Source/timers.c **** 	{
 661:Source/timers.c **** 		if( xTimerQueue == NULL )
 1096              		.loc 1 661 0
 1097 0008 0D4B     		ldr	r3, .L83
 1098 000a 1B68     		ldr	r3, [r3]
 1099 000c 002B     		cmp	r3, #0
 1100 000e 13D1     		bne	.L82
 662:Source/timers.c **** 		{
 663:Source/timers.c **** 			vListInitialise( &xActiveTimerList1 );
 1101              		.loc 1 663 0
 1102 0010 0C48     		ldr	r0, .L83+4
 1103 0012 FFF7FEFF 		bl	vListInitialise
 664:Source/timers.c **** 			vListInitialise( &xActiveTimerList2 );
 1104              		.loc 1 664 0
 1105 0016 0C48     		ldr	r0, .L83+8
 1106 0018 FFF7FEFF 		bl	vListInitialise
 665:Source/timers.c **** 			pxCurrentTimerList = &xActiveTimerList1;
 1107              		.loc 1 665 0
 1108 001c 0B4B     		ldr	r3, .L83+12
 1109 001e 094A     		ldr	r2, .L83+4
 1110 0020 1A60     		str	r2, [r3]
 666:Source/timers.c **** 			pxOverflowTimerList = &xActiveTimerList2;
 1111              		.loc 1 666 0
 1112 0022 0B4B     		ldr	r3, .L83+16
 1113 0024 084A     		ldr	r2, .L83+8
 1114 0026 1A60     		str	r2, [r3]
 667:Source/timers.c **** 			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_
 1115              		.loc 1 667 0
 1116 0028 0A20     		movs	r0, #10
 1117 002a 0C21     		movs	r1, #12
 1118 002c 0022     		movs	r2, #0
 1119 002e FFF7FEFF 		bl	xQueueGenericCreate
 1120 0032 0246     		mov	r2, r0
 1121 0034 024B     		ldr	r3, .L83
 1122 0036 1A60     		str	r2, [r3]
 1123              	.L82:
 668:Source/timers.c **** 		}
 669:Source/timers.c **** 	}
 670:Source/timers.c **** 	taskEXIT_CRITICAL();
 1124              		.loc 1 670 0
 1125 0038 FFF7FEFF 		bl	vPortExitCritical
 671:Source/timers.c **** }
 1126              		.loc 1 671 0
 1127 003c 80BD     		pop	{r7, pc}
 1128              	.L84:
 1129 003e 00BF     		.align	2
 1130              	.L83:
 1131 0040 00000000 		.word	xTimerQueue
 1132 0044 00000000 		.word	xActiveTimerList1
 1133 0048 00000000 		.word	xActiveTimerList2
 1134 004c 00000000 		.word	pxCurrentTimerList
 1135 0050 00000000 		.word	pxOverflowTimerList
 1136              		.cfi_endproc
 1137              	.LFE121:
 1139              		.section	.text.xTimerIsTimerActive,"ax",%progbits
 1140              		.align	2
 1141              		.global	xTimerIsTimerActive
 1142              		.thumb
 1143              		.thumb_func
 1145              	xTimerIsTimerActive:
 1146              	.LFB122:
 672:Source/timers.c **** /*-----------------------------------------------------------*/
 673:Source/timers.c **** 
 674:Source/timers.c **** portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
 675:Source/timers.c **** {
 1147              		.loc 1 675 0
 1148              		.cfi_startproc
 1149              		@ args = 0, pretend = 0, frame = 16
 1150              		@ frame_needed = 1, uses_anonymous_args = 0
 1151 0000 80B5     		push	{r7, lr}
 1152              	.LCFI35:
 1153              		.cfi_def_cfa_offset 8
 1154              		.cfi_offset 7, -8
 1155              		.cfi_offset 14, -4
 1156 0002 84B0     		sub	sp, sp, #16
 1157              	.LCFI36:
 1158              		.cfi_def_cfa_offset 24
 1159 0004 00AF     		add	r7, sp, #0
 1160              	.LCFI37:
 1161              		.cfi_def_cfa_register 7
 1162 0006 7860     		str	r0, [r7, #4]
 676:Source/timers.c **** portBASE_TYPE xTimerIsInActiveList;
 677:Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1163              		.loc 1 677 0
 1164 0008 7B68     		ldr	r3, [r7, #4]
 1165 000a FB60     		str	r3, [r7, #12]
 678:Source/timers.c **** 
 679:Source/timers.c **** 	/* Is the timer in the list of active timers? */
 680:Source/timers.c **** 	taskENTER_CRITICAL();
 1166              		.loc 1 680 0
 1167 000c FFF7FEFF 		bl	vPortEnterCritical
 681:Source/timers.c **** 	{
 682:Source/timers.c **** 		/* Checking to see if it is in the NULL list in effect checks to see if
 683:Source/timers.c **** 		it is referenced from either the current or the overflow timer lists in
 684:Source/timers.c **** 		one go, but the logic has to be reversed, hence the '!'. */
 685:Source/timers.c **** 		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 1168              		.loc 1 685 0
 1169 0010 FB68     		ldr	r3, [r7, #12]
 1170 0012 5B69     		ldr	r3, [r3, #20]
 1171 0014 002B     		cmp	r3, #0
 1172 0016 0CBF     		ite	eq
 1173 0018 0023     		moveq	r3, #0
 1174 001a 0123     		movne	r3, #1
 1175 001c DBB2     		uxtb	r3, r3
 1176 001e BB60     		str	r3, [r7, #8]
 686:Source/timers.c **** 	}
 687:Source/timers.c **** 	taskEXIT_CRITICAL();
 1177              		.loc 1 687 0
 1178 0020 FFF7FEFF 		bl	vPortExitCritical
 688:Source/timers.c **** 
 689:Source/timers.c **** 	return xTimerIsInActiveList;
 1179              		.loc 1 689 0
 1180 0024 BB68     		ldr	r3, [r7, #8]
 690:Source/timers.c **** }
 1181              		.loc 1 690 0
 1182 0026 1846     		mov	r0, r3
 1183 0028 1037     		adds	r7, r7, #16
 1184 002a BD46     		mov	sp, r7
 1185              		@ sp needed
 1186 002c 80BD     		pop	{r7, pc}
 1187              		.cfi_endproc
 1188              	.LFE122:
 1190 002e 00BF     		.section	.text.pvTimerGetTimerID,"ax",%progbits
 1191              		.align	2
 1192              		.global	pvTimerGetTimerID
 1193              		.thumb
 1194              		.thumb_func
 1196              	pvTimerGetTimerID:
 1197              	.LFB123:
 691:Source/timers.c **** /*-----------------------------------------------------------*/
 692:Source/timers.c **** 
 693:Source/timers.c **** void *pvTimerGetTimerID( xTimerHandle xTimer )
 694:Source/timers.c **** {
 1198              		.loc 1 694 0
 1199              		.cfi_startproc
 1200              		@ args = 0, pretend = 0, frame = 16
 1201              		@ frame_needed = 1, uses_anonymous_args = 0
 1202              		@ link register save eliminated.
 1203 0000 80B4     		push	{r7}
 1204              	.LCFI38:
 1205              		.cfi_def_cfa_offset 4
 1206              		.cfi_offset 7, -4
 1207 0002 85B0     		sub	sp, sp, #20
 1208              	.LCFI39:
 1209              		.cfi_def_cfa_offset 24
 1210 0004 00AF     		add	r7, sp, #0
 1211              	.LCFI40:
 1212              		.cfi_def_cfa_register 7
 1213 0006 7860     		str	r0, [r7, #4]
 695:Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1214              		.loc 1 695 0
 1215 0008 7B68     		ldr	r3, [r7, #4]
 1216 000a FB60     		str	r3, [r7, #12]
 696:Source/timers.c **** 
 697:Source/timers.c **** 	return pxTimer->pvTimerID;
 1217              		.loc 1 697 0
 1218 000c FB68     		ldr	r3, [r7, #12]
 1219 000e 1B6A     		ldr	r3, [r3, #32]
 698:Source/timers.c **** }
 1220              		.loc 1 698 0
 1221 0010 1846     		mov	r0, r3
 1222 0012 1437     		adds	r7, r7, #20
 1223 0014 BD46     		mov	sp, r7
 1224              		@ sp needed
 1225 0016 5DF8047B 		ldr	r7, [sp], #4
 1226 001a 7047     		bx	lr
 1227              		.cfi_endproc
 1228              	.LFE123:
 1230              		.section	.bss.xLastTime.8302,"aw",%nobits
 1231              		.align	2
 1234              	xLastTime.8302:
 1235 0000 00000000 		.space	4
 1236              		.text
 1237              	.Letext0:
 1238              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 1239              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 1240              		.file 4 "Source/include/list.h"
 1241              		.file 5 "Source/include/queue.h"
 1242              		.file 6 "Source/include/timers.h"
 1243              		.file 7 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/ccRYimFo.s:20     .bss.xActiveTimerList1:00000000 $d
     /tmp/ccRYimFo.s:23     .bss.xActiveTimerList1:00000000 xActiveTimerList1
     /tmp/ccRYimFo.s:26     .bss.xActiveTimerList2:00000000 $d
     /tmp/ccRYimFo.s:29     .bss.xActiveTimerList2:00000000 xActiveTimerList2
     /tmp/ccRYimFo.s:32     .bss.pxCurrentTimerList:00000000 $d
     /tmp/ccRYimFo.s:35     .bss.pxCurrentTimerList:00000000 pxCurrentTimerList
     /tmp/ccRYimFo.s:38     .bss.pxOverflowTimerList:00000000 $d
     /tmp/ccRYimFo.s:41     .bss.pxOverflowTimerList:00000000 pxOverflowTimerList
     /tmp/ccRYimFo.s:44     .bss.xTimerQueue:00000000 $d
     /tmp/ccRYimFo.s:47     .bss.xTimerQueue:00000000 xTimerQueue
     /tmp/ccRYimFo.s:50     .rodata:00000000 $d
     /tmp/ccRYimFo.s:54     .text.xTimerCreateTimerTask:00000000 $t
     /tmp/ccRYimFo.s:59     .text.xTimerCreateTimerTask:00000000 xTimerCreateTimerTask
     /tmp/ccRYimFo.s:1080   .text.prvCheckForValidListAndQueue:00000000 prvCheckForValidListAndQueue
     /tmp/ccRYimFo.s:123    .text.xTimerCreateTimerTask:0000004c $d
     /tmp/ccRYimFo.s:417    .text.prvTimerTask:00000000 prvTimerTask
     /tmp/ccRYimFo.s:130    .text.xTimerCreate:00000000 $t
     /tmp/ccRYimFo.s:135    .text.xTimerCreate:00000000 xTimerCreate
     /tmp/ccRYimFo.s:222    .text.xTimerGenericCommand:00000000 $t
     /tmp/ccRYimFo.s:227    .text.xTimerGenericCommand:00000000 xTimerGenericCommand
     /tmp/ccRYimFo.s:320    .text.xTimerGenericCommand:00000088 $d
     /tmp/ccRYimFo.s:325    .text.prvProcessExpiredTimer:00000000 $t
     /tmp/ccRYimFo.s:329    .text.prvProcessExpiredTimer:00000000 prvProcessExpiredTimer
     /tmp/ccRYimFo.s:678    .text.prvInsertTimerInActiveList:00000000 prvInsertTimerInActiveList
     /tmp/ccRYimFo.s:408    .text.prvProcessExpiredTimer:0000006c $d
     /tmp/ccRYimFo.s:413    .text.prvTimerTask:00000000 $t
     /tmp/ccRYimFo.s:543    .text.prvGetNextExpireTime:00000000 prvGetNextExpireTime
     /tmp/ccRYimFo.s:458    .text.prvProcessTimerOrBlockTask:00000000 prvProcessTimerOrBlockTask
     /tmp/ccRYimFo.s:783    .text.prvProcessReceivedCommands:00000000 prvProcessReceivedCommands
     /tmp/ccRYimFo.s:454    .text.prvProcessTimerOrBlockTask:00000000 $t
     /tmp/ccRYimFo.s:611    .text.prvSampleTimeNow:00000000 prvSampleTimeNow
     /tmp/ccRYimFo.s:534    .text.prvProcessTimerOrBlockTask:00000068 $d
     /tmp/ccRYimFo.s:539    .text.prvGetNextExpireTime:00000000 $t
     /tmp/ccRYimFo.s:602    .text.prvGetNextExpireTime:00000044 $d
     /tmp/ccRYimFo.s:607    .text.prvSampleTimeNow:00000000 $t
     /tmp/ccRYimFo.s:948    .text.prvSwitchTimerLists:00000000 prvSwitchTimerLists
     /tmp/ccRYimFo.s:669    .text.prvSampleTimeNow:00000040 $d
     /tmp/ccRYimFo.s:1234   .bss.xLastTime.8302:00000000 xLastTime.8302
     /tmp/ccRYimFo.s:674    .text.prvInsertTimerInActiveList:00000000 $t
     /tmp/ccRYimFo.s:773    .text.prvInsertTimerInActiveList:0000007c $d
     /tmp/ccRYimFo.s:779    .text.prvProcessReceivedCommands:00000000 $t
     /tmp/ccRYimFo.s:830    .text.prvProcessReceivedCommands:00000034 $d
     /tmp/ccRYimFo.s:836    .text.prvProcessReceivedCommands:00000044 $t
     /tmp/ccRYimFo.s:939    .text.prvProcessReceivedCommands:000000ec $d
     /tmp/ccRYimFo.s:944    .text.prvSwitchTimerLists:00000000 $t
     /tmp/ccRYimFo.s:1070   .text.prvSwitchTimerLists:000000ac $d
     /tmp/ccRYimFo.s:1076   .text.prvCheckForValidListAndQueue:00000000 $t
     /tmp/ccRYimFo.s:1131   .text.prvCheckForValidListAndQueue:00000040 $d
     /tmp/ccRYimFo.s:1140   .text.xTimerIsTimerActive:00000000 $t
     /tmp/ccRYimFo.s:1145   .text.xTimerIsTimerActive:00000000 xTimerIsTimerActive
     /tmp/ccRYimFo.s:1191   .text.pvTimerGetTimerID:00000000 $t
     /tmp/ccRYimFo.s:1196   .text.pvTimerGetTimerID:00000000 pvTimerGetTimerID
     /tmp/ccRYimFo.s:1231   .bss.xLastTime.8302:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericCreate
ulPortSetInterruptMask
pvPortMalloc
vListInitialiseItem
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
uxListRemove
vTaskSuspendAll
xTaskResumeAll
vQueueWaitForMessageRestricted
vPortYield
xTaskGetTickCount
vListInsert
vPortFree
xQueueGenericReceive
vPortEnterCritical
vListInitialise
xQueueGenericCreate
vPortExitCritical
