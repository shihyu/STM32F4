   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	100
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  81              		.align	2
  84              	uxCurrentNumberOfTasks:
  85 0000 00000000 		.space	4
  86              		.section	.bss.xTickCount,"aw",%nobits
  87              		.align	2
  90              	xTickCount:
  91 0000 00000000 		.space	4
  92              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  93              		.align	2
  96              	uxTopReadyPriority:
  97 0000 00000000 		.space	4
  98              		.section	.bss.xSchedulerRunning,"aw",%nobits
  99              		.align	2
 102              	xSchedulerRunning:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 105              		.align	2
 108              	uxSchedulerSuspended:
 109 0000 00000000 		.space	4
 110              		.section	.bss.uxPendedTicks,"aw",%nobits
 111              		.align	2
 114              	uxPendedTicks:
 115 0000 00000000 		.space	4
 116              		.section	.bss.xYieldPending,"aw",%nobits
 117              		.align	2
 120              	xYieldPending:
 121 0000 00000000 		.space	4
 122              		.section	.bss.xNumOfOverflows,"aw",%nobits
 123              		.align	2
 126              	xNumOfOverflows:
 127 0000 00000000 		.space	4
 128              		.section	.bss.uxTaskNumber,"aw",%nobits
 129              		.align	2
 132              	uxTaskNumber:
 133 0000 00000000 		.space	4
 134              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 135              		.align	2
 138              	xNextTaskUnblockTime:
 139 0000 FFFFFFFF 		.word	-1
 140              		.section	.text.xTaskGenericCreate,"ax",%progbits
 141              		.align	2
 142              		.global	xTaskGenericCreate
 143              		.thumb
 144              		.thumb_func
 146              	xTaskGenericCreate:
 147              	.LFB110:
 148              		.file 1 "Source/tasks.c"
   1:Source/tasks.c **** /*
   2:Source/tasks.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/tasks.c ****     All rights reserved
   4:Source/tasks.c **** 
   5:Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/tasks.c **** 
   7:Source/tasks.c ****     ***************************************************************************
   8:Source/tasks.c ****      *                                                                       *
   9:Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:Source/tasks.c ****      *                                                                       *
  13:Source/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/tasks.c ****      *                                                                       *
  17:Source/tasks.c ****      *    Thank you!                                                         *
  18:Source/tasks.c ****      *                                                                       *
  19:Source/tasks.c ****     ***************************************************************************
  20:Source/tasks.c **** 
  21:Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:Source/tasks.c **** 
  23:Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/tasks.c **** 
  27:Source/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/tasks.c ****     >>! kernel.
  31:Source/tasks.c **** 
  32:Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:Source/tasks.c **** 
  37:Source/tasks.c ****     1 tab == 4 spaces!
  38:Source/tasks.c **** 
  39:Source/tasks.c ****     ***************************************************************************
  40:Source/tasks.c ****      *                                                                       *
  41:Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:Source/tasks.c ****      *                                                                       *
  44:Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/tasks.c ****      *                                                                       *
  46:Source/tasks.c ****     ***************************************************************************
  47:Source/tasks.c **** 
  48:Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/tasks.c **** 
  51:Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/tasks.c **** 
  55:Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/tasks.c **** 
  59:Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/tasks.c ****     mission critical applications that require provable dependability.
  62:Source/tasks.c **** 
  63:Source/tasks.c ****     1 tab == 4 spaces!
  64:Source/tasks.c **** */
  65:Source/tasks.c **** 
  66:Source/tasks.c **** /* Standard includes. */
  67:Source/tasks.c **** #include <stdlib.h>
  68:Source/tasks.c **** #include <string.h>
  69:Source/tasks.c **** 
  70:Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:Source/tasks.c **** task.h is included from an application file. */
  73:Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:Source/tasks.c **** 
  75:Source/tasks.c **** /* FreeRTOS includes. */
  76:Source/tasks.c **** #include "FreeRTOS.h"
  77:Source/tasks.c **** #include "task.h"
  78:Source/tasks.c **** #include "timers.h"
  79:Source/tasks.c **** #include "StackMacros.h"
  80:Source/tasks.c **** 
  81:Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  82:Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  83:Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  84:Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  85:Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  86:Source/tasks.c **** 
  87:Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  88:Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  89:Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  90:Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  91:Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  92:Source/tasks.c **** 	#include <stdio.h>
  93:Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  94:Source/tasks.c **** 
  95:Source/tasks.c **** /* Sanity check the configuration. */
  96:Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  97:Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  98:Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  99:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 100:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 101:Source/tasks.c **** 
 102:Source/tasks.c **** /*
 103:Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 104:Source/tasks.c ****  */
 105:Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 106:Source/tasks.c **** 
 107:Source/tasks.c **** /*
 108:Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 109:Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 110:Source/tasks.c ****  * (the task's run time environment, including register values)
 111:Source/tasks.c ****  */
 112:Source/tasks.c **** typedef struct tskTaskControlBlock
 113:Source/tasks.c **** {
 114:Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 115:Source/tasks.c **** 
 116:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 117:Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 118:Source/tasks.c **** 	#endif
 119:Source/tasks.c **** 
 120:Source/tasks.c **** 	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from d
 121:Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 122:Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 123:Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 124:Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 125:Source/tasks.c **** 
 126:Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 127:Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 128:Source/tasks.c **** 	#endif
 129:Source/tasks.c **** 
 130:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 131:Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 132:Source/tasks.c **** 	#endif
 133:Source/tasks.c **** 
 134:Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 135:Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 136:Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 137:Source/tasks.c **** 	#endif
 138:Source/tasks.c **** 
 139:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 140:Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 141:Source/tasks.c **** 	#endif
 142:Source/tasks.c **** 
 143:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 144:Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 145:Source/tasks.c **** 	#endif
 146:Source/tasks.c **** 
 147:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 148:Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 149:Source/tasks.c **** 	#endif
 150:Source/tasks.c **** 
 151:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 152:Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 153:Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 154:Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 155:Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 156:Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 157:Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 158:Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 159:Source/tasks.c **** 		struct _reent xNewLib_reent;
 160:Source/tasks.c **** 	#endif
 161:Source/tasks.c **** 
 162:Source/tasks.c **** } tskTCB;
 163:Source/tasks.c **** 
 164:Source/tasks.c **** 
 165:Source/tasks.c **** /*
 166:Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 167:Source/tasks.c ****  * be global, rather than file scope.
 168:Source/tasks.c ****  */
 169:Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 170:Source/tasks.c **** 	#define static
 171:Source/tasks.c **** #endif
 172:Source/tasks.c **** 
 173:Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 174:Source/tasks.c **** static variables must be declared volatile. */
 175:Source/tasks.c **** 
 176:Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 177:Source/tasks.c **** 
 178:Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 179:Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 180:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 181:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 182:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list c
 183:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 184:Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 185:Source/tasks.c **** 
 186:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 187:Source/tasks.c **** 
 188:Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 189:Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 190:Source/tasks.c **** 
 191:Source/tasks.c **** #endif
 192:Source/tasks.c **** 
 193:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 194:Source/tasks.c **** 
 195:Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 196:Source/tasks.c **** 
 197:Source/tasks.c **** #endif
 198:Source/tasks.c **** 
 199:Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 200:Source/tasks.c **** 
 201:Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 202:Source/tasks.c **** 
 203:Source/tasks.c **** #endif
 204:Source/tasks.c **** 
 205:Source/tasks.c **** /* Other file private variables. --------------------------------*/
 206:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 207:Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 208:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 209:Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 210:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 211:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE 
 212:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
 213:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 214:Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 215:Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
 216:Source/tasks.c **** 
 217:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 218:Source/tasks.c **** 
 219:Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 220:Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of executi
 221:Source/tasks.c **** 
 222:Source/tasks.c **** #endif
 223:Source/tasks.c **** 
 224:Source/tasks.c **** /*lint +e956 */
 225:Source/tasks.c **** 
 226:Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 227:Source/tasks.c **** 
 228:Source/tasks.c **** /*
 229:Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 230:Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 231:Source/tasks.c ****  */
 232:Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 233:Source/tasks.c **** 
 234:Source/tasks.c **** /*
 235:Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 236:Source/tasks.c ****  */
 237:Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 238:Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 239:Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 240:Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 241:Source/tasks.c **** 
 242:Source/tasks.c **** /*-----------------------------------------------------------*/
 243:Source/tasks.c **** 
 244:Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 245:Source/tasks.c **** 
 246:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 247:Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 248:Source/tasks.c **** 	microcontroller architecture. */
 249:Source/tasks.c **** 
 250:Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 251:Source/tasks.c **** 	state task. */
 252:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 253:Source/tasks.c **** 	{																													\
 254:Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 255:Source/tasks.c **** 		{																												\
 256:Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 257:Source/tasks.c **** 		}																												\
 258:Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 259:Source/tasks.c **** 
 260:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 261:Source/tasks.c **** 
 262:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 263:Source/tasks.c **** 	{																													\
 264:Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 265:Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 266:Source/tasks.c **** 		{																												\
 267:Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 268:Source/tasks.c **** 			--uxTopReadyPriority;																						\
 269:Source/tasks.c **** 		}																												\
 270:Source/tasks.c **** 																														\
 271:Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 272:Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 273:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 274:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 275:Source/tasks.c **** 
 276:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 277:Source/tasks.c **** 
 278:Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 279:Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 280:Source/tasks.c **** 	being used. */
 281:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 282:Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 283:Source/tasks.c **** 
 284:Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 285:Source/tasks.c **** 
 286:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 287:Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 288:Source/tasks.c **** 	architecture being used. */
 289:Source/tasks.c **** 
 290:Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 291:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 292:Source/tasks.c **** 
 293:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 294:Source/tasks.c **** 
 295:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 296:Source/tasks.c **** 	{																								\
 297:Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 298:Source/tasks.c **** 																									\
 299:Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 300:Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 301:Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 302:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 303:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 304:Source/tasks.c **** 
 305:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 306:Source/tasks.c **** 
 307:Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 308:Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 309:Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 310:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 311:Source/tasks.c **** 	{																								\
 312:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 313:Source/tasks.c **** 		{																							\
 314:Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 315:Source/tasks.c **** 		}																							\
 316:Source/tasks.c **** 	}
 317:Source/tasks.c **** 
 318:Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 319:Source/tasks.c **** 
 320:Source/tasks.c **** /*-----------------------------------------------------------*/
 321:Source/tasks.c **** 
 322:Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 323:Source/tasks.c **** count overflows. */
 324:Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 325:Source/tasks.c **** {																									\
 326:Source/tasks.c **** 	xList *pxTemp;																					\
 327:Source/tasks.c **** 																									\
 328:Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 329:Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 330:Source/tasks.c **** 																									\
 331:Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 332:Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 333:Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 334:Source/tasks.c **** 	xNumOfOverflows++;																				\
 335:Source/tasks.c **** 																									\
 336:Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
 337:Source/tasks.c **** 	{																								\
 338:Source/tasks.c **** 		/* The new current delayed list is empty.  Set												\
 339:Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is									\
 340:Source/tasks.c **** 		extremely unlikely that the																	\
 341:Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
 342:Source/tasks.c **** 		there is an item in the delayed list. */													\
 343:Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;														\
 344:Source/tasks.c **** 	}																								\
 345:Source/tasks.c **** 	else																							\
 346:Source/tasks.c **** 	{																								\
 347:Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of								\
 348:Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at								\
 349:Source/tasks.c **** 		which the task at the head of the delayed list should be removed							\
 350:Source/tasks.c **** 		from the Blocked state. */																	\
 351:Source/tasks.c **** 		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
 352:Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
 353:Source/tasks.c **** 	}																								\
 354:Source/tasks.c **** }
 355:Source/tasks.c **** 
 356:Source/tasks.c **** /*-----------------------------------------------------------*/
 357:Source/tasks.c **** 
 358:Source/tasks.c **** /*
 359:Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 360:Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 361:Source/tasks.c ****  */
 362:Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																				\
 363:Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 364:Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 365:Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 366:Source/tasks.c **** /*-----------------------------------------------------------*/
 367:Source/tasks.c **** 
 368:Source/tasks.c **** /*
 369:Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 370:Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 371:Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 372:Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 373:Source/tasks.c ****  */
 374:Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 375:Source/tasks.c **** 
 376:Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 377:Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
 378:Source/tasks.c **** extern void vApplicationTickHook( void );
 379:Source/tasks.c **** 
 380:Source/tasks.c **** /* File private functions. --------------------------------*/
 381:Source/tasks.c **** 
 382:Source/tasks.c **** /*
 383:Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 384:Source/tasks.c ****  * into the TCB structure.
 385:Source/tasks.c ****  */
 386:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 387:Source/tasks.c **** 
 388:Source/tasks.c **** /*
 389:Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 390:Source/tasks.c ****  * automatically upon the creation of the first task.
 391:Source/tasks.c ****  */
 392:Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 393:Source/tasks.c **** 
 394:Source/tasks.c **** /*
 395:Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 396:Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 397:Source/tasks.c ****  * creation of the first user task.
 398:Source/tasks.c ****  *
 399:Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 400:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 401:Source/tasks.c ****  *
 402:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 403:Source/tasks.c ****  *
 404:Source/tasks.c ****  */
 405:Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 406:Source/tasks.c **** 
 407:Source/tasks.c **** /*
 408:Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 409:Source/tasks.c ****  * including the stack pointed to by the TCB.
 410:Source/tasks.c ****  *
 411:Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 412:Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 413:Source/tasks.c ****  */
 414:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 415:Source/tasks.c **** 
 416:Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 417:Source/tasks.c **** 
 418:Source/tasks.c **** #endif
 419:Source/tasks.c **** 
 420:Source/tasks.c **** /*
 421:Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 422:Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 423:Source/tasks.c ****  * and its TCB deleted.
 424:Source/tasks.c ****  */
 425:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 426:Source/tasks.c **** 
 427:Source/tasks.c **** /*
 428:Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 429:Source/tasks.c ****  * either the current or the overflow delayed task list.
 430:Source/tasks.c ****  */
 431:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 432:Source/tasks.c **** 
 433:Source/tasks.c **** /*
 434:Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 435:Source/tasks.c ****  * allocation was successful.
 436:Source/tasks.c ****  */
 437:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 438:Source/tasks.c **** 
 439:Source/tasks.c **** /*
 440:Source/tasks.c ****  * Fills an xTaskStatusType structure with information on each task that is
 441:Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 442:Source/tasks.c ****  * a suspended list, etc.).
 443:Source/tasks.c ****  *
 444:Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 445:Source/tasks.c ****  * NORMAL APPLICATION CODE.
 446:Source/tasks.c ****  */
 447:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 448:Source/tasks.c **** 
 449:Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
 450:Source/tasks.c **** 
 451:Source/tasks.c **** #endif
 452:Source/tasks.c **** 
 453:Source/tasks.c **** /*
 454:Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 455:Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 456:Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 457:Source/tasks.c ****  */
 458:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 459:Source/tasks.c **** 
 460:Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_
 461:Source/tasks.c **** 
 462:Source/tasks.c **** #endif
 463:Source/tasks.c **** 
 464:Source/tasks.c **** /*
 465:Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 466:Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 467:Source/tasks.c ****  *
 468:Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 469:Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 470:Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 471:Source/tasks.c ****  * set to a value other than 1.
 472:Source/tasks.c ****  */
 473:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 474:Source/tasks.c **** 
 475:Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 476:Source/tasks.c **** 
 477:Source/tasks.c **** #endif
 478:Source/tasks.c **** 
 479:Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 480:Source/tasks.c **** {
 149              		.loc 1 480 0
 150              		.cfi_startproc
 151              		@ args = 16, pretend = 0, frame = 32
 152              		@ frame_needed = 1, uses_anonymous_args = 0
 153 0000 80B5     		push	{r7, lr}
 154              	.LCFI0:
 155              		.cfi_def_cfa_offset 8
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8AB0     		sub	sp, sp, #40
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 48
 161 0004 02AF     		add	r7, sp, #8
 162              	.LCFI2:
 163              		.cfi_def_cfa 7, 40
 164 0006 F860     		str	r0, [r7, #12]
 165 0008 B960     		str	r1, [r7, #8]
 166 000a 3B60     		str	r3, [r7]
 167 000c 1346     		mov	r3, r2	@ movhi
 168 000e FB80     		strh	r3, [r7, #6]	@ movhi
 481:Source/tasks.c **** signed portBASE_TYPE xReturn;
 482:Source/tasks.c **** tskTCB * pxNewTCB;
 483:Source/tasks.c **** 
 484:Source/tasks.c **** 	configASSERT( pxTaskCode );
 169              		.loc 1 484 0
 170 0010 FB68     		ldr	r3, [r7, #12]
 171 0012 002B     		cmp	r3, #0
 172 0014 02D1     		bne	.L2
 173              		.loc 1 484 0 is_stmt 0 discriminator 1
 174 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 175              	.L3:
 176 001a FEE7     		b	.L3
 177              	.L2:
 485:Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 178              		.loc 1 485 0 is_stmt 1
 179 001c BB6A     		ldr	r3, [r7, #40]
 180 001e 042B     		cmp	r3, #4
 181 0020 02D9     		bls	.L4
 182              		.loc 1 485 0 is_stmt 0 discriminator 1
 183 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 184              	.L5:
 185 0026 FEE7     		b	.L5
 186              	.L4:
 486:Source/tasks.c **** 
 487:Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 488:Source/tasks.c **** 	checking that the allocation was successful. */
 489:Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 187              		.loc 1 489 0 is_stmt 1
 188 0028 FB88     		ldrh	r3, [r7, #6]
 189 002a 1846     		mov	r0, r3
 190 002c 396B     		ldr	r1, [r7, #48]
 191 002e FFF7FEFF 		bl	prvAllocateTCBAndStack
 192 0032 B861     		str	r0, [r7, #24]
 490:Source/tasks.c **** 
 491:Source/tasks.c **** 	if( pxNewTCB != NULL )
 193              		.loc 1 491 0
 194 0034 BB69     		ldr	r3, [r7, #24]
 195 0036 002B     		cmp	r3, #0
 196 0038 72D0     		beq	.L6
 197              	.LBB2:
 492:Source/tasks.c **** 	{
 493:Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 494:Source/tasks.c **** 
 495:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 496:Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 497:Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 498:Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 499:Source/tasks.c **** 			{
 500:Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 501:Source/tasks.c **** 			}
 502:Source/tasks.c **** 			else
 503:Source/tasks.c **** 			{
 504:Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 505:Source/tasks.c **** 			}
 506:Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 507:Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 508:Source/tasks.c **** 
 509:Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 510:Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 511:Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 512:Source/tasks.c **** 		required by the port. */
 513:Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 514:Source/tasks.c **** 		{
 515:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 198              		.loc 1 515 0
 199 003a BB69     		ldr	r3, [r7, #24]
 200 003c 1A6B     		ldr	r2, [r3, #48]
 201 003e FB88     		ldrh	r3, [r7, #6]
 202 0040 03F18043 		add	r3, r3, #1073741824
 203 0044 013B     		subs	r3, r3, #1
 204 0046 9B00     		lsls	r3, r3, #2
 205 0048 1344     		add	r3, r3, r2
 206 004a 7B61     		str	r3, [r7, #20]
 516:Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 207              		.loc 1 516 0
 208 004c 7B69     		ldr	r3, [r7, #20]
 209 004e 23F00703 		bic	r3, r3, #7
 210 0052 7B61     		str	r3, [r7, #20]
 517:Source/tasks.c **** 
 518:Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 519:Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 211              		.loc 1 519 0
 212 0054 7B69     		ldr	r3, [r7, #20]
 213 0056 03F00703 		and	r3, r3, #7
 214 005a 002B     		cmp	r3, #0
 215 005c 02D0     		beq	.L7
 216              		.loc 1 519 0 is_stmt 0 discriminator 1
 217 005e FFF7FEFF 		bl	ulPortSetInterruptMask
 218              	.L8:
 219 0062 FEE7     		b	.L8
 220              	.L7:
 520:Source/tasks.c **** 		}
 521:Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 522:Source/tasks.c **** 		{
 523:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 524:Source/tasks.c **** 
 525:Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 526:Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 527:Source/tasks.c **** 
 528:Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 529:Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 530:Source/tasks.c **** 			other extreme of the stack space. */
 531:Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 532:Source/tasks.c **** 		}
 533:Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 534:Source/tasks.c **** 
 535:Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 536:Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 221              		.loc 1 536 0 is_stmt 1
 222 0064 FB88     		ldrh	r3, [r7, #6]
 223 0066 0093     		str	r3, [sp]
 224 0068 B869     		ldr	r0, [r7, #24]
 225 006a B968     		ldr	r1, [r7, #8]
 226 006c BA6A     		ldr	r2, [r7, #40]
 227 006e 7B6B     		ldr	r3, [r7, #52]
 228 0070 FFF7FEFF 		bl	prvInitialiseTCBVariables
 537:Source/tasks.c **** 
 538:Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 539:Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 540:Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 541:Source/tasks.c **** 		the	top of stack variable is updated. */
 542:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 543:Source/tasks.c **** 		{
 544:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 545:Source/tasks.c **** 		}
 546:Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 547:Source/tasks.c **** 		{
 548:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 229              		.loc 1 548 0
 230 0074 7869     		ldr	r0, [r7, #20]
 231 0076 F968     		ldr	r1, [r7, #12]
 232 0078 3A68     		ldr	r2, [r7]
 233 007a FFF7FEFF 		bl	pxPortInitialiseStack
 234 007e 0246     		mov	r2, r0
 235 0080 BB69     		ldr	r3, [r7, #24]
 236 0082 1A60     		str	r2, [r3]
 549:Source/tasks.c **** 		}
 550:Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 551:Source/tasks.c **** 
 552:Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 237              		.loc 1 552 0
 238 0084 FB6A     		ldr	r3, [r7, #44]
 239 0086 002B     		cmp	r3, #0
 240 0088 02D0     		beq	.L9
 553:Source/tasks.c **** 		{
 554:Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 555:Source/tasks.c **** 			task can use this as a handle to delete the task later if
 556:Source/tasks.c **** 			required.*/
 557:Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 241              		.loc 1 557 0
 242 008a FB6A     		ldr	r3, [r7, #44]
 243 008c BA69     		ldr	r2, [r7, #24]
 244 008e 1A60     		str	r2, [r3]
 245              	.L9:
 558:Source/tasks.c **** 		}
 559:Source/tasks.c **** 
 560:Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 561:Source/tasks.c **** 		updated. */
 562:Source/tasks.c **** 		taskENTER_CRITICAL();
 246              		.loc 1 562 0
 247 0090 FFF7FEFF 		bl	vPortEnterCritical
 563:Source/tasks.c **** 		{
 564:Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 248              		.loc 1 564 0
 249 0094 2E4B     		ldr	r3, .L17
 250 0096 1B68     		ldr	r3, [r3]
 251 0098 5A1C     		adds	r2, r3, #1
 252 009a 2D4B     		ldr	r3, .L17
 253 009c 1A60     		str	r2, [r3]
 565:Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 254              		.loc 1 565 0
 255 009e 2D4B     		ldr	r3, .L17+4
 256 00a0 1B68     		ldr	r3, [r3]
 257 00a2 002B     		cmp	r3, #0
 258 00a4 09D1     		bne	.L10
 566:Source/tasks.c **** 			{
 567:Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 568:Source/tasks.c **** 				the suspended state - make this the current task. */
 569:Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 259              		.loc 1 569 0
 260 00a6 2B4B     		ldr	r3, .L17+4
 261 00a8 BA69     		ldr	r2, [r7, #24]
 262 00aa 1A60     		str	r2, [r3]
 570:Source/tasks.c **** 
 571:Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 263              		.loc 1 571 0
 264 00ac 284B     		ldr	r3, .L17
 265 00ae 1B68     		ldr	r3, [r3]
 266 00b0 012B     		cmp	r3, #1
 267 00b2 0FD1     		bne	.L12
 572:Source/tasks.c **** 				{
 573:Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 574:Source/tasks.c **** 					initialisation required.  We will not recover if this call
 575:Source/tasks.c **** 					fails, but we will report the failure. */
 576:Source/tasks.c **** 					prvInitialiseTaskLists();
 268              		.loc 1 576 0
 269 00b4 FFF7FEFF 		bl	prvInitialiseTaskLists
 270 00b8 0CE0     		b	.L12
 271              	.L10:
 577:Source/tasks.c **** 				}
 578:Source/tasks.c **** 			}
 579:Source/tasks.c **** 			else
 580:Source/tasks.c **** 			{
 581:Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 582:Source/tasks.c **** 				current task if it is the highest priority task to be created
 583:Source/tasks.c **** 				so far. */
 584:Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 272              		.loc 1 584 0
 273 00ba 274B     		ldr	r3, .L17+8
 274 00bc 1B68     		ldr	r3, [r3]
 275 00be 002B     		cmp	r3, #0
 276 00c0 08D1     		bne	.L12
 585:Source/tasks.c **** 				{
 586:Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 277              		.loc 1 586 0
 278 00c2 244B     		ldr	r3, .L17+4
 279 00c4 1B68     		ldr	r3, [r3]
 280 00c6 DA6A     		ldr	r2, [r3, #44]
 281 00c8 BB6A     		ldr	r3, [r7, #40]
 282 00ca 9A42     		cmp	r2, r3
 283 00cc 02D8     		bhi	.L12
 587:Source/tasks.c **** 					{
 588:Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 284              		.loc 1 588 0
 285 00ce 214B     		ldr	r3, .L17+4
 286 00d0 BA69     		ldr	r2, [r7, #24]
 287 00d2 1A60     		str	r2, [r3]
 288              	.L12:
 589:Source/tasks.c **** 					}
 590:Source/tasks.c **** 				}
 591:Source/tasks.c **** 			}
 592:Source/tasks.c **** 
 593:Source/tasks.c **** 			uxTaskNumber++;
 289              		.loc 1 593 0
 290 00d4 214B     		ldr	r3, .L17+12
 291 00d6 1B68     		ldr	r3, [r3]
 292 00d8 5A1C     		adds	r2, r3, #1
 293 00da 204B     		ldr	r3, .L17+12
 294 00dc 1A60     		str	r2, [r3]
 594:Source/tasks.c **** 
 595:Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 596:Source/tasks.c **** 			{
 597:Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 598:Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 295              		.loc 1 598 0
 296 00de 1F4B     		ldr	r3, .L17+12
 297 00e0 1A68     		ldr	r2, [r3]
 298 00e2 BB69     		ldr	r3, [r7, #24]
 299 00e4 1A64     		str	r2, [r3, #64]
 599:Source/tasks.c **** 			}
 600:Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 601:Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 602:Source/tasks.c **** 
 603:Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 300              		.loc 1 603 0
 301 00e6 BB69     		ldr	r3, [r7, #24]
 302 00e8 DA6A     		ldr	r2, [r3, #44]
 303 00ea 1D4B     		ldr	r3, .L17+16
 304 00ec 1B68     		ldr	r3, [r3]
 305 00ee 9A42     		cmp	r2, r3
 306 00f0 03D9     		bls	.L13
 307              		.loc 1 603 0 is_stmt 0 discriminator 1
 308 00f2 BB69     		ldr	r3, [r7, #24]
 309 00f4 DA6A     		ldr	r2, [r3, #44]
 310 00f6 1A4B     		ldr	r3, .L17+16
 311 00f8 1A60     		str	r2, [r3]
 312              	.L13:
 313              		.loc 1 603 0 discriminator 2
 314 00fa BB69     		ldr	r3, [r7, #24]
 315 00fc DA6A     		ldr	r2, [r3, #44]
 316 00fe 1346     		mov	r3, r2
 317 0100 9B00     		lsls	r3, r3, #2
 318 0102 1344     		add	r3, r3, r2
 319 0104 9B00     		lsls	r3, r3, #2
 320 0106 174A     		ldr	r2, .L17+20
 321 0108 1A44     		add	r2, r2, r3
 322 010a BB69     		ldr	r3, [r7, #24]
 323 010c 0433     		adds	r3, r3, #4
 324 010e 1046     		mov	r0, r2
 325 0110 1946     		mov	r1, r3
 326 0112 FFF7FEFF 		bl	vListInsertEnd
 604:Source/tasks.c **** 
 605:Source/tasks.c **** 			xReturn = pdPASS;
 327              		.loc 1 605 0 is_stmt 1 discriminator 2
 328 0116 0123     		movs	r3, #1
 329 0118 FB61     		str	r3, [r7, #28]
 606:Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 607:Source/tasks.c **** 		}
 608:Source/tasks.c **** 		taskEXIT_CRITICAL();
 330              		.loc 1 608 0 discriminator 2
 331 011a FFF7FEFF 		bl	vPortExitCritical
 332              	.LBE2:
 333 011e 02E0     		b	.L14
 334              	.L6:
 609:Source/tasks.c **** 	}
 610:Source/tasks.c **** 	else
 611:Source/tasks.c **** 	{
 612:Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 335              		.loc 1 612 0
 336 0120 4FF0FF33 		mov	r3, #-1
 337 0124 FB61     		str	r3, [r7, #28]
 338              	.L14:
 613:Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 614:Source/tasks.c **** 	}
 615:Source/tasks.c **** 
 616:Source/tasks.c **** 	if( xReturn == pdPASS )
 339              		.loc 1 616 0
 340 0126 FB69     		ldr	r3, [r7, #28]
 341 0128 012B     		cmp	r3, #1
 342 012a 0BD1     		bne	.L15
 617:Source/tasks.c **** 	{
 618:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 343              		.loc 1 618 0
 344 012c 0A4B     		ldr	r3, .L17+8
 345 012e 1B68     		ldr	r3, [r3]
 346 0130 002B     		cmp	r3, #0
 347 0132 07D0     		beq	.L15
 619:Source/tasks.c **** 		{
 620:Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 621:Source/tasks.c **** 			then it should run now. */
 622:Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 348              		.loc 1 622 0
 349 0134 074B     		ldr	r3, .L17+4
 350 0136 1B68     		ldr	r3, [r3]
 351 0138 DA6A     		ldr	r2, [r3, #44]
 352 013a BB6A     		ldr	r3, [r7, #40]
 353 013c 9A42     		cmp	r2, r3
 354 013e 01D2     		bcs	.L15
 623:Source/tasks.c **** 			{
 624:Source/tasks.c **** 				portYIELD_WITHIN_API();
 355              		.loc 1 624 0
 356 0140 FFF7FEFF 		bl	vPortYield
 357              	.L15:
 625:Source/tasks.c **** 			}
 626:Source/tasks.c **** 		}
 627:Source/tasks.c **** 	}
 628:Source/tasks.c **** 
 629:Source/tasks.c **** 	return xReturn;
 358              		.loc 1 629 0
 359 0144 FB69     		ldr	r3, [r7, #28]
 630:Source/tasks.c **** }
 360              		.loc 1 630 0
 361 0146 1846     		mov	r0, r3
 362 0148 2037     		adds	r7, r7, #32
 363 014a BD46     		mov	sp, r7
 364              		@ sp needed
 365 014c 80BD     		pop	{r7, pc}
 366              	.L18:
 367 014e 00BF     		.align	2
 368              	.L17:
 369 0150 00000000 		.word	uxCurrentNumberOfTasks
 370 0154 00000000 		.word	pxCurrentTCB
 371 0158 00000000 		.word	xSchedulerRunning
 372 015c 00000000 		.word	uxTaskNumber
 373 0160 00000000 		.word	uxTopReadyPriority
 374 0164 00000000 		.word	pxReadyTasksLists
 375              		.cfi_endproc
 376              	.LFE110:
 378              		.section	.text.vTaskDelete,"ax",%progbits
 379              		.align	2
 380              		.global	vTaskDelete
 381              		.thumb
 382              		.thumb_func
 384              	vTaskDelete:
 385              	.LFB111:
 631:Source/tasks.c **** /*-----------------------------------------------------------*/
 632:Source/tasks.c **** 
 633:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 634:Source/tasks.c **** 
 635:Source/tasks.c **** 	void vTaskDelete( xTaskHandle xTaskToDelete )
 636:Source/tasks.c **** 	{
 386              		.loc 1 636 0
 387              		.cfi_startproc
 388              		@ args = 0, pretend = 0, frame = 16
 389              		@ frame_needed = 1, uses_anonymous_args = 0
 390 0000 80B5     		push	{r7, lr}
 391              	.LCFI3:
 392              		.cfi_def_cfa_offset 8
 393              		.cfi_offset 7, -8
 394              		.cfi_offset 14, -4
 395 0002 84B0     		sub	sp, sp, #16
 396              	.LCFI4:
 397              		.cfi_def_cfa_offset 24
 398 0004 00AF     		add	r7, sp, #0
 399              	.LCFI5:
 400              		.cfi_def_cfa_register 7
 401 0006 7860     		str	r0, [r7, #4]
 637:Source/tasks.c **** 	tskTCB *pxTCB;
 638:Source/tasks.c **** 
 639:Source/tasks.c **** 		taskENTER_CRITICAL();
 402              		.loc 1 639 0
 403 0008 FFF7FEFF 		bl	vPortEnterCritical
 640:Source/tasks.c **** 		{
 641:Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 642:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 404              		.loc 1 642 0
 405 000c 7B68     		ldr	r3, [r7, #4]
 406 000e 002B     		cmp	r3, #0
 407 0010 02D1     		bne	.L20
 408              		.loc 1 642 0 is_stmt 0 discriminator 1
 409 0012 194B     		ldr	r3, .L24
 410 0014 1B68     		ldr	r3, [r3]
 411 0016 00E0     		b	.L21
 412              	.L20:
 413              		.loc 1 642 0 discriminator 2
 414 0018 7B68     		ldr	r3, [r7, #4]
 415              	.L21:
 416              		.loc 1 642 0 discriminator 3
 417 001a FB60     		str	r3, [r7, #12]
 643:Source/tasks.c **** 
 644:Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 645:Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 646:Source/tasks.c **** 			the termination list and free up any memory allocated by the
 647:Source/tasks.c **** 			scheduler for the TCB and stack. */
 648:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 418              		.loc 1 648 0 is_stmt 1 discriminator 3
 419 001c FB68     		ldr	r3, [r7, #12]
 420 001e 0433     		adds	r3, r3, #4
 421 0020 1846     		mov	r0, r3
 422 0022 FFF7FEFF 		bl	uxListRemove
 649:Source/tasks.c **** 			{
 650:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 651:Source/tasks.c **** 			}
 652:Source/tasks.c **** 
 653:Source/tasks.c **** 			/* Is the task waiting on an event also? */
 654:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 423              		.loc 1 654 0 discriminator 3
 424 0026 FB68     		ldr	r3, [r7, #12]
 425 0028 9B6A     		ldr	r3, [r3, #40]
 426 002a 002B     		cmp	r3, #0
 427 002c 04D0     		beq	.L22
 655:Source/tasks.c **** 			{
 656:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 428              		.loc 1 656 0
 429 002e FB68     		ldr	r3, [r7, #12]
 430 0030 1833     		adds	r3, r3, #24
 431 0032 1846     		mov	r0, r3
 432 0034 FFF7FEFF 		bl	uxListRemove
 433              	.L22:
 657:Source/tasks.c **** 			}
 658:Source/tasks.c **** 
 659:Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 434              		.loc 1 659 0
 435 0038 FB68     		ldr	r3, [r7, #12]
 436 003a 0433     		adds	r3, r3, #4
 437 003c 0F48     		ldr	r0, .L24+4
 438 003e 1946     		mov	r1, r3
 439 0040 FFF7FEFF 		bl	vListInsertEnd
 660:Source/tasks.c **** 
 661:Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 662:Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 663:Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 664:Source/tasks.c **** 			++uxTasksDeleted;
 440              		.loc 1 664 0
 441 0044 0E4B     		ldr	r3, .L24+8
 442 0046 1B68     		ldr	r3, [r3]
 443 0048 5A1C     		adds	r2, r3, #1
 444 004a 0D4B     		ldr	r3, .L24+8
 445 004c 1A60     		str	r2, [r3]
 665:Source/tasks.c **** 
 666:Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 667:Source/tasks.c **** 			can detect that the task lists need re-generating. */
 668:Source/tasks.c **** 			uxTaskNumber++;
 446              		.loc 1 668 0
 447 004e 0D4B     		ldr	r3, .L24+12
 448 0050 1B68     		ldr	r3, [r3]
 449 0052 5A1C     		adds	r2, r3, #1
 450 0054 0B4B     		ldr	r3, .L24+12
 451 0056 1A60     		str	r2, [r3]
 669:Source/tasks.c **** 
 670:Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 671:Source/tasks.c **** 		}
 672:Source/tasks.c **** 		taskEXIT_CRITICAL();
 452              		.loc 1 672 0
 453 0058 FFF7FEFF 		bl	vPortExitCritical
 673:Source/tasks.c **** 
 674:Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 675:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 454              		.loc 1 675 0
 455 005c 0A4B     		ldr	r3, .L24+16
 456 005e 1B68     		ldr	r3, [r3]
 457 0060 002B     		cmp	r3, #0
 458 0062 06D0     		beq	.L19
 676:Source/tasks.c **** 		{
 677:Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 459              		.loc 1 677 0
 460 0064 044B     		ldr	r3, .L24
 461 0066 1B68     		ldr	r3, [r3]
 462 0068 FA68     		ldr	r2, [r7, #12]
 463 006a 9A42     		cmp	r2, r3
 464 006c 01D1     		bne	.L19
 678:Source/tasks.c **** 			{
 679:Source/tasks.c **** 				portYIELD_WITHIN_API();
 465              		.loc 1 679 0
 466 006e FFF7FEFF 		bl	vPortYield
 467              	.L19:
 680:Source/tasks.c **** 			}
 681:Source/tasks.c **** 		}
 682:Source/tasks.c **** 	}
 468              		.loc 1 682 0
 469 0072 1037     		adds	r7, r7, #16
 470 0074 BD46     		mov	sp, r7
 471              		@ sp needed
 472 0076 80BD     		pop	{r7, pc}
 473              	.L25:
 474              		.align	2
 475              	.L24:
 476 0078 00000000 		.word	pxCurrentTCB
 477 007c 00000000 		.word	xTasksWaitingTermination
 478 0080 00000000 		.word	uxTasksDeleted
 479 0084 00000000 		.word	uxTaskNumber
 480 0088 00000000 		.word	xSchedulerRunning
 481              		.cfi_endproc
 482              	.LFE111:
 484              		.section	.text.vTaskDelayUntil,"ax",%progbits
 485              		.align	2
 486              		.global	vTaskDelayUntil
 487              		.thumb
 488              		.thumb_func
 490              	vTaskDelayUntil:
 491              	.LFB112:
 683:Source/tasks.c **** 
 684:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 685:Source/tasks.c **** /*-----------------------------------------------------------*/
 686:Source/tasks.c **** 
 687:Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 688:Source/tasks.c **** 
 689:Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 690:Source/tasks.c **** 	{
 492              		.loc 1 690 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 24
 495              		@ frame_needed = 1, uses_anonymous_args = 0
 496 0000 80B5     		push	{r7, lr}
 497              	.LCFI6:
 498              		.cfi_def_cfa_offset 8
 499              		.cfi_offset 7, -8
 500              		.cfi_offset 14, -4
 501 0002 86B0     		sub	sp, sp, #24
 502              	.LCFI7:
 503              		.cfi_def_cfa_offset 32
 504 0004 00AF     		add	r7, sp, #0
 505              	.LCFI8:
 506              		.cfi_def_cfa_register 7
 507 0006 7860     		str	r0, [r7, #4]
 508 0008 3960     		str	r1, [r7]
 691:Source/tasks.c **** 	portTickType xTimeToWake;
 692:Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 509              		.loc 1 692 0
 510 000a 0023     		movs	r3, #0
 511 000c 7B61     		str	r3, [r7, #20]
 693:Source/tasks.c **** 
 694:Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 512              		.loc 1 694 0
 513 000e 7B68     		ldr	r3, [r7, #4]
 514 0010 002B     		cmp	r3, #0
 515 0012 02D1     		bne	.L27
 516              		.loc 1 694 0 is_stmt 0 discriminator 1
 517 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 518              	.L28:
 519 0018 FEE7     		b	.L28
 520              	.L27:
 695:Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 521              		.loc 1 695 0 is_stmt 1
 522 001a 3B68     		ldr	r3, [r7]
 523 001c 002B     		cmp	r3, #0
 524 001e 02D1     		bne	.L29
 525              		.loc 1 695 0 is_stmt 0 discriminator 1
 526 0020 FFF7FEFF 		bl	ulPortSetInterruptMask
 527              	.L30:
 528 0024 FEE7     		b	.L30
 529              	.L29:
 696:Source/tasks.c **** 
 697:Source/tasks.c **** 		vTaskSuspendAll();
 530              		.loc 1 697 0 is_stmt 1
 531 0026 FFF7FEFF 		bl	vTaskSuspendAll
 532              	.LBB3:
 698:Source/tasks.c **** 		{
 699:Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 700:Source/tasks.c **** 			block. */
 701:Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 533              		.loc 1 701 0
 534 002a 1F4B     		ldr	r3, .L37
 535 002c 1B68     		ldr	r3, [r3]
 536 002e 3B61     		str	r3, [r7, #16]
 702:Source/tasks.c **** 
 703:Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 704:Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 537              		.loc 1 704 0
 538 0030 7B68     		ldr	r3, [r7, #4]
 539 0032 1A68     		ldr	r2, [r3]
 540 0034 3B68     		ldr	r3, [r7]
 541 0036 1344     		add	r3, r3, r2
 542 0038 FB60     		str	r3, [r7, #12]
 705:Source/tasks.c **** 
 706:Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 543              		.loc 1 706 0
 544 003a 7B68     		ldr	r3, [r7, #4]
 545 003c 1A68     		ldr	r2, [r3]
 546 003e 3B69     		ldr	r3, [r7, #16]
 547 0040 9A42     		cmp	r2, r3
 548 0042 0BD9     		bls	.L31
 707:Source/tasks.c **** 			{
 708:Source/tasks.c **** 				/* The tick count has overflowed since this function was
 709:Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 710:Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 711:Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 712:Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 713:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 549              		.loc 1 713 0
 550 0044 7B68     		ldr	r3, [r7, #4]
 551 0046 1A68     		ldr	r2, [r3]
 552 0048 FB68     		ldr	r3, [r7, #12]
 553 004a 9A42     		cmp	r2, r3
 554 004c 11D9     		bls	.L33
 555              		.loc 1 713 0 is_stmt 0 discriminator 1
 556 004e FA68     		ldr	r2, [r7, #12]
 557 0050 3B69     		ldr	r3, [r7, #16]
 558 0052 9A42     		cmp	r2, r3
 559 0054 0DD9     		bls	.L33
 714:Source/tasks.c **** 				{
 715:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 560              		.loc 1 715 0 is_stmt 1
 561 0056 0123     		movs	r3, #1
 562 0058 7B61     		str	r3, [r7, #20]
 563 005a 0AE0     		b	.L33
 564              	.L31:
 716:Source/tasks.c **** 				}
 717:Source/tasks.c **** 			}
 718:Source/tasks.c **** 			else
 719:Source/tasks.c **** 			{
 720:Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 721:Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 722:Source/tasks.c **** 				tick time is less than the wake time. */
 723:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 565              		.loc 1 723 0
 566 005c 7B68     		ldr	r3, [r7, #4]
 567 005e 1A68     		ldr	r2, [r3]
 568 0060 FB68     		ldr	r3, [r7, #12]
 569 0062 9A42     		cmp	r2, r3
 570 0064 03D8     		bhi	.L34
 571              		.loc 1 723 0 is_stmt 0 discriminator 1
 572 0066 FA68     		ldr	r2, [r7, #12]
 573 0068 3B69     		ldr	r3, [r7, #16]
 574 006a 9A42     		cmp	r2, r3
 575 006c 01D9     		bls	.L33
 576              	.L34:
 724:Source/tasks.c **** 				{
 725:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 577              		.loc 1 725 0 is_stmt 1
 578 006e 0123     		movs	r3, #1
 579 0070 7B61     		str	r3, [r7, #20]
 580              	.L33:
 726:Source/tasks.c **** 				}
 727:Source/tasks.c **** 			}
 728:Source/tasks.c **** 
 729:Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 730:Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 581              		.loc 1 730 0
 582 0072 7B68     		ldr	r3, [r7, #4]
 583 0074 FA68     		ldr	r2, [r7, #12]
 584 0076 1A60     		str	r2, [r3]
 731:Source/tasks.c **** 
 732:Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 585              		.loc 1 732 0
 586 0078 7B69     		ldr	r3, [r7, #20]
 587 007a 002B     		cmp	r3, #0
 588 007c 08D0     		beq	.L35
 733:Source/tasks.c **** 			{
 734:Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 735:Source/tasks.c **** 
 736:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 737:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 738:Source/tasks.c **** 				both lists. */
 739:Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 589              		.loc 1 739 0
 590 007e 0B4B     		ldr	r3, .L37+4
 591 0080 1B68     		ldr	r3, [r3]
 592 0082 0433     		adds	r3, r3, #4
 593 0084 1846     		mov	r0, r3
 594 0086 FFF7FEFF 		bl	uxListRemove
 740:Source/tasks.c **** 				{
 741:Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 742:Source/tasks.c **** 					no need to check, and the port reset macro can be called
 743:Source/tasks.c **** 					directly. */
 744:Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 745:Source/tasks.c **** 				}
 746:Source/tasks.c **** 
 747:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 595              		.loc 1 747 0
 596 008a F868     		ldr	r0, [r7, #12]
 597 008c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 598              	.L35:
 599              	.LBE3:
 748:Source/tasks.c **** 			}
 749:Source/tasks.c **** 		}
 750:Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 600              		.loc 1 750 0
 601 0090 FFF7FEFF 		bl	xTaskResumeAll
 602 0094 B860     		str	r0, [r7, #8]
 751:Source/tasks.c **** 
 752:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 753:Source/tasks.c **** 		have put ourselves to sleep. */
 754:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 603              		.loc 1 754 0
 604 0096 BB68     		ldr	r3, [r7, #8]
 605 0098 002B     		cmp	r3, #0
 606 009a 01D1     		bne	.L26
 755:Source/tasks.c **** 		{
 756:Source/tasks.c **** 			portYIELD_WITHIN_API();
 607              		.loc 1 756 0
 608 009c FFF7FEFF 		bl	vPortYield
 609              	.L26:
 757:Source/tasks.c **** 		}
 758:Source/tasks.c **** 	}
 610              		.loc 1 758 0
 611 00a0 1837     		adds	r7, r7, #24
 612 00a2 BD46     		mov	sp, r7
 613              		@ sp needed
 614 00a4 80BD     		pop	{r7, pc}
 615              	.L38:
 616 00a6 00BF     		.align	2
 617              	.L37:
 618 00a8 00000000 		.word	xTickCount
 619 00ac 00000000 		.word	pxCurrentTCB
 620              		.cfi_endproc
 621              	.LFE112:
 623              		.section	.text.vTaskDelay,"ax",%progbits
 624              		.align	2
 625              		.global	vTaskDelay
 626              		.thumb
 627              		.thumb_func
 629              	vTaskDelay:
 630              	.LFB113:
 759:Source/tasks.c **** 
 760:Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 761:Source/tasks.c **** /*-----------------------------------------------------------*/
 762:Source/tasks.c **** 
 763:Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 764:Source/tasks.c **** 
 765:Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 766:Source/tasks.c **** 	{
 631              		.loc 1 766 0
 632              		.cfi_startproc
 633              		@ args = 0, pretend = 0, frame = 16
 634              		@ frame_needed = 1, uses_anonymous_args = 0
 635 0000 80B5     		push	{r7, lr}
 636              	.LCFI9:
 637              		.cfi_def_cfa_offset 8
 638              		.cfi_offset 7, -8
 639              		.cfi_offset 14, -4
 640 0002 84B0     		sub	sp, sp, #16
 641              	.LCFI10:
 642              		.cfi_def_cfa_offset 24
 643 0004 00AF     		add	r7, sp, #0
 644              	.LCFI11:
 645              		.cfi_def_cfa_register 7
 646 0006 7860     		str	r0, [r7, #4]
 767:Source/tasks.c **** 	portTickType xTimeToWake;
 768:Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 647              		.loc 1 768 0
 648 0008 0023     		movs	r3, #0
 649 000a FB60     		str	r3, [r7, #12]
 769:Source/tasks.c **** 
 770:Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 771:Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 650              		.loc 1 771 0
 651 000c 7B68     		ldr	r3, [r7, #4]
 652 000e 002B     		cmp	r3, #0
 653 0010 12D0     		beq	.L40
 772:Source/tasks.c **** 		{
 773:Source/tasks.c **** 			vTaskSuspendAll();
 654              		.loc 1 773 0
 655 0012 FFF7FEFF 		bl	vTaskSuspendAll
 774:Source/tasks.c **** 			{
 775:Source/tasks.c **** 				traceTASK_DELAY();
 776:Source/tasks.c **** 
 777:Source/tasks.c **** 				/* A task that is removed from the event list while the
 778:Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 779:Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 780:Source/tasks.c **** 				is resumed.
 781:Source/tasks.c **** 
 782:Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 783:Source/tasks.c **** 				executing task. */
 784:Source/tasks.c **** 
 785:Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 786:Source/tasks.c **** 				not a problem. */
 787:Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 656              		.loc 1 787 0
 657 0016 0C4B     		ldr	r3, .L42
 658 0018 1A68     		ldr	r2, [r3]
 659 001a 7B68     		ldr	r3, [r7, #4]
 660 001c 1344     		add	r3, r3, r2
 661 001e BB60     		str	r3, [r7, #8]
 788:Source/tasks.c **** 
 789:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 790:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 791:Source/tasks.c **** 				both lists. */
 792:Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 662              		.loc 1 792 0
 663 0020 0A4B     		ldr	r3, .L42+4
 664 0022 1B68     		ldr	r3, [r3]
 665 0024 0433     		adds	r3, r3, #4
 666 0026 1846     		mov	r0, r3
 667 0028 FFF7FEFF 		bl	uxListRemove
 793:Source/tasks.c **** 				{
 794:Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 795:Source/tasks.c **** 					no need to check, and the port reset macro can be called
 796:Source/tasks.c **** 					directly. */
 797:Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 798:Source/tasks.c **** 				}
 799:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 668              		.loc 1 799 0
 669 002c B868     		ldr	r0, [r7, #8]
 670 002e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 800:Source/tasks.c **** 			}
 801:Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 671              		.loc 1 801 0
 672 0032 FFF7FEFF 		bl	xTaskResumeAll
 673 0036 F860     		str	r0, [r7, #12]
 674              	.L40:
 802:Source/tasks.c **** 		}
 803:Source/tasks.c **** 
 804:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 805:Source/tasks.c **** 		have put ourselves to sleep. */
 806:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 675              		.loc 1 806 0
 676 0038 FB68     		ldr	r3, [r7, #12]
 677 003a 002B     		cmp	r3, #0
 678 003c 01D1     		bne	.L39
 807:Source/tasks.c **** 		{
 808:Source/tasks.c **** 			portYIELD_WITHIN_API();
 679              		.loc 1 808 0
 680 003e FFF7FEFF 		bl	vPortYield
 681              	.L39:
 809:Source/tasks.c **** 		}
 810:Source/tasks.c **** 	}
 682              		.loc 1 810 0
 683 0042 1037     		adds	r7, r7, #16
 684 0044 BD46     		mov	sp, r7
 685              		@ sp needed
 686 0046 80BD     		pop	{r7, pc}
 687              	.L43:
 688              		.align	2
 689              	.L42:
 690 0048 00000000 		.word	xTickCount
 691 004c 00000000 		.word	pxCurrentTCB
 692              		.cfi_endproc
 693              	.LFE113:
 695              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 696              		.align	2
 697              		.global	uxTaskPriorityGet
 698              		.thumb
 699              		.thumb_func
 701              	uxTaskPriorityGet:
 702              	.LFB114:
 811:Source/tasks.c **** 
 812:Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 813:Source/tasks.c **** /*-----------------------------------------------------------*/
 814:Source/tasks.c **** 
 815:Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 816:Source/tasks.c **** 
 817:Source/tasks.c **** 	eTaskState eTaskGetState( xTaskHandle xTask )
 818:Source/tasks.c **** 	{
 819:Source/tasks.c **** 	eTaskState eReturn;
 820:Source/tasks.c **** 	xList *pxStateList;
 821:Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 822:Source/tasks.c **** 
 823:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 824:Source/tasks.c **** 		{
 825:Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 826:Source/tasks.c **** 			eReturn = eRunning;
 827:Source/tasks.c **** 		}
 828:Source/tasks.c **** 		else
 829:Source/tasks.c **** 		{
 830:Source/tasks.c **** 			taskENTER_CRITICAL();
 831:Source/tasks.c **** 			{
 832:Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 833:Source/tasks.c **** 			}
 834:Source/tasks.c **** 			taskEXIT_CRITICAL();
 835:Source/tasks.c **** 
 836:Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 837:Source/tasks.c **** 			{
 838:Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 839:Source/tasks.c **** 				lists. */
 840:Source/tasks.c **** 				eReturn = eBlocked;
 841:Source/tasks.c **** 			}
 842:Source/tasks.c **** 
 843:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 844:Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 845:Source/tasks.c **** 				{
 846:Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 847:Source/tasks.c **** 					list. */
 848:Source/tasks.c **** 					eReturn = eSuspended;
 849:Source/tasks.c **** 				}
 850:Source/tasks.c **** 			#endif
 851:Source/tasks.c **** 
 852:Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 853:Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 854:Source/tasks.c **** 				{
 855:Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 856:Source/tasks.c **** 					tasks list. */
 857:Source/tasks.c **** 					eReturn = eDeleted;
 858:Source/tasks.c **** 				}
 859:Source/tasks.c **** 			#endif
 860:Source/tasks.c **** 
 861:Source/tasks.c **** 			else
 862:Source/tasks.c **** 			{
 863:Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 864:Source/tasks.c **** 				Ready (including pending ready) state. */
 865:Source/tasks.c **** 				eReturn = eReady;
 866:Source/tasks.c **** 			}
 867:Source/tasks.c **** 		}
 868:Source/tasks.c **** 
 869:Source/tasks.c **** 		return eReturn;
 870:Source/tasks.c **** 	}
 871:Source/tasks.c **** 
 872:Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
 873:Source/tasks.c **** /*-----------------------------------------------------------*/
 874:Source/tasks.c **** 
 875:Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 876:Source/tasks.c **** 
 877:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
 878:Source/tasks.c **** 	{
 703              		.loc 1 878 0
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 16
 706              		@ frame_needed = 1, uses_anonymous_args = 0
 707 0000 80B5     		push	{r7, lr}
 708              	.LCFI12:
 709              		.cfi_def_cfa_offset 8
 710              		.cfi_offset 7, -8
 711              		.cfi_offset 14, -4
 712 0002 84B0     		sub	sp, sp, #16
 713              	.LCFI13:
 714              		.cfi_def_cfa_offset 24
 715 0004 00AF     		add	r7, sp, #0
 716              	.LCFI14:
 717              		.cfi_def_cfa_register 7
 718 0006 7860     		str	r0, [r7, #4]
 879:Source/tasks.c **** 	tskTCB *pxTCB;
 880:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 881:Source/tasks.c **** 
 882:Source/tasks.c **** 		taskENTER_CRITICAL();
 719              		.loc 1 882 0
 720 0008 FFF7FEFF 		bl	vPortEnterCritical
 883:Source/tasks.c **** 		{
 884:Source/tasks.c **** 			/* If null is passed in here then we are changing the
 885:Source/tasks.c **** 			priority of the calling function. */
 886:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 721              		.loc 1 886 0
 722 000c 7B68     		ldr	r3, [r7, #4]
 723 000e 002B     		cmp	r3, #0
 724 0010 02D1     		bne	.L45
 725              		.loc 1 886 0 is_stmt 0 discriminator 1
 726 0012 074B     		ldr	r3, .L48
 727 0014 1B68     		ldr	r3, [r3]
 728 0016 00E0     		b	.L46
 729              	.L45:
 730              		.loc 1 886 0 discriminator 2
 731 0018 7B68     		ldr	r3, [r7, #4]
 732              	.L46:
 733              		.loc 1 886 0 discriminator 3
 734 001a FB60     		str	r3, [r7, #12]
 887:Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 735              		.loc 1 887 0 is_stmt 1 discriminator 3
 736 001c FB68     		ldr	r3, [r7, #12]
 737 001e DB6A     		ldr	r3, [r3, #44]
 738 0020 BB60     		str	r3, [r7, #8]
 888:Source/tasks.c **** 		}
 889:Source/tasks.c **** 		taskEXIT_CRITICAL();
 739              		.loc 1 889 0 discriminator 3
 740 0022 FFF7FEFF 		bl	vPortExitCritical
 890:Source/tasks.c **** 
 891:Source/tasks.c **** 		return uxReturn;
 741              		.loc 1 891 0 discriminator 3
 742 0026 BB68     		ldr	r3, [r7, #8]
 892:Source/tasks.c **** 	}
 743              		.loc 1 892 0 discriminator 3
 744 0028 1846     		mov	r0, r3
 745 002a 1037     		adds	r7, r7, #16
 746 002c BD46     		mov	sp, r7
 747              		@ sp needed
 748 002e 80BD     		pop	{r7, pc}
 749              	.L49:
 750              		.align	2
 751              	.L48:
 752 0030 00000000 		.word	pxCurrentTCB
 753              		.cfi_endproc
 754              	.LFE114:
 756              		.section	.text.vTaskPrioritySet,"ax",%progbits
 757              		.align	2
 758              		.global	vTaskPrioritySet
 759              		.thumb
 760              		.thumb_func
 762              	vTaskPrioritySet:
 763              	.LFB115:
 893:Source/tasks.c **** 
 894:Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
 895:Source/tasks.c **** /*-----------------------------------------------------------*/
 896:Source/tasks.c **** 
 897:Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 898:Source/tasks.c **** 
 899:Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
 900:Source/tasks.c **** 	{
 764              		.loc 1 900 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 24
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768 0000 80B5     		push	{r7, lr}
 769              	.LCFI15:
 770              		.cfi_def_cfa_offset 8
 771              		.cfi_offset 7, -8
 772              		.cfi_offset 14, -4
 773 0002 86B0     		sub	sp, sp, #24
 774              	.LCFI16:
 775              		.cfi_def_cfa_offset 32
 776 0004 00AF     		add	r7, sp, #0
 777              	.LCFI17:
 778              		.cfi_def_cfa_register 7
 779 0006 7860     		str	r0, [r7, #4]
 780 0008 3960     		str	r1, [r7]
 901:Source/tasks.c **** 	tskTCB *pxTCB;
 902:Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
 903:Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 781              		.loc 1 903 0
 782 000a 0023     		movs	r3, #0
 783 000c 7B61     		str	r3, [r7, #20]
 904:Source/tasks.c **** 
 905:Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 784              		.loc 1 905 0
 785 000e 3B68     		ldr	r3, [r7]
 786 0010 042B     		cmp	r3, #4
 787 0012 02D9     		bls	.L51
 788              		.loc 1 905 0 is_stmt 0 discriminator 1
 789 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 790              	.L52:
 791 0018 FEE7     		b	.L52
 792              	.L51:
 906:Source/tasks.c **** 
 907:Source/tasks.c **** 		/* Ensure the new priority is valid. */
 908:Source/tasks.c **** 		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 793              		.loc 1 908 0 is_stmt 1
 794 001a 3B68     		ldr	r3, [r7]
 795 001c 042B     		cmp	r3, #4
 796 001e 01D9     		bls	.L53
 909:Source/tasks.c **** 		{
 910:Source/tasks.c **** 			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 797              		.loc 1 910 0
 798 0020 0423     		movs	r3, #4
 799 0022 3B60     		str	r3, [r7]
 800              	.L53:
 911:Source/tasks.c **** 		}
 912:Source/tasks.c **** 
 913:Source/tasks.c **** 		taskENTER_CRITICAL();
 801              		.loc 1 913 0
 802 0024 FFF7FEFF 		bl	vPortEnterCritical
 914:Source/tasks.c **** 		{
 915:Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
 916:Source/tasks.c **** 			task that is being changed. */
 917:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 803              		.loc 1 917 0
 804 0028 7B68     		ldr	r3, [r7, #4]
 805 002a 002B     		cmp	r3, #0
 806 002c 02D1     		bne	.L54
 807              		.loc 1 917 0 is_stmt 0 discriminator 1
 808 002e 384B     		ldr	r3, .L65
 809 0030 1B68     		ldr	r3, [r3]
 810 0032 00E0     		b	.L55
 811              	.L54:
 812              		.loc 1 917 0 discriminator 2
 813 0034 7B68     		ldr	r3, [r7, #4]
 814              	.L55:
 815              		.loc 1 917 0 discriminator 3
 816 0036 3B61     		str	r3, [r7, #16]
 918:Source/tasks.c **** 
 919:Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 920:Source/tasks.c **** 
 921:Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 922:Source/tasks.c **** 			{
 923:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 817              		.loc 1 923 0 is_stmt 1 discriminator 3
 818 0038 3B69     		ldr	r3, [r7, #16]
 819 003a 9B6C     		ldr	r3, [r3, #72]
 820 003c FB60     		str	r3, [r7, #12]
 924:Source/tasks.c **** 			}
 925:Source/tasks.c **** 			#else
 926:Source/tasks.c **** 			{
 927:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
 928:Source/tasks.c **** 			}
 929:Source/tasks.c **** 			#endif
 930:Source/tasks.c **** 
 931:Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 821              		.loc 1 931 0 discriminator 3
 822 003e FA68     		ldr	r2, [r7, #12]
 823 0040 3B68     		ldr	r3, [r7]
 824 0042 9A42     		cmp	r2, r3
 825 0044 5ED0     		beq	.L56
 932:Source/tasks.c **** 			{
 933:Source/tasks.c **** 				/* The priority change may have readied a task of higher
 934:Source/tasks.c **** 				priority than the calling task. */
 935:Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 826              		.loc 1 935 0
 827 0046 3A68     		ldr	r2, [r7]
 828 0048 FB68     		ldr	r3, [r7, #12]
 829 004a 9A42     		cmp	r2, r3
 830 004c 0DD9     		bls	.L57
 936:Source/tasks.c **** 				{
 937:Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 831              		.loc 1 937 0
 832 004e 304B     		ldr	r3, .L65
 833 0050 1B68     		ldr	r3, [r3]
 834 0052 3A69     		ldr	r2, [r7, #16]
 835 0054 9A42     		cmp	r2, r3
 836 0056 0FD0     		beq	.L58
 938:Source/tasks.c **** 					{
 939:Source/tasks.c **** 						/* The priority of a task other than the currently
 940:Source/tasks.c **** 						running task is being raised.  Is the priority being
 941:Source/tasks.c **** 						raised above that of the running task? */
 942:Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 837              		.loc 1 942 0
 838 0058 2D4B     		ldr	r3, .L65
 839 005a 1B68     		ldr	r3, [r3]
 840 005c DA6A     		ldr	r2, [r3, #44]
 841 005e 3B68     		ldr	r3, [r7]
 842 0060 9A42     		cmp	r2, r3
 843 0062 09D8     		bhi	.L58
 943:Source/tasks.c **** 						{
 944:Source/tasks.c **** 							xYieldRequired = pdTRUE;
 844              		.loc 1 944 0
 845 0064 0123     		movs	r3, #1
 846 0066 7B61     		str	r3, [r7, #20]
 847 0068 06E0     		b	.L58
 848              	.L57:
 945:Source/tasks.c **** 						}
 946:Source/tasks.c **** 					}
 947:Source/tasks.c **** 					else
 948:Source/tasks.c **** 					{
 949:Source/tasks.c **** 						/* The priority of the running task is being raised,
 950:Source/tasks.c **** 						but the running task must already be the highest
 951:Source/tasks.c **** 						priority task able to run so no yield is required. */
 952:Source/tasks.c **** 					}
 953:Source/tasks.c **** 				}
 954:Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 849              		.loc 1 954 0
 850 006a 294B     		ldr	r3, .L65
 851 006c 1B68     		ldr	r3, [r3]
 852 006e 3A69     		ldr	r2, [r7, #16]
 853 0070 9A42     		cmp	r2, r3
 854 0072 01D1     		bne	.L58
 955:Source/tasks.c **** 				{
 956:Source/tasks.c **** 					/* Setting the priority of the running task down means
 957:Source/tasks.c **** 					there may now be another task of higher priority that
 958:Source/tasks.c **** 					is ready to execute. */
 959:Source/tasks.c **** 					xYieldRequired = pdTRUE;
 855              		.loc 1 959 0
 856 0074 0123     		movs	r3, #1
 857 0076 7B61     		str	r3, [r7, #20]
 858              	.L58:
 960:Source/tasks.c **** 				}
 961:Source/tasks.c **** 				else
 962:Source/tasks.c **** 				{
 963:Source/tasks.c **** 					/* Setting the priority of any other task down does not
 964:Source/tasks.c **** 					require a yield as the running task must be above the
 965:Source/tasks.c **** 					new priority of the task being modified. */
 966:Source/tasks.c **** 				}
 967:Source/tasks.c **** 
 968:Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 969:Source/tasks.c **** 				before its uxPriority member is changed so the
 970:Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 971:Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 859              		.loc 1 971 0
 860 0078 3B69     		ldr	r3, [r7, #16]
 861 007a DB6A     		ldr	r3, [r3, #44]
 862 007c BB60     		str	r3, [r7, #8]
 972:Source/tasks.c **** 
 973:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 974:Source/tasks.c **** 				{
 975:Source/tasks.c **** 					/* Only change the priority being used if the task is not
 976:Source/tasks.c **** 					currently using an inherited priority. */
 977:Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 863              		.loc 1 977 0
 864 007e 3B69     		ldr	r3, [r7, #16]
 865 0080 9A6C     		ldr	r2, [r3, #72]
 866 0082 3B69     		ldr	r3, [r7, #16]
 867 0084 DB6A     		ldr	r3, [r3, #44]
 868 0086 9A42     		cmp	r2, r3
 869 0088 02D1     		bne	.L60
 978:Source/tasks.c **** 					{
 979:Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 870              		.loc 1 979 0
 871 008a 3B69     		ldr	r3, [r7, #16]
 872 008c 3A68     		ldr	r2, [r7]
 873 008e DA62     		str	r2, [r3, #44]
 874              	.L60:
 980:Source/tasks.c **** 					}
 981:Source/tasks.c **** 
 982:Source/tasks.c **** 					/* The base priority gets set whatever. */
 983:Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 875              		.loc 1 983 0
 876 0090 3B69     		ldr	r3, [r7, #16]
 877 0092 3A68     		ldr	r2, [r7]
 878 0094 9A64     		str	r2, [r3, #72]
 984:Source/tasks.c **** 				}
 985:Source/tasks.c **** 				#else
 986:Source/tasks.c **** 				{
 987:Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 988:Source/tasks.c **** 				}
 989:Source/tasks.c **** 				#endif
 990:Source/tasks.c **** 
 991:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - 
 879              		.loc 1 991 0
 880 0096 3B68     		ldr	r3, [r7]
 881 0098 C3F10502 		rsb	r2, r3, #5
 882 009c 3B69     		ldr	r3, [r7, #16]
 883 009e 9A61     		str	r2, [r3, #24]
 992:Source/tasks.c **** 
 993:Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 994:Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 995:Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 996:Source/tasks.c **** 				in the list appropriate to its new priority. */
 997:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 884              		.loc 1 997 0
 885 00a0 3B69     		ldr	r3, [r7, #16]
 886 00a2 5969     		ldr	r1, [r3, #20]
 887 00a4 BA68     		ldr	r2, [r7, #8]
 888 00a6 1346     		mov	r3, r2
 889 00a8 9B00     		lsls	r3, r3, #2
 890 00aa 1344     		add	r3, r3, r2
 891 00ac 9B00     		lsls	r3, r3, #2
 892 00ae 194A     		ldr	r2, .L65+4
 893 00b0 1344     		add	r3, r3, r2
 894 00b2 9942     		cmp	r1, r3
 895 00b4 01D1     		bne	.L61
 896              		.loc 1 997 0 is_stmt 0 discriminator 1
 897 00b6 0123     		movs	r3, #1
 898 00b8 00E0     		b	.L62
 899              	.L61:
 900              		.loc 1 997 0 discriminator 2
 901 00ba 0023     		movs	r3, #0
 902              	.L62:
 903              		.loc 1 997 0 discriminator 3
 904 00bc 002B     		cmp	r3, #0
 905 00be 1CD0     		beq	.L63
 998:Source/tasks.c **** 				{
 999:Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1000:Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1001:Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1002:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 906              		.loc 1 1002 0 is_stmt 1
 907 00c0 3B69     		ldr	r3, [r7, #16]
 908 00c2 0433     		adds	r3, r3, #4
 909 00c4 1846     		mov	r0, r3
 910 00c6 FFF7FEFF 		bl	uxListRemove
1003:Source/tasks.c **** 					{
1004:Source/tasks.c **** 						/* It is known that the task is in its ready list so
1005:Source/tasks.c **** 						there is no need to check again and the port level
1006:Source/tasks.c **** 						reset macro can be called directly. */
1007:Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1008:Source/tasks.c **** 					}
1009:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 911              		.loc 1 1009 0
 912 00ca 3B69     		ldr	r3, [r7, #16]
 913 00cc DA6A     		ldr	r2, [r3, #44]
 914 00ce 124B     		ldr	r3, .L65+8
 915 00d0 1B68     		ldr	r3, [r3]
 916 00d2 9A42     		cmp	r2, r3
 917 00d4 03D9     		bls	.L64
 918              		.loc 1 1009 0 is_stmt 0 discriminator 1
 919 00d6 3B69     		ldr	r3, [r7, #16]
 920 00d8 DA6A     		ldr	r2, [r3, #44]
 921 00da 0F4B     		ldr	r3, .L65+8
 922 00dc 1A60     		str	r2, [r3]
 923              	.L64:
 924              		.loc 1 1009 0 discriminator 2
 925 00de 3B69     		ldr	r3, [r7, #16]
 926 00e0 DA6A     		ldr	r2, [r3, #44]
 927 00e2 1346     		mov	r3, r2
 928 00e4 9B00     		lsls	r3, r3, #2
 929 00e6 1344     		add	r3, r3, r2
 930 00e8 9B00     		lsls	r3, r3, #2
 931 00ea 0A4A     		ldr	r2, .L65+4
 932 00ec 1A44     		add	r2, r2, r3
 933 00ee 3B69     		ldr	r3, [r7, #16]
 934 00f0 0433     		adds	r3, r3, #4
 935 00f2 1046     		mov	r0, r2
 936 00f4 1946     		mov	r1, r3
 937 00f6 FFF7FEFF 		bl	vListInsertEnd
 938              	.L63:
1010:Source/tasks.c **** 				}
1011:Source/tasks.c **** 
1012:Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 939              		.loc 1 1012 0 is_stmt 1
 940 00fa 7B69     		ldr	r3, [r7, #20]
 941 00fc 012B     		cmp	r3, #1
 942 00fe 01D1     		bne	.L56
1013:Source/tasks.c **** 				{
1014:Source/tasks.c **** 					portYIELD_WITHIN_API();
 943              		.loc 1 1014 0
 944 0100 FFF7FEFF 		bl	vPortYield
 945              	.L56:
1015:Source/tasks.c **** 				}
1016:Source/tasks.c **** 
1017:Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1018:Source/tasks.c **** 				optimised task selection is not being used. */
1019:Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1020:Source/tasks.c **** 			}
1021:Source/tasks.c **** 		}
1022:Source/tasks.c **** 		taskEXIT_CRITICAL();
 946              		.loc 1 1022 0
 947 0104 FFF7FEFF 		bl	vPortExitCritical
1023:Source/tasks.c **** 	}
 948              		.loc 1 1023 0
 949 0108 1837     		adds	r7, r7, #24
 950 010a BD46     		mov	sp, r7
 951              		@ sp needed
 952 010c 80BD     		pop	{r7, pc}
 953              	.L66:
 954 010e 00BF     		.align	2
 955              	.L65:
 956 0110 00000000 		.word	pxCurrentTCB
 957 0114 00000000 		.word	pxReadyTasksLists
 958 0118 00000000 		.word	uxTopReadyPriority
 959              		.cfi_endproc
 960              	.LFE115:
 962              		.section	.text.vTaskSuspend,"ax",%progbits
 963              		.align	2
 964              		.global	vTaskSuspend
 965              		.thumb
 966              		.thumb_func
 968              	vTaskSuspend:
 969              	.LFB116:
1024:Source/tasks.c **** 
1025:Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1026:Source/tasks.c **** /*-----------------------------------------------------------*/
1027:Source/tasks.c **** 
1028:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1029:Source/tasks.c **** 
1030:Source/tasks.c **** 	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1031:Source/tasks.c **** 	{
 970              		.loc 1 1031 0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 16
 973              		@ frame_needed = 1, uses_anonymous_args = 0
 974 0000 80B5     		push	{r7, lr}
 975              	.LCFI18:
 976              		.cfi_def_cfa_offset 8
 977              		.cfi_offset 7, -8
 978              		.cfi_offset 14, -4
 979 0002 84B0     		sub	sp, sp, #16
 980              	.LCFI19:
 981              		.cfi_def_cfa_offset 24
 982 0004 00AF     		add	r7, sp, #0
 983              	.LCFI20:
 984              		.cfi_def_cfa_register 7
 985 0006 7860     		str	r0, [r7, #4]
1032:Source/tasks.c **** 	tskTCB *pxTCB;
1033:Source/tasks.c **** 
1034:Source/tasks.c **** 		taskENTER_CRITICAL();
 986              		.loc 1 1034 0
 987 0008 FFF7FEFF 		bl	vPortEnterCritical
1035:Source/tasks.c **** 		{
1036:Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1037:Source/tasks.c **** 			being suspended. */
1038:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 988              		.loc 1 1038 0
 989 000c 7B68     		ldr	r3, [r7, #4]
 990 000e 002B     		cmp	r3, #0
 991 0010 02D1     		bne	.L68
 992              		.loc 1 1038 0 is_stmt 0 discriminator 1
 993 0012 1B4B     		ldr	r3, .L74
 994 0014 1B68     		ldr	r3, [r3]
 995 0016 00E0     		b	.L69
 996              	.L68:
 997              		.loc 1 1038 0 discriminator 2
 998 0018 7B68     		ldr	r3, [r7, #4]
 999              	.L69:
 1000              		.loc 1 1038 0 discriminator 3
 1001 001a FB60     		str	r3, [r7, #12]
1039:Source/tasks.c **** 
1040:Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1041:Source/tasks.c **** 
1042:Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1043:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1002              		.loc 1 1043 0 is_stmt 1 discriminator 3
 1003 001c FB68     		ldr	r3, [r7, #12]
 1004 001e 0433     		adds	r3, r3, #4
 1005 0020 1846     		mov	r0, r3
 1006 0022 FFF7FEFF 		bl	uxListRemove
1044:Source/tasks.c **** 			{
1045:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1046:Source/tasks.c **** 			}
1047:Source/tasks.c **** 
1048:Source/tasks.c **** 			/* Is the task waiting on an event also? */
1049:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1007              		.loc 1 1049 0 discriminator 3
 1008 0026 FB68     		ldr	r3, [r7, #12]
 1009 0028 9B6A     		ldr	r3, [r3, #40]
 1010 002a 002B     		cmp	r3, #0
 1011 002c 04D0     		beq	.L70
1050:Source/tasks.c **** 			{
1051:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1012              		.loc 1 1051 0
 1013 002e FB68     		ldr	r3, [r7, #12]
 1014 0030 1833     		adds	r3, r3, #24
 1015 0032 1846     		mov	r0, r3
 1016 0034 FFF7FEFF 		bl	uxListRemove
 1017              	.L70:
1052:Source/tasks.c **** 			}
1053:Source/tasks.c **** 
1054:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1018              		.loc 1 1054 0
 1019 0038 FB68     		ldr	r3, [r7, #12]
 1020 003a 0433     		adds	r3, r3, #4
 1021 003c 1148     		ldr	r0, .L74+4
 1022 003e 1946     		mov	r1, r3
 1023 0040 FFF7FEFF 		bl	vListInsertEnd
1055:Source/tasks.c **** 		}
1056:Source/tasks.c **** 		taskEXIT_CRITICAL();
 1024              		.loc 1 1056 0
 1025 0044 FFF7FEFF 		bl	vPortExitCritical
1057:Source/tasks.c **** 
1058:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1026              		.loc 1 1058 0
 1027 0048 0D4B     		ldr	r3, .L74
 1028 004a 1B68     		ldr	r3, [r3]
 1029 004c FA68     		ldr	r2, [r7, #12]
 1030 004e 9A42     		cmp	r2, r3
 1031 0050 12D1     		bne	.L67
1059:Source/tasks.c **** 		{
1060:Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1032              		.loc 1 1060 0
 1033 0052 0D4B     		ldr	r3, .L74+8
 1034 0054 1B68     		ldr	r3, [r3]
 1035 0056 002B     		cmp	r3, #0
 1036 0058 02D0     		beq	.L72
1061:Source/tasks.c **** 			{
1062:Source/tasks.c **** 				/* The current task has just been suspended. */
1063:Source/tasks.c **** 				portYIELD_WITHIN_API();
 1037              		.loc 1 1063 0
 1038 005a FFF7FEFF 		bl	vPortYield
 1039 005e 0BE0     		b	.L67
 1040              	.L72:
1064:Source/tasks.c **** 			}
1065:Source/tasks.c **** 			else
1066:Source/tasks.c **** 			{
1067:Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1068:Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1069:Source/tasks.c **** 				must be adjusted to point to a different task. */
1070:Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1041              		.loc 1 1070 0
 1042 0060 084B     		ldr	r3, .L74+4
 1043 0062 1A68     		ldr	r2, [r3]
 1044 0064 094B     		ldr	r3, .L74+12
 1045 0066 1B68     		ldr	r3, [r3]
 1046 0068 9A42     		cmp	r2, r3
 1047 006a 03D1     		bne	.L73
1071:Source/tasks.c **** 				{
1072:Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1073:Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1074:Source/tasks.c **** 					be set to point to it no matter what its relative priority
1075:Source/tasks.c **** 					is. */
1076:Source/tasks.c **** 					pxCurrentTCB = NULL;
 1048              		.loc 1 1076 0
 1049 006c 044B     		ldr	r3, .L74
 1050 006e 0022     		movs	r2, #0
 1051 0070 1A60     		str	r2, [r3]
 1052 0072 01E0     		b	.L67
 1053              	.L73:
1077:Source/tasks.c **** 				}
1078:Source/tasks.c **** 				else
1079:Source/tasks.c **** 				{
1080:Source/tasks.c **** 					vTaskSwitchContext();
 1054              		.loc 1 1080 0
 1055 0074 FFF7FEFF 		bl	vTaskSwitchContext
 1056              	.L67:
1081:Source/tasks.c **** 				}
1082:Source/tasks.c **** 			}
1083:Source/tasks.c **** 		}
1084:Source/tasks.c **** 	}
 1057              		.loc 1 1084 0
 1058 0078 1037     		adds	r7, r7, #16
 1059 007a BD46     		mov	sp, r7
 1060              		@ sp needed
 1061 007c 80BD     		pop	{r7, pc}
 1062              	.L75:
 1063 007e 00BF     		.align	2
 1064              	.L74:
 1065 0080 00000000 		.word	pxCurrentTCB
 1066 0084 00000000 		.word	xSuspendedTaskList
 1067 0088 00000000 		.word	xSchedulerRunning
 1068 008c 00000000 		.word	uxCurrentNumberOfTasks
 1069              		.cfi_endproc
 1070              	.LFE116:
 1072              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1073              		.align	2
 1074              		.global	xTaskIsTaskSuspended
 1075              		.thumb
 1076              		.thumb_func
 1078              	xTaskIsTaskSuspended:
 1079              	.LFB117:
1085:Source/tasks.c **** 
1086:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1087:Source/tasks.c **** /*-----------------------------------------------------------*/
1088:Source/tasks.c **** 
1089:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1090:Source/tasks.c **** 
1091:Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1092:Source/tasks.c **** 	{
 1080              		.loc 1 1092 0
 1081              		.cfi_startproc
 1082              		@ args = 0, pretend = 0, frame = 16
 1083              		@ frame_needed = 1, uses_anonymous_args = 0
 1084 0000 80B5     		push	{r7, lr}
 1085              	.LCFI21:
 1086              		.cfi_def_cfa_offset 8
 1087              		.cfi_offset 7, -8
 1088              		.cfi_offset 14, -4
 1089 0002 84B0     		sub	sp, sp, #16
 1090              	.LCFI22:
 1091              		.cfi_def_cfa_offset 24
 1092 0004 00AF     		add	r7, sp, #0
 1093              	.LCFI23:
 1094              		.cfi_def_cfa_register 7
 1095 0006 7860     		str	r0, [r7, #4]
1093:Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1096              		.loc 1 1093 0
 1097 0008 0023     		movs	r3, #0
 1098 000a FB60     		str	r3, [r7, #12]
1094:Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1099              		.loc 1 1094 0
 1100 000c 7B68     		ldr	r3, [r7, #4]
 1101 000e BB60     		str	r3, [r7, #8]
1095:Source/tasks.c **** 
1096:Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1097:Source/tasks.c **** 		configASSERT( xTask );
 1102              		.loc 1 1097 0
 1103 0010 7B68     		ldr	r3, [r7, #4]
 1104 0012 002B     		cmp	r3, #0
 1105 0014 02D1     		bne	.L77
 1106              		.loc 1 1097 0 is_stmt 0 discriminator 1
 1107 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1108              	.L78:
 1109 001a FEE7     		b	.L78
 1110              	.L77:
1098:Source/tasks.c **** 
1099:Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1100:Source/tasks.c **** 		suspended list? */
1101:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1111              		.loc 1 1101 0 is_stmt 1
 1112 001c BB68     		ldr	r3, [r7, #8]
 1113 001e 5A69     		ldr	r2, [r3, #20]
 1114 0020 0E4B     		ldr	r3, .L85
 1115 0022 9A42     		cmp	r2, r3
 1116 0024 01D1     		bne	.L79
 1117              		.loc 1 1101 0 is_stmt 0 discriminator 1
 1118 0026 0123     		movs	r3, #1
 1119 0028 00E0     		b	.L80
 1120              	.L79:
 1121              		.loc 1 1101 0 discriminator 2
 1122 002a 0023     		movs	r3, #0
 1123              	.L80:
 1124              		.loc 1 1101 0 discriminator 3
 1125 002c 002B     		cmp	r3, #0
 1126 002e 0FD0     		beq	.L81
1102:Source/tasks.c **** 		{
1103:Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1104:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1127              		.loc 1 1104 0 is_stmt 1
 1128 0030 BB68     		ldr	r3, [r7, #8]
 1129 0032 9A6A     		ldr	r2, [r3, #40]
 1130 0034 0A4B     		ldr	r3, .L85+4
 1131 0036 9A42     		cmp	r2, r3
 1132 0038 0AD0     		beq	.L81
1105:Source/tasks.c **** 			{
1106:Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1107:Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1108:Source/tasks.c **** 				list because it is blocked on a task with no timeout
1109:Source/tasks.c **** 				specified. */
1110:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1133              		.loc 1 1110 0
 1134 003a BB68     		ldr	r3, [r7, #8]
 1135 003c 9B6A     		ldr	r3, [r3, #40]
 1136 003e 002B     		cmp	r3, #0
 1137 0040 01D1     		bne	.L82
 1138              		.loc 1 1110 0 is_stmt 0 discriminator 1
 1139 0042 0123     		movs	r3, #1
 1140 0044 00E0     		b	.L83
 1141              	.L82:
 1142              		.loc 1 1110 0 discriminator 2
 1143 0046 0023     		movs	r3, #0
 1144              	.L83:
 1145              		.loc 1 1110 0 discriminator 3
 1146 0048 002B     		cmp	r3, #0
 1147 004a 01D0     		beq	.L81
1111:Source/tasks.c **** 				{
1112:Source/tasks.c **** 					xReturn = pdTRUE;
 1148              		.loc 1 1112 0 is_stmt 1
 1149 004c 0123     		movs	r3, #1
 1150 004e FB60     		str	r3, [r7, #12]
 1151              	.L81:
1113:Source/tasks.c **** 				}
1114:Source/tasks.c **** 			}
1115:Source/tasks.c **** 		}
1116:Source/tasks.c **** 
1117:Source/tasks.c **** 		return xReturn;
 1152              		.loc 1 1117 0
 1153 0050 FB68     		ldr	r3, [r7, #12]
1118:Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1154              		.loc 1 1118 0
 1155 0052 1846     		mov	r0, r3
 1156 0054 1037     		adds	r7, r7, #16
 1157 0056 BD46     		mov	sp, r7
 1158              		@ sp needed
 1159 0058 80BD     		pop	{r7, pc}
 1160              	.L86:
 1161 005a 00BF     		.align	2
 1162              	.L85:
 1163 005c 00000000 		.word	xSuspendedTaskList
 1164 0060 00000000 		.word	xPendingReadyList
 1165              		.cfi_endproc
 1166              	.LFE117:
 1168              		.section	.text.vTaskResume,"ax",%progbits
 1169              		.align	2
 1170              		.global	vTaskResume
 1171              		.thumb
 1172              		.thumb_func
 1174              	vTaskResume:
 1175              	.LFB118:
1119:Source/tasks.c **** 
1120:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1121:Source/tasks.c **** /*-----------------------------------------------------------*/
1122:Source/tasks.c **** 
1123:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1124:Source/tasks.c **** 
1125:Source/tasks.c **** 	void vTaskResume( xTaskHandle xTaskToResume )
1126:Source/tasks.c **** 	{
 1176              		.loc 1 1126 0
 1177              		.cfi_startproc
 1178              		@ args = 0, pretend = 0, frame = 16
 1179              		@ frame_needed = 1, uses_anonymous_args = 0
 1180 0000 80B5     		push	{r7, lr}
 1181              	.LCFI24:
 1182              		.cfi_def_cfa_offset 8
 1183              		.cfi_offset 7, -8
 1184              		.cfi_offset 14, -4
 1185 0002 84B0     		sub	sp, sp, #16
 1186              	.LCFI25:
 1187              		.cfi_def_cfa_offset 24
 1188 0004 00AF     		add	r7, sp, #0
 1189              	.LCFI26:
 1190              		.cfi_def_cfa_register 7
 1191 0006 7860     		str	r0, [r7, #4]
1127:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
 1192              		.loc 1 1127 0
 1193 0008 7B68     		ldr	r3, [r7, #4]
 1194 000a FB60     		str	r3, [r7, #12]
1128:Source/tasks.c **** 
1129:Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1130:Source/tasks.c **** 		configASSERT( xTaskToResume );
 1195              		.loc 1 1130 0
 1196 000c 7B68     		ldr	r3, [r7, #4]
 1197 000e 002B     		cmp	r3, #0
 1198 0010 02D1     		bne	.L88
 1199              		.loc 1 1130 0 is_stmt 0 discriminator 1
 1200 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1201              	.L89:
 1202 0016 FEE7     		b	.L89
 1203              	.L88:
1131:Source/tasks.c **** 
1132:Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1133:Source/tasks.c **** 		currently executing task. */
1134:Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1204              		.loc 1 1134 0 is_stmt 1
 1205 0018 FB68     		ldr	r3, [r7, #12]
 1206 001a 002B     		cmp	r3, #0
 1207 001c 34D0     		beq	.L87
 1208              		.loc 1 1134 0 is_stmt 0 discriminator 1
 1209 001e 1C4B     		ldr	r3, .L93
 1210 0020 1B68     		ldr	r3, [r3]
 1211 0022 FA68     		ldr	r2, [r7, #12]
 1212 0024 9A42     		cmp	r2, r3
 1213 0026 2FD0     		beq	.L87
1135:Source/tasks.c **** 		{
1136:Source/tasks.c **** 			taskENTER_CRITICAL();
 1214              		.loc 1 1136 0 is_stmt 1
 1215 0028 FFF7FEFF 		bl	vPortEnterCritical
1137:Source/tasks.c **** 			{
1138:Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1216              		.loc 1 1138 0
 1217 002c F868     		ldr	r0, [r7, #12]
 1218 002e FFF7FEFF 		bl	xTaskIsTaskSuspended
 1219 0032 0346     		mov	r3, r0
 1220 0034 012B     		cmp	r3, #1
 1221 0036 25D1     		bne	.L91
1139:Source/tasks.c **** 				{
1140:Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1141:Source/tasks.c **** 
1142:Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1143:Source/tasks.c **** 					lists even if the scheduler is suspended. */
1144:Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1222              		.loc 1 1144 0
 1223 0038 FB68     		ldr	r3, [r7, #12]
 1224 003a 0433     		adds	r3, r3, #4
 1225 003c 1846     		mov	r0, r3
 1226 003e FFF7FEFF 		bl	uxListRemove
1145:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1227              		.loc 1 1145 0
 1228 0042 FB68     		ldr	r3, [r7, #12]
 1229 0044 DA6A     		ldr	r2, [r3, #44]
 1230 0046 134B     		ldr	r3, .L93+4
 1231 0048 1B68     		ldr	r3, [r3]
 1232 004a 9A42     		cmp	r2, r3
 1233 004c 03D9     		bls	.L92
 1234              		.loc 1 1145 0 is_stmt 0 discriminator 1
 1235 004e FB68     		ldr	r3, [r7, #12]
 1236 0050 DA6A     		ldr	r2, [r3, #44]
 1237 0052 104B     		ldr	r3, .L93+4
 1238 0054 1A60     		str	r2, [r3]
 1239              	.L92:
 1240              		.loc 1 1145 0 discriminator 2
 1241 0056 FB68     		ldr	r3, [r7, #12]
 1242 0058 DA6A     		ldr	r2, [r3, #44]
 1243 005a 1346     		mov	r3, r2
 1244 005c 9B00     		lsls	r3, r3, #2
 1245 005e 1344     		add	r3, r3, r2
 1246 0060 9B00     		lsls	r3, r3, #2
 1247 0062 0D4A     		ldr	r2, .L93+8
 1248 0064 1A44     		add	r2, r2, r3
 1249 0066 FB68     		ldr	r3, [r7, #12]
 1250 0068 0433     		adds	r3, r3, #4
 1251 006a 1046     		mov	r0, r2
 1252 006c 1946     		mov	r1, r3
 1253 006e FFF7FEFF 		bl	vListInsertEnd
1146:Source/tasks.c **** 
1147:Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1148:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1254              		.loc 1 1148 0 is_stmt 1 discriminator 2
 1255 0072 FB68     		ldr	r3, [r7, #12]
 1256 0074 DA6A     		ldr	r2, [r3, #44]
 1257 0076 064B     		ldr	r3, .L93
 1258 0078 1B68     		ldr	r3, [r3]
 1259 007a DB6A     		ldr	r3, [r3, #44]
 1260 007c 9A42     		cmp	r2, r3
 1261 007e 01D3     		bcc	.L91
1149:Source/tasks.c **** 					{
1150:Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1151:Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1152:Source/tasks.c **** 						portYIELD_WITHIN_API();
 1262              		.loc 1 1152 0
 1263 0080 FFF7FEFF 		bl	vPortYield
 1264              	.L91:
1153:Source/tasks.c **** 					}
1154:Source/tasks.c **** 				}
1155:Source/tasks.c **** 			}
1156:Source/tasks.c **** 			taskEXIT_CRITICAL();
 1265              		.loc 1 1156 0
 1266 0084 FFF7FEFF 		bl	vPortExitCritical
 1267              	.L87:
1157:Source/tasks.c **** 		}
1158:Source/tasks.c **** 	}
 1268              		.loc 1 1158 0
 1269 0088 1037     		adds	r7, r7, #16
 1270 008a BD46     		mov	sp, r7
 1271              		@ sp needed
 1272 008c 80BD     		pop	{r7, pc}
 1273              	.L94:
 1274 008e 00BF     		.align	2
 1275              	.L93:
 1276 0090 00000000 		.word	pxCurrentTCB
 1277 0094 00000000 		.word	uxTopReadyPriority
 1278 0098 00000000 		.word	pxReadyTasksLists
 1279              		.cfi_endproc
 1280              	.LFE118:
 1282              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1283              		.align	2
 1284              		.global	xTaskResumeFromISR
 1285              		.thumb
 1286              		.thumb_func
 1288              	xTaskResumeFromISR:
 1289              	.LFB119:
1159:Source/tasks.c **** 
1160:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1161:Source/tasks.c **** 
1162:Source/tasks.c **** /*-----------------------------------------------------------*/
1163:Source/tasks.c **** 
1164:Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1165:Source/tasks.c **** 
1166:Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1167:Source/tasks.c **** 	{
 1290              		.loc 1 1167 0
 1291              		.cfi_startproc
 1292              		@ args = 0, pretend = 0, frame = 24
 1293              		@ frame_needed = 1, uses_anonymous_args = 0
 1294 0000 80B5     		push	{r7, lr}
 1295              	.LCFI27:
 1296              		.cfi_def_cfa_offset 8
 1297              		.cfi_offset 7, -8
 1298              		.cfi_offset 14, -4
 1299 0002 86B0     		sub	sp, sp, #24
 1300              	.LCFI28:
 1301              		.cfi_def_cfa_offset 32
 1302 0004 00AF     		add	r7, sp, #0
 1303              	.LCFI29:
 1304              		.cfi_def_cfa_register 7
 1305 0006 7860     		str	r0, [r7, #4]
1168:Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1306              		.loc 1 1168 0
 1307 0008 0023     		movs	r3, #0
 1308 000a 7B61     		str	r3, [r7, #20]
1169:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
 1309              		.loc 1 1169 0
 1310 000c 7B68     		ldr	r3, [r7, #4]
 1311 000e 3B61     		str	r3, [r7, #16]
1170:Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1171:Source/tasks.c **** 
1172:Source/tasks.c **** 		configASSERT( xTaskToResume );
 1312              		.loc 1 1172 0
 1313 0010 7B68     		ldr	r3, [r7, #4]
 1314 0012 002B     		cmp	r3, #0
 1315 0014 02D1     		bne	.L96
 1316              		.loc 1 1172 0 is_stmt 0 discriminator 1
 1317 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1318              	.L97:
 1319 001a FEE7     		b	.L97
 1320              	.L96:
1173:Source/tasks.c **** 
1174:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1175:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1176:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1177:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1178:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1179:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1180:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1181:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1182:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1183:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1184:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1185:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1186:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1187:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1188:Source/tasks.c **** 		provided on the following link:
1189:Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1190:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1321              		.loc 1 1190 0 is_stmt 1
 1322 001c FFF7FEFF 		bl	vPortValidateInterruptPriority
1191:Source/tasks.c **** 
1192:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1323              		.loc 1 1192 0
 1324 0020 FFF7FEFF 		bl	ulPortSetInterruptMask
 1325 0024 F860     		str	r0, [r7, #12]
1193:Source/tasks.c **** 		{
1194:Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1326              		.loc 1 1194 0
 1327 0026 3869     		ldr	r0, [r7, #16]
 1328 0028 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1329 002c 0346     		mov	r3, r0
 1330 002e 012B     		cmp	r3, #1
 1331 0030 30D1     		bne	.L98
1195:Source/tasks.c **** 			{
1196:Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1197:Source/tasks.c **** 
1198:Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1332              		.loc 1 1198 0
 1333 0032 1C4B     		ldr	r3, .L103
 1334 0034 1B68     		ldr	r3, [r3]
 1335 0036 002B     		cmp	r3, #0
 1336 0038 26D1     		bne	.L99
1199:Source/tasks.c **** 				{
1200:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1337              		.loc 1 1200 0
 1338 003a 3B69     		ldr	r3, [r7, #16]
 1339 003c DA6A     		ldr	r2, [r3, #44]
 1340 003e 1A4B     		ldr	r3, .L103+4
 1341 0040 1B68     		ldr	r3, [r3]
 1342 0042 DB6A     		ldr	r3, [r3, #44]
 1343 0044 9A42     		cmp	r2, r3
 1344 0046 01D3     		bcc	.L100
1201:Source/tasks.c **** 					{
1202:Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1345              		.loc 1 1202 0
 1346 0048 0123     		movs	r3, #1
 1347 004a 7B61     		str	r3, [r7, #20]
 1348              	.L100:
1203:Source/tasks.c **** 					}
1204:Source/tasks.c **** 
1205:Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1349              		.loc 1 1205 0
 1350 004c 3B69     		ldr	r3, [r7, #16]
 1351 004e 0433     		adds	r3, r3, #4
 1352 0050 1846     		mov	r0, r3
 1353 0052 FFF7FEFF 		bl	uxListRemove
1206:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1354              		.loc 1 1206 0
 1355 0056 3B69     		ldr	r3, [r7, #16]
 1356 0058 DA6A     		ldr	r2, [r3, #44]
 1357 005a 144B     		ldr	r3, .L103+8
 1358 005c 1B68     		ldr	r3, [r3]
 1359 005e 9A42     		cmp	r2, r3
 1360 0060 03D9     		bls	.L101
 1361              		.loc 1 1206 0 is_stmt 0 discriminator 1
 1362 0062 3B69     		ldr	r3, [r7, #16]
 1363 0064 DA6A     		ldr	r2, [r3, #44]
 1364 0066 114B     		ldr	r3, .L103+8
 1365 0068 1A60     		str	r2, [r3]
 1366              	.L101:
 1367              		.loc 1 1206 0 discriminator 2
 1368 006a 3B69     		ldr	r3, [r7, #16]
 1369 006c DA6A     		ldr	r2, [r3, #44]
 1370 006e 1346     		mov	r3, r2
 1371 0070 9B00     		lsls	r3, r3, #2
 1372 0072 1344     		add	r3, r3, r2
 1373 0074 9B00     		lsls	r3, r3, #2
 1374 0076 0E4A     		ldr	r2, .L103+12
 1375 0078 1A44     		add	r2, r2, r3
 1376 007a 3B69     		ldr	r3, [r7, #16]
 1377 007c 0433     		adds	r3, r3, #4
 1378 007e 1046     		mov	r0, r2
 1379 0080 1946     		mov	r1, r3
 1380 0082 FFF7FEFF 		bl	vListInsertEnd
 1381 0086 05E0     		b	.L98
 1382              	.L99:
1207:Source/tasks.c **** 				}
1208:Source/tasks.c **** 				else
1209:Source/tasks.c **** 				{
1210:Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1211:Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1212:Source/tasks.c **** 					yield will be performed if necessary. */
1213:Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1383              		.loc 1 1213 0 is_stmt 1
 1384 0088 3B69     		ldr	r3, [r7, #16]
 1385 008a 1833     		adds	r3, r3, #24
 1386 008c 0948     		ldr	r0, .L103+16
 1387 008e 1946     		mov	r1, r3
 1388 0090 FFF7FEFF 		bl	vListInsertEnd
 1389              	.L98:
1214:Source/tasks.c **** 				}
1215:Source/tasks.c **** 			}
1216:Source/tasks.c **** 		}
1217:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1390              		.loc 1 1217 0
 1391 0094 F868     		ldr	r0, [r7, #12]
 1392 0096 FFF7FEFF 		bl	vPortClearInterruptMask
1218:Source/tasks.c **** 
1219:Source/tasks.c **** 		return xYieldRequired;
 1393              		.loc 1 1219 0
 1394 009a 7B69     		ldr	r3, [r7, #20]
1220:Source/tasks.c **** 	}
 1395              		.loc 1 1220 0
 1396 009c 1846     		mov	r0, r3
 1397 009e 1837     		adds	r7, r7, #24
 1398 00a0 BD46     		mov	sp, r7
 1399              		@ sp needed
 1400 00a2 80BD     		pop	{r7, pc}
 1401              	.L104:
 1402              		.align	2
 1403              	.L103:
 1404 00a4 00000000 		.word	uxSchedulerSuspended
 1405 00a8 00000000 		.word	pxCurrentTCB
 1406 00ac 00000000 		.word	uxTopReadyPriority
 1407 00b0 00000000 		.word	pxReadyTasksLists
 1408 00b4 00000000 		.word	xPendingReadyList
 1409              		.cfi_endproc
 1410              	.LFE119:
 1412              		.section	.rodata
 1413              		.align	2
 1414              	.LC0:
 1415 0000 49444C45 		.ascii	"IDLE\000"
 1415      00
 1416 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1417              		.align	2
 1418              		.global	vTaskStartScheduler
 1419              		.thumb
 1420              		.thumb_func
 1422              	vTaskStartScheduler:
 1423              	.LFB120:
1221:Source/tasks.c **** 
1222:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1223:Source/tasks.c **** /*-----------------------------------------------------------*/
1224:Source/tasks.c **** 
1225:Source/tasks.c **** void vTaskStartScheduler( void )
1226:Source/tasks.c **** {
 1424              		.loc 1 1226 0
 1425              		.cfi_startproc
 1426              		@ args = 0, pretend = 0, frame = 8
 1427              		@ frame_needed = 1, uses_anonymous_args = 0
 1428 0000 80B5     		push	{r7, lr}
 1429              	.LCFI30:
 1430              		.cfi_def_cfa_offset 8
 1431              		.cfi_offset 7, -8
 1432              		.cfi_offset 14, -4
 1433 0002 86B0     		sub	sp, sp, #24
 1434              	.LCFI31:
 1435              		.cfi_def_cfa_offset 32
 1436 0004 04AF     		add	r7, sp, #16
 1437              	.LCFI32:
 1438              		.cfi_def_cfa 7, 16
1227:Source/tasks.c **** portBASE_TYPE xReturn;
1228:Source/tasks.c **** 
1229:Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1230:Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1231:Source/tasks.c **** 	{
1232:Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1233:Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1234:Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1235:Source/tasks.c **** 	}
1236:Source/tasks.c **** 	#else
1237:Source/tasks.c **** 	{
1238:Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1239:Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1439              		.loc 1 1239 0
 1440 0006 0023     		movs	r3, #0
 1441 0008 0093     		str	r3, [sp]
 1442 000a 0023     		movs	r3, #0
 1443 000c 0193     		str	r3, [sp, #4]
 1444 000e 0023     		movs	r3, #0
 1445 0010 0293     		str	r3, [sp, #8]
 1446 0012 0023     		movs	r3, #0
 1447 0014 0393     		str	r3, [sp, #12]
 1448 0016 1248     		ldr	r0, .L110
 1449 0018 1249     		ldr	r1, .L110+4
 1450 001a 8222     		movs	r2, #130
 1451 001c 0023     		movs	r3, #0
 1452 001e FFF7FEFF 		bl	xTaskGenericCreate
 1453 0022 7860     		str	r0, [r7, #4]
1240:Source/tasks.c **** 	}
1241:Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1242:Source/tasks.c **** 
1243:Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1244:Source/tasks.c **** 	{
1245:Source/tasks.c **** 		if( xReturn == pdPASS )
 1454              		.loc 1 1245 0
 1455 0024 7B68     		ldr	r3, [r7, #4]
 1456 0026 012B     		cmp	r3, #1
 1457 0028 02D1     		bne	.L106
1246:Source/tasks.c **** 		{
1247:Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1458              		.loc 1 1247 0
 1459 002a FFF7FEFF 		bl	xTimerCreateTimerTask
 1460 002e 7860     		str	r0, [r7, #4]
 1461              	.L106:
1248:Source/tasks.c **** 		}
1249:Source/tasks.c **** 	}
1250:Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1251:Source/tasks.c **** 
1252:Source/tasks.c **** 	if( xReturn == pdPASS )
 1462              		.loc 1 1252 0
 1463 0030 7B68     		ldr	r3, [r7, #4]
 1464 0032 012B     		cmp	r3, #1
 1465 0034 0AD1     		bne	.L107
1253:Source/tasks.c **** 	{
1254:Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1255:Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1256:Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1257:Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1258:Source/tasks.c **** 		starts to run. */
1259:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1466              		.loc 1 1259 0
 1467 0036 FFF7FEFF 		bl	ulPortSetInterruptMask
1260:Source/tasks.c **** 
1261:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1262:Source/tasks.c **** 		{
1263:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1264:Source/tasks.c **** 			structure specific to the task that will run first. */
1265:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1266:Source/tasks.c **** 		}
1267:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1268:Source/tasks.c **** 
1269:Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1468              		.loc 1 1269 0
 1469 003a 0B4B     		ldr	r3, .L110+8
 1470 003c 0122     		movs	r2, #1
 1471 003e 1A60     		str	r2, [r3]
1270:Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1472              		.loc 1 1270 0
 1473 0040 0A4B     		ldr	r3, .L110+12
 1474 0042 0022     		movs	r2, #0
 1475 0044 1A60     		str	r2, [r3]
1271:Source/tasks.c **** 
1272:Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1273:Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1274:Source/tasks.c **** 		the run time counter time base. */
1275:Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1276:Source/tasks.c **** 
1277:Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1278:Source/tasks.c **** 		portable interface. */
1279:Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1476              		.loc 1 1279 0
 1477 0046 FFF7FEFF 		bl	xPortStartScheduler
 1478 004a 05E0     		b	.L105
 1479              	.L107:
1280:Source/tasks.c **** 		{
1281:Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1282:Source/tasks.c **** 			function will not return. */
1283:Source/tasks.c **** 		}
1284:Source/tasks.c **** 		else
1285:Source/tasks.c **** 		{
1286:Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1287:Source/tasks.c **** 		}
1288:Source/tasks.c **** 	}
1289:Source/tasks.c **** 	else
1290:Source/tasks.c **** 	{
1291:Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1292:Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1293:Source/tasks.c **** 		or the timer task. */
1294:Source/tasks.c **** 		configASSERT( xReturn );
 1480              		.loc 1 1294 0
 1481 004c 7B68     		ldr	r3, [r7, #4]
 1482 004e 002B     		cmp	r3, #0
 1483 0050 02D1     		bne	.L105
 1484              		.loc 1 1294 0 is_stmt 0 discriminator 1
 1485 0052 FFF7FEFF 		bl	ulPortSetInterruptMask
 1486              	.L109:
 1487 0056 FEE7     		b	.L109
 1488              	.L105:
1295:Source/tasks.c **** 	}
1296:Source/tasks.c **** }
 1489              		.loc 1 1296 0 is_stmt 1
 1490 0058 0837     		adds	r7, r7, #8
 1491 005a BD46     		mov	sp, r7
 1492              		@ sp needed
 1493 005c 80BD     		pop	{r7, pc}
 1494              	.L111:
 1495 005e 00BF     		.align	2
 1496              	.L110:
 1497 0060 00000000 		.word	prvIdleTask
 1498 0064 00000000 		.word	.LC0
 1499 0068 00000000 		.word	xSchedulerRunning
 1500 006c 00000000 		.word	xTickCount
 1501              		.cfi_endproc
 1502              	.LFE120:
 1504              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1505              		.align	2
 1506              		.global	vTaskEndScheduler
 1507              		.thumb
 1508              		.thumb_func
 1510              	vTaskEndScheduler:
 1511              	.LFB121:
1297:Source/tasks.c **** /*-----------------------------------------------------------*/
1298:Source/tasks.c **** 
1299:Source/tasks.c **** void vTaskEndScheduler( void )
1300:Source/tasks.c **** {
 1512              		.loc 1 1300 0
 1513              		.cfi_startproc
 1514              		@ args = 0, pretend = 0, frame = 0
 1515              		@ frame_needed = 1, uses_anonymous_args = 0
 1516 0000 80B5     		push	{r7, lr}
 1517              	.LCFI33:
 1518              		.cfi_def_cfa_offset 8
 1519              		.cfi_offset 7, -8
 1520              		.cfi_offset 14, -4
 1521 0002 00AF     		add	r7, sp, #0
 1522              	.LCFI34:
 1523              		.cfi_def_cfa_register 7
1301:Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1302:Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1303:Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1304:Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1524              		.loc 1 1304 0
 1525 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
1305:Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1526              		.loc 1 1305 0
 1527 0008 024B     		ldr	r3, .L113
 1528 000a 0022     		movs	r2, #0
 1529 000c 1A60     		str	r2, [r3]
1306:Source/tasks.c **** 	vPortEndScheduler();
 1530              		.loc 1 1306 0
 1531 000e FFF7FEFF 		bl	vPortEndScheduler
1307:Source/tasks.c **** }
 1532              		.loc 1 1307 0
 1533 0012 80BD     		pop	{r7, pc}
 1534              	.L114:
 1535              		.align	2
 1536              	.L113:
 1537 0014 00000000 		.word	xSchedulerRunning
 1538              		.cfi_endproc
 1539              	.LFE121:
 1541              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1542              		.align	2
 1543              		.global	vTaskSuspendAll
 1544              		.thumb
 1545              		.thumb_func
 1547              	vTaskSuspendAll:
 1548              	.LFB122:
1308:Source/tasks.c **** /*----------------------------------------------------------*/
1309:Source/tasks.c **** 
1310:Source/tasks.c **** void vTaskSuspendAll( void )
1311:Source/tasks.c **** {
 1549              		.loc 1 1311 0
 1550              		.cfi_startproc
 1551              		@ args = 0, pretend = 0, frame = 0
 1552              		@ frame_needed = 1, uses_anonymous_args = 0
 1553              		@ link register save eliminated.
 1554 0000 80B4     		push	{r7}
 1555              	.LCFI35:
 1556              		.cfi_def_cfa_offset 4
 1557              		.cfi_offset 7, -4
 1558 0002 00AF     		add	r7, sp, #0
 1559              	.LCFI36:
 1560              		.cfi_def_cfa_register 7
1312:Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1313:Source/tasks.c **** 	portBASE_TYPE. */
1314:Source/tasks.c **** 	++uxSchedulerSuspended;
 1561              		.loc 1 1314 0
 1562 0004 044B     		ldr	r3, .L116
 1563 0006 1B68     		ldr	r3, [r3]
 1564 0008 5A1C     		adds	r2, r3, #1
 1565 000a 034B     		ldr	r3, .L116
 1566 000c 1A60     		str	r2, [r3]
1315:Source/tasks.c **** }
 1567              		.loc 1 1315 0
 1568 000e BD46     		mov	sp, r7
 1569              		@ sp needed
 1570 0010 5DF8047B 		ldr	r7, [sp], #4
 1571 0014 7047     		bx	lr
 1572              	.L117:
 1573 0016 00BF     		.align	2
 1574              	.L116:
 1575 0018 00000000 		.word	uxSchedulerSuspended
 1576              		.cfi_endproc
 1577              	.LFE122:
 1579              		.section	.text.xTaskResumeAll,"ax",%progbits
 1580              		.align	2
 1581              		.global	xTaskResumeAll
 1582              		.thumb
 1583              		.thumb_func
 1585              	xTaskResumeAll:
 1586              	.LFB123:
1316:Source/tasks.c **** /*----------------------------------------------------------*/
1317:Source/tasks.c **** 
1318:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1319:Source/tasks.c **** 
1320:Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void )
1321:Source/tasks.c **** 	{
1322:Source/tasks.c **** 	portTickType xReturn;
1323:Source/tasks.c **** 
1324:Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1325:Source/tasks.c **** 		{
1326:Source/tasks.c **** 			xReturn = 0;
1327:Source/tasks.c **** 		}
1328:Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1329:Source/tasks.c **** 		{
1330:Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1331:Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1332:Source/tasks.c **** 			processed. */
1333:Source/tasks.c **** 			xReturn = 0;
1334:Source/tasks.c **** 		}
1335:Source/tasks.c **** 		else
1336:Source/tasks.c **** 		{
1337:Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1338:Source/tasks.c **** 		}
1339:Source/tasks.c **** 
1340:Source/tasks.c **** 		return xReturn;
1341:Source/tasks.c **** 	}
1342:Source/tasks.c **** 
1343:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1344:Source/tasks.c **** /*----------------------------------------------------------*/
1345:Source/tasks.c **** 
1346:Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1347:Source/tasks.c **** {
 1587              		.loc 1 1347 0
 1588              		.cfi_startproc
 1589              		@ args = 0, pretend = 0, frame = 8
 1590              		@ frame_needed = 1, uses_anonymous_args = 0
 1591 0000 80B5     		push	{r7, lr}
 1592              	.LCFI37:
 1593              		.cfi_def_cfa_offset 8
 1594              		.cfi_offset 7, -8
 1595              		.cfi_offset 14, -4
 1596 0002 82B0     		sub	sp, sp, #8
 1597              	.LCFI38:
 1598              		.cfi_def_cfa_offset 16
 1599 0004 00AF     		add	r7, sp, #0
 1600              	.LCFI39:
 1601              		.cfi_def_cfa_register 7
1348:Source/tasks.c **** tskTCB *pxTCB;
1349:Source/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
 1602              		.loc 1 1349 0
 1603 0006 0023     		movs	r3, #0
 1604 0008 7B60     		str	r3, [r7, #4]
1350:Source/tasks.c **** 
1351:Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1352:Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1353:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1605              		.loc 1 1353 0
 1606 000a 384B     		ldr	r3, .L130
 1607 000c 1B68     		ldr	r3, [r3]
 1608 000e 002B     		cmp	r3, #0
 1609 0010 02D1     		bne	.L119
 1610              		.loc 1 1353 0 is_stmt 0 discriminator 1
 1611 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1612              	.L120:
 1613 0016 FEE7     		b	.L120
 1614              	.L119:
1354:Source/tasks.c **** 
1355:Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1356:Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1357:Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1358:Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1359:Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1360:Source/tasks.c **** 	taskENTER_CRITICAL();
 1615              		.loc 1 1360 0 is_stmt 1
 1616 0018 FFF7FEFF 		bl	vPortEnterCritical
1361:Source/tasks.c **** 	{
1362:Source/tasks.c **** 		--uxSchedulerSuspended;
 1617              		.loc 1 1362 0
 1618 001c 334B     		ldr	r3, .L130
 1619 001e 1B68     		ldr	r3, [r3]
 1620 0020 5A1E     		subs	r2, r3, #1
 1621 0022 324B     		ldr	r3, .L130
 1622 0024 1A60     		str	r2, [r3]
1363:Source/tasks.c **** 
1364:Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1623              		.loc 1 1364 0
 1624 0026 314B     		ldr	r3, .L130
 1625 0028 1B68     		ldr	r3, [r3]
 1626 002a 002B     		cmp	r3, #0
 1627 002c 56D1     		bne	.L121
1365:Source/tasks.c **** 		{
1366:Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1628              		.loc 1 1366 0
 1629 002e 304B     		ldr	r3, .L130+4
 1630 0030 1B68     		ldr	r3, [r3]
 1631 0032 002B     		cmp	r3, #0
 1632 0034 52D0     		beq	.L121
1367:Source/tasks.c **** 			{
1368:Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1369:Source/tasks.c **** 				appropriate ready list. */
1370:Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1633              		.loc 1 1370 0
 1634 0036 2FE0     		b	.L122
 1635              	.L124:
1371:Source/tasks.c **** 				{
1372:Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1636              		.loc 1 1372 0
 1637 0038 2E4B     		ldr	r3, .L130+8
 1638 003a DB68     		ldr	r3, [r3, #12]
 1639 003c DB68     		ldr	r3, [r3, #12]
 1640 003e 3B60     		str	r3, [r7]
1373:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1641              		.loc 1 1373 0
 1642 0040 3B68     		ldr	r3, [r7]
 1643 0042 1833     		adds	r3, r3, #24
 1644 0044 1846     		mov	r0, r3
 1645 0046 FFF7FEFF 		bl	uxListRemove
1374:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1646              		.loc 1 1374 0
 1647 004a 3B68     		ldr	r3, [r7]
 1648 004c 0433     		adds	r3, r3, #4
 1649 004e 1846     		mov	r0, r3
 1650 0050 FFF7FEFF 		bl	uxListRemove
1375:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1651              		.loc 1 1375 0
 1652 0054 3B68     		ldr	r3, [r7]
 1653 0056 DA6A     		ldr	r2, [r3, #44]
 1654 0058 274B     		ldr	r3, .L130+12
 1655 005a 1B68     		ldr	r3, [r3]
 1656 005c 9A42     		cmp	r2, r3
 1657 005e 03D9     		bls	.L123
 1658              		.loc 1 1375 0 is_stmt 0 discriminator 1
 1659 0060 3B68     		ldr	r3, [r7]
 1660 0062 DA6A     		ldr	r2, [r3, #44]
 1661 0064 244B     		ldr	r3, .L130+12
 1662 0066 1A60     		str	r2, [r3]
 1663              	.L123:
 1664              		.loc 1 1375 0 discriminator 2
 1665 0068 3B68     		ldr	r3, [r7]
 1666 006a DA6A     		ldr	r2, [r3, #44]
 1667 006c 1346     		mov	r3, r2
 1668 006e 9B00     		lsls	r3, r3, #2
 1669 0070 1344     		add	r3, r3, r2
 1670 0072 9B00     		lsls	r3, r3, #2
 1671 0074 214A     		ldr	r2, .L130+16
 1672 0076 1A44     		add	r2, r2, r3
 1673 0078 3B68     		ldr	r3, [r7]
 1674 007a 0433     		adds	r3, r3, #4
 1675 007c 1046     		mov	r0, r2
 1676 007e 1946     		mov	r1, r3
 1677 0080 FFF7FEFF 		bl	vListInsertEnd
1376:Source/tasks.c **** 
1377:Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1378:Source/tasks.c **** 					the current task then we should yield. */
1379:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1678              		.loc 1 1379 0 is_stmt 1 discriminator 2
 1679 0084 3B68     		ldr	r3, [r7]
 1680 0086 DA6A     		ldr	r2, [r3, #44]
 1681 0088 1D4B     		ldr	r3, .L130+20
 1682 008a 1B68     		ldr	r3, [r3]
 1683 008c DB6A     		ldr	r3, [r3, #44]
 1684 008e 9A42     		cmp	r2, r3
 1685 0090 02D3     		bcc	.L122
1380:Source/tasks.c **** 					{
1381:Source/tasks.c **** 						xYieldPending = pdTRUE;
 1686              		.loc 1 1381 0
 1687 0092 1C4B     		ldr	r3, .L130+24
 1688 0094 0122     		movs	r2, #1
 1689 0096 1A60     		str	r2, [r3]
 1690              	.L122:
1370:Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1691              		.loc 1 1370 0 discriminator 1
 1692 0098 164B     		ldr	r3, .L130+8
 1693 009a 1B68     		ldr	r3, [r3]
 1694 009c 002B     		cmp	r3, #0
 1695 009e CBD1     		bne	.L124
1382:Source/tasks.c **** 					}
1383:Source/tasks.c **** 				}
1384:Source/tasks.c **** 
1385:Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1386:Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1387:Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1388:Source/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1696              		.loc 1 1388 0
 1697 00a0 194B     		ldr	r3, .L130+28
 1698 00a2 1B68     		ldr	r3, [r3]
 1699 00a4 002B     		cmp	r3, #0
 1700 00a6 11D0     		beq	.L125
1389:Source/tasks.c **** 				{
1390:Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1701              		.loc 1 1390 0
 1702 00a8 0CE0     		b	.L126
 1703              	.L128:
1391:Source/tasks.c **** 					{
1392:Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1704              		.loc 1 1392 0
 1705 00aa FFF7FEFF 		bl	xTaskIncrementTick
 1706 00ae 0346     		mov	r3, r0
 1707 00b0 002B     		cmp	r3, #0
 1708 00b2 02D0     		beq	.L127
1393:Source/tasks.c **** 						{
1394:Source/tasks.c **** 							xYieldPending = pdTRUE;
 1709              		.loc 1 1394 0
 1710 00b4 134B     		ldr	r3, .L130+24
 1711 00b6 0122     		movs	r2, #1
 1712 00b8 1A60     		str	r2, [r3]
 1713              	.L127:
1395:Source/tasks.c **** 						}
1396:Source/tasks.c **** 						--uxPendedTicks;
 1714              		.loc 1 1396 0
 1715 00ba 134B     		ldr	r3, .L130+28
 1716 00bc 1B68     		ldr	r3, [r3]
 1717 00be 5A1E     		subs	r2, r3, #1
 1718 00c0 114B     		ldr	r3, .L130+28
 1719 00c2 1A60     		str	r2, [r3]
 1720              	.L126:
1390:Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1721              		.loc 1 1390 0 discriminator 1
 1722 00c4 104B     		ldr	r3, .L130+28
 1723 00c6 1B68     		ldr	r3, [r3]
 1724 00c8 002B     		cmp	r3, #0
 1725 00ca EED1     		bne	.L128
 1726              	.L125:
1397:Source/tasks.c **** 					}
1398:Source/tasks.c **** 				}
1399:Source/tasks.c **** 
1400:Source/tasks.c **** 				if( xYieldPending == pdTRUE )
 1727              		.loc 1 1400 0
 1728 00cc 0D4B     		ldr	r3, .L130+24
 1729 00ce 1B68     		ldr	r3, [r3]
 1730 00d0 012B     		cmp	r3, #1
 1731 00d2 03D1     		bne	.L121
1401:Source/tasks.c **** 				{
1402:Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1732              		.loc 1 1402 0
 1733 00d4 0123     		movs	r3, #1
 1734 00d6 7B60     		str	r3, [r7, #4]
1403:Source/tasks.c **** 					portYIELD_WITHIN_API();
 1735              		.loc 1 1403 0
 1736 00d8 FFF7FEFF 		bl	vPortYield
 1737              	.L121:
1404:Source/tasks.c **** 				}
1405:Source/tasks.c **** 			}
1406:Source/tasks.c **** 		}
1407:Source/tasks.c **** 	}
1408:Source/tasks.c **** 	taskEXIT_CRITICAL();
 1738              		.loc 1 1408 0
 1739 00dc FFF7FEFF 		bl	vPortExitCritical
1409:Source/tasks.c **** 
1410:Source/tasks.c **** 	return xAlreadyYielded;
 1740              		.loc 1 1410 0
 1741 00e0 7B68     		ldr	r3, [r7, #4]
1411:Source/tasks.c **** }
 1742              		.loc 1 1411 0
 1743 00e2 1846     		mov	r0, r3
 1744 00e4 0837     		adds	r7, r7, #8
 1745 00e6 BD46     		mov	sp, r7
 1746              		@ sp needed
 1747 00e8 80BD     		pop	{r7, pc}
 1748              	.L131:
 1749 00ea 00BF     		.align	2
 1750              	.L130:
 1751 00ec 00000000 		.word	uxSchedulerSuspended
 1752 00f0 00000000 		.word	uxCurrentNumberOfTasks
 1753 00f4 00000000 		.word	xPendingReadyList
 1754 00f8 00000000 		.word	uxTopReadyPriority
 1755 00fc 00000000 		.word	pxReadyTasksLists
 1756 0100 00000000 		.word	pxCurrentTCB
 1757 0104 00000000 		.word	xYieldPending
 1758 0108 00000000 		.word	uxPendedTicks
 1759              		.cfi_endproc
 1760              	.LFE123:
 1762              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1763              		.align	2
 1764              		.global	xTaskGetTickCount
 1765              		.thumb
 1766              		.thumb_func
 1768              	xTaskGetTickCount:
 1769              	.LFB124:
1412:Source/tasks.c **** /*-----------------------------------------------------------*/
1413:Source/tasks.c **** 
1414:Source/tasks.c **** portTickType xTaskGetTickCount( void )
1415:Source/tasks.c **** {
 1770              		.loc 1 1415 0
 1771              		.cfi_startproc
 1772              		@ args = 0, pretend = 0, frame = 8
 1773              		@ frame_needed = 1, uses_anonymous_args = 0
 1774 0000 80B5     		push	{r7, lr}
 1775              	.LCFI40:
 1776              		.cfi_def_cfa_offset 8
 1777              		.cfi_offset 7, -8
 1778              		.cfi_offset 14, -4
 1779 0002 82B0     		sub	sp, sp, #8
 1780              	.LCFI41:
 1781              		.cfi_def_cfa_offset 16
 1782 0004 00AF     		add	r7, sp, #0
 1783              	.LCFI42:
 1784              		.cfi_def_cfa_register 7
1416:Source/tasks.c **** portTickType xTicks;
1417:Source/tasks.c **** 
1418:Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1419:Source/tasks.c **** 	taskENTER_CRITICAL();
 1785              		.loc 1 1419 0
 1786 0006 FFF7FEFF 		bl	vPortEnterCritical
1420:Source/tasks.c **** 	{
1421:Source/tasks.c **** 		xTicks = xTickCount;
 1787              		.loc 1 1421 0
 1788 000a 054B     		ldr	r3, .L134
 1789 000c 1B68     		ldr	r3, [r3]
 1790 000e 7B60     		str	r3, [r7, #4]
1422:Source/tasks.c **** 	}
1423:Source/tasks.c **** 	taskEXIT_CRITICAL();
 1791              		.loc 1 1423 0
 1792 0010 FFF7FEFF 		bl	vPortExitCritical
1424:Source/tasks.c **** 
1425:Source/tasks.c **** 	return xTicks;
 1793              		.loc 1 1425 0
 1794 0014 7B68     		ldr	r3, [r7, #4]
1426:Source/tasks.c **** }
 1795              		.loc 1 1426 0
 1796 0016 1846     		mov	r0, r3
 1797 0018 0837     		adds	r7, r7, #8
 1798 001a BD46     		mov	sp, r7
 1799              		@ sp needed
 1800 001c 80BD     		pop	{r7, pc}
 1801              	.L135:
 1802 001e 00BF     		.align	2
 1803              	.L134:
 1804 0020 00000000 		.word	xTickCount
 1805              		.cfi_endproc
 1806              	.LFE124:
 1808              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1809              		.align	2
 1810              		.global	xTaskGetTickCountFromISR
 1811              		.thumb
 1812              		.thumb_func
 1814              	xTaskGetTickCountFromISR:
 1815              	.LFB125:
1427:Source/tasks.c **** /*-----------------------------------------------------------*/
1428:Source/tasks.c **** 
1429:Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1430:Source/tasks.c **** {
 1816              		.loc 1 1430 0
 1817              		.cfi_startproc
 1818              		@ args = 0, pretend = 0, frame = 8
 1819              		@ frame_needed = 1, uses_anonymous_args = 0
 1820 0000 80B5     		push	{r7, lr}
 1821              	.LCFI43:
 1822              		.cfi_def_cfa_offset 8
 1823              		.cfi_offset 7, -8
 1824              		.cfi_offset 14, -4
 1825 0002 82B0     		sub	sp, sp, #8
 1826              	.LCFI44:
 1827              		.cfi_def_cfa_offset 16
 1828 0004 00AF     		add	r7, sp, #0
 1829              	.LCFI45:
 1830              		.cfi_def_cfa_register 7
1431:Source/tasks.c **** portTickType xReturn;
1432:Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1433:Source/tasks.c **** 
1434:Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1435:Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1436:Source/tasks.c **** 	above the maximum system call priority are keep permanently enabled, even
1437:Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1438:Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1439:Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1440:Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1441:Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1442:Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1443:Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1444:Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1445:Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1446:Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1447:Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1448:Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1831              		.loc 1 1448 0
 1832 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
1449:Source/tasks.c **** 
1450:Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1833              		.loc 1 1450 0
 1834 000a FFF7FEFF 		bl	ulPortSetInterruptMask
 1835 000e 7860     		str	r0, [r7, #4]
1451:Source/tasks.c **** 	xReturn = xTickCount;
 1836              		.loc 1 1451 0
 1837 0010 054B     		ldr	r3, .L138
 1838 0012 1B68     		ldr	r3, [r3]
 1839 0014 3B60     		str	r3, [r7]
1452:Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1840              		.loc 1 1452 0
 1841 0016 7868     		ldr	r0, [r7, #4]
 1842 0018 FFF7FEFF 		bl	vPortClearInterruptMask
1453:Source/tasks.c **** 
1454:Source/tasks.c **** 	return xReturn;
 1843              		.loc 1 1454 0
 1844 001c 3B68     		ldr	r3, [r7]
1455:Source/tasks.c **** }
 1845              		.loc 1 1455 0
 1846 001e 1846     		mov	r0, r3
 1847 0020 0837     		adds	r7, r7, #8
 1848 0022 BD46     		mov	sp, r7
 1849              		@ sp needed
 1850 0024 80BD     		pop	{r7, pc}
 1851              	.L139:
 1852 0026 00BF     		.align	2
 1853              	.L138:
 1854 0028 00000000 		.word	xTickCount
 1855              		.cfi_endproc
 1856              	.LFE125:
 1858              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1859              		.align	2
 1860              		.global	uxTaskGetNumberOfTasks
 1861              		.thumb
 1862              		.thumb_func
 1864              	uxTaskGetNumberOfTasks:
 1865              	.LFB126:
1456:Source/tasks.c **** /*-----------------------------------------------------------*/
1457:Source/tasks.c **** 
1458:Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1459:Source/tasks.c **** {
 1866              		.loc 1 1459 0
 1867              		.cfi_startproc
 1868              		@ args = 0, pretend = 0, frame = 0
 1869              		@ frame_needed = 1, uses_anonymous_args = 0
 1870              		@ link register save eliminated.
 1871 0000 80B4     		push	{r7}
 1872              	.LCFI46:
 1873              		.cfi_def_cfa_offset 4
 1874              		.cfi_offset 7, -4
 1875 0002 00AF     		add	r7, sp, #0
 1876              	.LCFI47:
 1877              		.cfi_def_cfa_register 7
1460:Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1461:Source/tasks.c **** 	portBASE_TYPE. */
1462:Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1878              		.loc 1 1462 0
 1879 0004 034B     		ldr	r3, .L142
 1880 0006 1B68     		ldr	r3, [r3]
1463:Source/tasks.c **** }
 1881              		.loc 1 1463 0
 1882 0008 1846     		mov	r0, r3
 1883 000a BD46     		mov	sp, r7
 1884              		@ sp needed
 1885 000c 5DF8047B 		ldr	r7, [sp], #4
 1886 0010 7047     		bx	lr
 1887              	.L143:
 1888 0012 00BF     		.align	2
 1889              	.L142:
 1890 0014 00000000 		.word	uxCurrentNumberOfTasks
 1891              		.cfi_endproc
 1892              	.LFE126:
 1894              		.section	.text.uxTaskGetSystemState,"ax",%progbits
 1895              		.align	2
 1896              		.global	uxTaskGetSystemState
 1897              		.thumb
 1898              		.thumb_func
 1900              	uxTaskGetSystemState:
 1901              	.LFB127:
1464:Source/tasks.c **** /*-----------------------------------------------------------*/
1465:Source/tasks.c **** 
1466:Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1467:Source/tasks.c **** 
1468:Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1469:Source/tasks.c **** 	{
1470:Source/tasks.c **** 	tskTCB *pxTCB;
1471:Source/tasks.c **** 
1472:Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1473:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1474:Source/tasks.c **** 		configASSERT( pxTCB );
1475:Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1476:Source/tasks.c **** 	}
1477:Source/tasks.c **** 
1478:Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1479:Source/tasks.c **** /*-----------------------------------------------------------*/
1480:Source/tasks.c **** 
1481:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1482:Source/tasks.c **** 
1483:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE
1484:Source/tasks.c **** 	{
 1902              		.loc 1 1484 0
 1903              		.cfi_startproc
 1904              		@ args = 0, pretend = 0, frame = 24
 1905              		@ frame_needed = 1, uses_anonymous_args = 0
 1906 0000 80B5     		push	{r7, lr}
 1907              	.LCFI48:
 1908              		.cfi_def_cfa_offset 8
 1909              		.cfi_offset 7, -8
 1910              		.cfi_offset 14, -4
 1911 0002 86B0     		sub	sp, sp, #24
 1912              	.LCFI49:
 1913              		.cfi_def_cfa_offset 32
 1914 0004 00AF     		add	r7, sp, #0
 1915              	.LCFI50:
 1916              		.cfi_def_cfa_register 7
 1917 0006 F860     		str	r0, [r7, #12]
 1918 0008 B960     		str	r1, [r7, #8]
 1919 000a 7A60     		str	r2, [r7, #4]
1485:Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
 1920              		.loc 1 1485 0
 1921 000c 0023     		movs	r3, #0
 1922 000e 7B61     		str	r3, [r7, #20]
 1923 0010 0523     		movs	r3, #5
 1924 0012 3B61     		str	r3, [r7, #16]
1486:Source/tasks.c **** 
1487:Source/tasks.c **** 		vTaskSuspendAll();
 1925              		.loc 1 1487 0
 1926 0014 FFF7FEFF 		bl	vTaskSuspendAll
1488:Source/tasks.c **** 		{
1489:Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1490:Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
 1927              		.loc 1 1490 0
 1928 0018 314B     		ldr	r3, .L148
 1929 001a 1B68     		ldr	r3, [r3]
 1930 001c BA68     		ldr	r2, [r7, #8]
 1931 001e 9A42     		cmp	r2, r3
 1932 0020 57D3     		bcc	.L145
 1933              	.L146:
1491:Source/tasks.c **** 			{
1492:Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1493:Source/tasks.c **** 				task in the Ready state. */
1494:Source/tasks.c **** 				do
1495:Source/tasks.c **** 				{
1496:Source/tasks.c **** 					uxQueue--;
 1934              		.loc 1 1496 0 discriminator 1
 1935 0022 3B69     		ldr	r3, [r7, #16]
 1936 0024 013B     		subs	r3, r3, #1
 1937 0026 3B61     		str	r3, [r7, #16]
1497:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
 1938              		.loc 1 1497 0 discriminator 1
 1939 0028 7B69     		ldr	r3, [r7, #20]
 1940 002a 5B01     		lsls	r3, r3, #5
 1941 002c FA68     		ldr	r2, [r7, #12]
 1942 002e D118     		adds	r1, r2, r3
 1943 0030 3A69     		ldr	r2, [r7, #16]
 1944 0032 1346     		mov	r3, r2
 1945 0034 9B00     		lsls	r3, r3, #2
 1946 0036 1344     		add	r3, r3, r2
 1947 0038 9B00     		lsls	r3, r3, #2
 1948 003a 2A4A     		ldr	r2, .L148+4
 1949 003c 1344     		add	r3, r3, r2
 1950 003e 0846     		mov	r0, r1
 1951 0040 1946     		mov	r1, r3
 1952 0042 0122     		movs	r2, #1
 1953 0044 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1954 0048 0346     		mov	r3, r0
 1955 004a 7A69     		ldr	r2, [r7, #20]
 1956 004c 1344     		add	r3, r3, r2
 1957 004e 7B61     		str	r3, [r7, #20]
1498:Source/tasks.c **** 
1499:Source/tasks.c **** 				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception 
 1958              		.loc 1 1499 0 discriminator 1
 1959 0050 3B69     		ldr	r3, [r7, #16]
 1960 0052 002B     		cmp	r3, #0
 1961 0054 E5D1     		bne	.L146
1500:Source/tasks.c **** 
1501:Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1502:Source/tasks.c **** 				task in the Blocked state. */
1503:Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedT
 1962              		.loc 1 1503 0
 1963 0056 7B69     		ldr	r3, [r7, #20]
 1964 0058 5B01     		lsls	r3, r3, #5
 1965 005a FA68     		ldr	r2, [r7, #12]
 1966 005c 1A44     		add	r2, r2, r3
 1967 005e 224B     		ldr	r3, .L148+8
 1968 0060 1B68     		ldr	r3, [r3]
 1969 0062 1046     		mov	r0, r2
 1970 0064 1946     		mov	r1, r3
 1971 0066 0222     		movs	r2, #2
 1972 0068 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1973 006c 0346     		mov	r3, r0
 1974 006e 7A69     		ldr	r2, [r7, #20]
 1975 0070 1344     		add	r3, r3, r2
 1976 0072 7B61     		str	r3, [r7, #20]
1504:Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflow
 1977              		.loc 1 1504 0
 1978 0074 7B69     		ldr	r3, [r7, #20]
 1979 0076 5B01     		lsls	r3, r3, #5
 1980 0078 FA68     		ldr	r2, [r7, #12]
 1981 007a 1A44     		add	r2, r2, r3
 1982 007c 1B4B     		ldr	r3, .L148+12
 1983 007e 1B68     		ldr	r3, [r3]
 1984 0080 1046     		mov	r0, r2
 1985 0082 1946     		mov	r1, r3
 1986 0084 0222     		movs	r2, #2
 1987 0086 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1988 008a 0346     		mov	r3, r0
 1989 008c 7A69     		ldr	r2, [r7, #20]
 1990 008e 1344     		add	r3, r3, r2
 1991 0090 7B61     		str	r3, [r7, #20]
1505:Source/tasks.c **** 
1506:Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1507:Source/tasks.c **** 				{
1508:Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1509:Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1510:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
 1992              		.loc 1 1510 0
 1993 0092 7B69     		ldr	r3, [r7, #20]
 1994 0094 5B01     		lsls	r3, r3, #5
 1995 0096 FA68     		ldr	r2, [r7, #12]
 1996 0098 1344     		add	r3, r3, r2
 1997 009a 1846     		mov	r0, r3
 1998 009c 1449     		ldr	r1, .L148+16
 1999 009e 0422     		movs	r2, #4
 2000 00a0 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2001 00a4 0346     		mov	r3, r0
 2002 00a6 7A69     		ldr	r2, [r7, #20]
 2003 00a8 1344     		add	r3, r3, r2
 2004 00aa 7B61     		str	r3, [r7, #20]
1511:Source/tasks.c **** 				}
1512:Source/tasks.c **** 				#endif
1513:Source/tasks.c **** 
1514:Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1515:Source/tasks.c **** 				{
1516:Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1517:Source/tasks.c **** 					each task in the Suspended state. */
1518:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
 2005              		.loc 1 1518 0
 2006 00ac 7B69     		ldr	r3, [r7, #20]
 2007 00ae 5B01     		lsls	r3, r3, #5
 2008 00b0 FA68     		ldr	r2, [r7, #12]
 2009 00b2 1344     		add	r3, r3, r2
 2010 00b4 1846     		mov	r0, r3
 2011 00b6 0F49     		ldr	r1, .L148+20
 2012 00b8 0322     		movs	r2, #3
 2013 00ba FFF7FEFF 		bl	prvListTaskWithinSingleList
 2014 00be 0346     		mov	r3, r0
 2015 00c0 7A69     		ldr	r2, [r7, #20]
 2016 00c2 1344     		add	r3, r3, r2
 2017 00c4 7B61     		str	r3, [r7, #20]
1519:Source/tasks.c **** 				}
1520:Source/tasks.c **** 				#endif
1521:Source/tasks.c **** 
1522:Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1523:Source/tasks.c **** 				{
1524:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1525:Source/tasks.c **** 					{
1526:Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1527:Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1528:Source/tasks.c **** 						#else
1529:Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1530:Source/tasks.c **** 						#endif
1531:Source/tasks.c **** 					}
1532:Source/tasks.c **** 				}
1533:Source/tasks.c **** 				#else
1534:Source/tasks.c **** 				{
1535:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
 2018              		.loc 1 1535 0
 2019 00c6 7B68     		ldr	r3, [r7, #4]
 2020 00c8 002B     		cmp	r3, #0
 2021 00ca 02D0     		beq	.L145
1536:Source/tasks.c **** 					{
1537:Source/tasks.c **** 						*pulTotalRunTime = 0;
 2022              		.loc 1 1537 0
 2023 00cc 7B68     		ldr	r3, [r7, #4]
 2024 00ce 0022     		movs	r2, #0
 2025 00d0 1A60     		str	r2, [r3]
 2026              	.L145:
1538:Source/tasks.c **** 					}
1539:Source/tasks.c **** 				}
1540:Source/tasks.c **** 				#endif
1541:Source/tasks.c **** 			}
1542:Source/tasks.c **** 		}
1543:Source/tasks.c **** 		( void ) xTaskResumeAll();
 2027              		.loc 1 1543 0
 2028 00d2 FFF7FEFF 		bl	xTaskResumeAll
1544:Source/tasks.c **** 
1545:Source/tasks.c **** 		return uxTask;
 2029              		.loc 1 1545 0
 2030 00d6 7B69     		ldr	r3, [r7, #20]
1546:Source/tasks.c **** 	}
 2031              		.loc 1 1546 0
 2032 00d8 1846     		mov	r0, r3
 2033 00da 1837     		adds	r7, r7, #24
 2034 00dc BD46     		mov	sp, r7
 2035              		@ sp needed
 2036 00de 80BD     		pop	{r7, pc}
 2037              	.L149:
 2038              		.align	2
 2039              	.L148:
 2040 00e0 00000000 		.word	uxCurrentNumberOfTasks
 2041 00e4 00000000 		.word	pxReadyTasksLists
 2042 00e8 00000000 		.word	pxDelayedTaskList
 2043 00ec 00000000 		.word	pxOverflowDelayedTaskList
 2044 00f0 00000000 		.word	xTasksWaitingTermination
 2045 00f4 00000000 		.word	xSuspendedTaskList
 2046              		.cfi_endproc
 2047              	.LFE127:
 2049              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2050              		.align	2
 2051              		.global	xTaskIncrementTick
 2052              		.thumb
 2053              		.thumb_func
 2055              	xTaskIncrementTick:
 2056              	.LFB128:
1547:Source/tasks.c **** 
1548:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1549:Source/tasks.c **** /*----------------------------------------------------------*/
1550:Source/tasks.c **** 
1551:Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1552:Source/tasks.c **** 
1553:Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1554:Source/tasks.c **** 	{
1555:Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1556:Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1557:Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1558:Source/tasks.c **** 		return xIdleTaskHandle;
1559:Source/tasks.c **** 	}
1560:Source/tasks.c **** 
1561:Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1562:Source/tasks.c **** /*----------------------------------------------------------*/
1563:Source/tasks.c **** 
1564:Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1565:Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1566:Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1567:Source/tasks.c **** 1. */
1568:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1569:Source/tasks.c **** 
1570:Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1571:Source/tasks.c **** 	{
1572:Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1573:Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1574:Source/tasks.c **** 		each stepped tick. */
1575:Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1576:Source/tasks.c **** 		xTickCount += xTicksToJump;
1577:Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1578:Source/tasks.c **** 	}
1579:Source/tasks.c **** 
1580:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1581:Source/tasks.c **** /*----------------------------------------------------------*/
1582:Source/tasks.c **** 
1583:Source/tasks.c **** portBASE_TYPE xTaskIncrementTick( void )
1584:Source/tasks.c **** {
 2057              		.loc 1 1584 0
 2058              		.cfi_startproc
 2059              		@ args = 0, pretend = 0, frame = 24
 2060              		@ frame_needed = 1, uses_anonymous_args = 0
 2061 0000 80B5     		push	{r7, lr}
 2062              	.LCFI51:
 2063              		.cfi_def_cfa_offset 8
 2064              		.cfi_offset 7, -8
 2065              		.cfi_offset 14, -4
 2066 0002 86B0     		sub	sp, sp, #24
 2067              	.LCFI52:
 2068              		.cfi_def_cfa_offset 32
 2069 0004 00AF     		add	r7, sp, #0
 2070              	.LCFI53:
 2071              		.cfi_def_cfa_register 7
1585:Source/tasks.c **** tskTCB * pxTCB;
1586:Source/tasks.c **** portTickType xItemValue;
1587:Source/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
 2072              		.loc 1 1587 0
 2073 0006 0023     		movs	r3, #0
 2074 0008 7B61     		str	r3, [r7, #20]
1588:Source/tasks.c **** 
1589:Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1590:Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1591:Source/tasks.c **** 	tasks to be unblocked. */
1592:Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1593:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2075              		.loc 1 1593 0
 2076 000a 5D4B     		ldr	r3, .L172
 2077 000c 1B68     		ldr	r3, [r3]
 2078 000e 002B     		cmp	r3, #0
 2079 0010 40F0A480 		bne	.L151
1594:Source/tasks.c **** 	{
1595:Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1596:Source/tasks.c **** 		delayed lists if it wraps to 0. */
1597:Source/tasks.c **** 		++xTickCount;
 2080              		.loc 1 1597 0
 2081 0014 5B4B     		ldr	r3, .L172+4
 2082 0016 1B68     		ldr	r3, [r3]
 2083 0018 5A1C     		adds	r2, r3, #1
 2084 001a 5A4B     		ldr	r3, .L172+4
 2085 001c 1A60     		str	r2, [r3]
 2086              	.LBB4:
1598:Source/tasks.c **** 
1599:Source/tasks.c **** 		{
1600:Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1601:Source/tasks.c **** 			block. */
1602:Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 2087              		.loc 1 1602 0
 2088 001e 594B     		ldr	r3, .L172+4
 2089 0020 1B68     		ldr	r3, [r3]
 2090 0022 3B61     		str	r3, [r7, #16]
1603:Source/tasks.c **** 
1604:Source/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
 2091              		.loc 1 1604 0
 2092 0024 3B69     		ldr	r3, [r7, #16]
 2093 0026 002B     		cmp	r3, #0
 2094 0028 2ED1     		bne	.L152
 2095              	.LBB5:
1605:Source/tasks.c **** 			{
1606:Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 2096              		.loc 1 1606 0
 2097 002a 574B     		ldr	r3, .L172+8
 2098 002c 1B68     		ldr	r3, [r3]
 2099 002e 1B68     		ldr	r3, [r3]
 2100 0030 002B     		cmp	r3, #0
 2101 0032 02D0     		beq	.L153
 2102              		.loc 1 1606 0 is_stmt 0 discriminator 1
 2103 0034 FFF7FEFF 		bl	ulPortSetInterruptMask
 2104              	.L154:
 2105 0038 FEE7     		b	.L154
 2106              	.L153:
 2107              		.loc 1 1606 0 discriminator 2
 2108 003a 534B     		ldr	r3, .L172+8
 2109 003c 1B68     		ldr	r3, [r3]
 2110 003e FB60     		str	r3, [r7, #12]
 2111 0040 524B     		ldr	r3, .L172+12
 2112 0042 1A68     		ldr	r2, [r3]
 2113 0044 504B     		ldr	r3, .L172+8
 2114 0046 1A60     		str	r2, [r3]
 2115 0048 504B     		ldr	r3, .L172+12
 2116 004a FA68     		ldr	r2, [r7, #12]
 2117 004c 1A60     		str	r2, [r3]
 2118 004e 504B     		ldr	r3, .L172+16
 2119 0050 1B68     		ldr	r3, [r3]
 2120 0052 5A1C     		adds	r2, r3, #1
 2121 0054 4E4B     		ldr	r3, .L172+16
 2122 0056 1A60     		str	r2, [r3]
 2123 0058 4B4B     		ldr	r3, .L172+8
 2124 005a 1B68     		ldr	r3, [r3]
 2125 005c 1B68     		ldr	r3, [r3]
 2126 005e 002B     		cmp	r3, #0
 2127 0060 01D1     		bne	.L155
 2128              		.loc 1 1606 0 discriminator 1
 2129 0062 0123     		movs	r3, #1
 2130 0064 00E0     		b	.L156
 2131              	.L155:
 2132              		.loc 1 1606 0 discriminator 2
 2133 0066 0023     		movs	r3, #0
 2134              	.L156:
 2135              		.loc 1 1606 0 discriminator 3
 2136 0068 002B     		cmp	r3, #0
 2137 006a 04D0     		beq	.L157
 2138              		.loc 1 1606 0 discriminator 1
 2139 006c 494B     		ldr	r3, .L172+20
 2140 006e 4FF0FF32 		mov	r2, #-1
 2141 0072 1A60     		str	r2, [r3]
 2142 0074 08E0     		b	.L152
 2143              	.L157:
 2144              		.loc 1 1606 0 discriminator 2
 2145 0076 444B     		ldr	r3, .L172+8
 2146 0078 1B68     		ldr	r3, [r3]
 2147 007a DB68     		ldr	r3, [r3, #12]
 2148 007c DB68     		ldr	r3, [r3, #12]
 2149 007e BB60     		str	r3, [r7, #8]
 2150 0080 BB68     		ldr	r3, [r7, #8]
 2151 0082 5A68     		ldr	r2, [r3, #4]
 2152 0084 434B     		ldr	r3, .L172+20
 2153 0086 1A60     		str	r2, [r3]
 2154              	.L152:
 2155              	.LBE5:
1607:Source/tasks.c **** 			}
1608:Source/tasks.c **** 
1609:Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in the
1610:Source/tasks.c **** 			queue in the order of their wake time - meaning once one tasks has been
1611:Source/tasks.c **** 			found whose block time has not expired there is no need not look any
1612:Source/tasks.c **** 			further	down the list. */
1613:Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 2156              		.loc 1 1613 0 is_stmt 1
 2157 0088 424B     		ldr	r3, .L172+20
 2158 008a 1B68     		ldr	r3, [r3]
 2159 008c 3A69     		ldr	r2, [r7, #16]
 2160 008e 9A42     		cmp	r2, r3
 2161 0090 4FD3     		bcc	.L158
 2162              	.L166:
1614:Source/tasks.c **** 			{
1615:Source/tasks.c **** 				for( ;; )
1616:Source/tasks.c **** 				{
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2163              		.loc 1 1617 0
 2164 0092 3D4B     		ldr	r3, .L172+8
 2165 0094 1B68     		ldr	r3, [r3]
 2166 0096 1B68     		ldr	r3, [r3]
 2167 0098 002B     		cmp	r3, #0
 2168 009a 01D1     		bne	.L159
 2169              		.loc 1 1617 0 is_stmt 0 discriminator 1
 2170 009c 0123     		movs	r3, #1
 2171 009e 00E0     		b	.L160
 2172              	.L159:
 2173              		.loc 1 1617 0 discriminator 2
 2174 00a0 0023     		movs	r3, #0
 2175              	.L160:
 2176              		.loc 1 1617 0 discriminator 3
 2177 00a2 002B     		cmp	r3, #0
 2178 00a4 04D0     		beq	.L161
1618:Source/tasks.c **** 					{
1619:Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime to
1620:Source/tasks.c **** 						the	maximum possible value so it is extremely unlikely that
1621:Source/tasks.c **** 						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
1622:Source/tasks.c **** 						next time through. */
1623:Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 2179              		.loc 1 1623 0 is_stmt 1
 2180 00a6 3B4B     		ldr	r3, .L172+20
 2181 00a8 4FF0FF32 		mov	r2, #-1
 2182 00ac 1A60     		str	r2, [r3]
1624:Source/tasks.c **** 						break;
 2183              		.loc 1 1624 0
 2184 00ae 40E0     		b	.L158
 2185              	.L161:
1625:Source/tasks.c **** 					}
1626:Source/tasks.c **** 					else
1627:Source/tasks.c **** 					{
1628:Source/tasks.c **** 						/* The delayed list is not empty, get the value of the item
1629:Source/tasks.c **** 						at the head of the delayed list.  This is the time at which
1630:Source/tasks.c **** 						the task at the head of the delayed list must be removed
1631:Source/tasks.c **** 						from the Blocked state. */
1632:Source/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2186              		.loc 1 1632 0
 2187 00b0 354B     		ldr	r3, .L172+8
 2188 00b2 1B68     		ldr	r3, [r3]
 2189 00b4 DB68     		ldr	r3, [r3, #12]
 2190 00b6 DB68     		ldr	r3, [r3, #12]
 2191 00b8 BB60     		str	r3, [r7, #8]
1633:Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2192              		.loc 1 1633 0
 2193 00ba BB68     		ldr	r3, [r7, #8]
 2194 00bc 5B68     		ldr	r3, [r3, #4]
 2195 00be 7B60     		str	r3, [r7, #4]
1634:Source/tasks.c **** 
1635:Source/tasks.c **** 						if( xConstTickCount < xItemValue )
 2196              		.loc 1 1635 0
 2197 00c0 3A69     		ldr	r2, [r7, #16]
 2198 00c2 7B68     		ldr	r3, [r7, #4]
 2199 00c4 9A42     		cmp	r2, r3
 2200 00c6 03D2     		bcs	.L162
1636:Source/tasks.c **** 						{
1637:Source/tasks.c **** 							/* It is not time to unblock this item yet, but the item
1638:Source/tasks.c **** 							value is the time at which the task at the head of the
1639:Source/tasks.c **** 							blocked list must be removed from the Blocked state -
1640:Source/tasks.c **** 							so record the item value in xNextTaskUnblockTime. */
1641:Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 2201              		.loc 1 1641 0
 2202 00c8 324B     		ldr	r3, .L172+20
 2203 00ca 7A68     		ldr	r2, [r7, #4]
 2204 00cc 1A60     		str	r2, [r3]
1642:Source/tasks.c **** 							break;
 2205              		.loc 1 1642 0
 2206 00ce 30E0     		b	.L158
 2207              	.L162:
1643:Source/tasks.c **** 						}
1644:Source/tasks.c **** 
1645:Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1646:Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2208              		.loc 1 1646 0
 2209 00d0 BB68     		ldr	r3, [r7, #8]
 2210 00d2 0433     		adds	r3, r3, #4
 2211 00d4 1846     		mov	r0, r3
 2212 00d6 FFF7FEFF 		bl	uxListRemove
1647:Source/tasks.c **** 
1648:Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove it
1649:Source/tasks.c **** 						from the event list. */
1650:Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2213              		.loc 1 1650 0
 2214 00da BB68     		ldr	r3, [r7, #8]
 2215 00dc 9B6A     		ldr	r3, [r3, #40]
 2216 00de 002B     		cmp	r3, #0
 2217 00e0 04D0     		beq	.L163
1651:Source/tasks.c **** 						{
1652:Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2218              		.loc 1 1652 0
 2219 00e2 BB68     		ldr	r3, [r7, #8]
 2220 00e4 1833     		adds	r3, r3, #24
 2221 00e6 1846     		mov	r0, r3
 2222 00e8 FFF7FEFF 		bl	uxListRemove
 2223              	.L163:
1653:Source/tasks.c **** 						}
1654:Source/tasks.c **** 
1655:Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1656:Source/tasks.c **** 						list. */
1657:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2224              		.loc 1 1657 0
 2225 00ec BB68     		ldr	r3, [r7, #8]
 2226 00ee DA6A     		ldr	r2, [r3, #44]
 2227 00f0 294B     		ldr	r3, .L172+24
 2228 00f2 1B68     		ldr	r3, [r3]
 2229 00f4 9A42     		cmp	r2, r3
 2230 00f6 03D9     		bls	.L164
 2231              		.loc 1 1657 0 is_stmt 0 discriminator 1
 2232 00f8 BB68     		ldr	r3, [r7, #8]
 2233 00fa DA6A     		ldr	r2, [r3, #44]
 2234 00fc 264B     		ldr	r3, .L172+24
 2235 00fe 1A60     		str	r2, [r3]
 2236              	.L164:
 2237              		.loc 1 1657 0 discriminator 2
 2238 0100 BB68     		ldr	r3, [r7, #8]
 2239 0102 DA6A     		ldr	r2, [r3, #44]
 2240 0104 1346     		mov	r3, r2
 2241 0106 9B00     		lsls	r3, r3, #2
 2242 0108 1344     		add	r3, r3, r2
 2243 010a 9B00     		lsls	r3, r3, #2
 2244 010c 234A     		ldr	r2, .L172+28
 2245 010e 1A44     		add	r2, r2, r3
 2246 0110 BB68     		ldr	r3, [r7, #8]
 2247 0112 0433     		adds	r3, r3, #4
 2248 0114 1046     		mov	r0, r2
 2249 0116 1946     		mov	r1, r3
 2250 0118 FFF7FEFF 		bl	vListInsertEnd
1658:Source/tasks.c **** 
1659:Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate context
1660:Source/tasks.c **** 						switch if preemption is turned off. */
1661:Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1662:Source/tasks.c **** 						{
1663:Source/tasks.c **** 							/* Preemption is on, but a context switch should only
1664:Source/tasks.c **** 							be performed if the unblocked task has a priority that
1665:Source/tasks.c **** 							is equal to or higher than the currently executing
1666:Source/tasks.c **** 							task. */
1667:Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2251              		.loc 1 1667 0 is_stmt 1 discriminator 2
 2252 011c BB68     		ldr	r3, [r7, #8]
 2253 011e DA6A     		ldr	r2, [r3, #44]
 2254 0120 1F4B     		ldr	r3, .L172+32
 2255 0122 1B68     		ldr	r3, [r3]
 2256 0124 DB6A     		ldr	r3, [r3, #44]
 2257 0126 9A42     		cmp	r2, r3
 2258 0128 02D3     		bcc	.L165
1668:Source/tasks.c **** 							{
1669:Source/tasks.c **** 								xSwitchRequired = pdTRUE;
 2259              		.loc 1 1669 0
 2260 012a 0123     		movs	r3, #1
 2261 012c 7B61     		str	r3, [r7, #20]
1670:Source/tasks.c **** 							}
1671:Source/tasks.c **** 						}
1672:Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1673:Source/tasks.c **** 					}
1674:Source/tasks.c **** 				}
 2262              		.loc 1 1674 0
 2263 012e B0E7     		b	.L166
 2264              	.L165:
 2265 0130 AFE7     		b	.L166
 2266              	.L158:
 2267              	.LBE4:
1675:Source/tasks.c **** 			}
1676:Source/tasks.c **** 		}
1677:Source/tasks.c **** 
1678:Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1679:Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1680:Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
1681:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1682:Source/tasks.c **** 		{
1683:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
 2268              		.loc 1 1683 0
 2269 0132 1B4B     		ldr	r3, .L172+32
 2270 0134 1B68     		ldr	r3, [r3]
 2271 0136 DA6A     		ldr	r2, [r3, #44]
 2272 0138 1849     		ldr	r1, .L172+28
 2273 013a 1346     		mov	r3, r2
 2274 013c 9B00     		lsls	r3, r3, #2
 2275 013e 1344     		add	r3, r3, r2
 2276 0140 9B00     		lsls	r3, r3, #2
 2277 0142 0B44     		add	r3, r3, r1
 2278 0144 1B68     		ldr	r3, [r3]
 2279 0146 012B     		cmp	r3, #1
 2280 0148 01D9     		bls	.L167
1684:Source/tasks.c **** 			{
1685:Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2281              		.loc 1 1685 0
 2282 014a 0123     		movs	r3, #1
 2283 014c 7B61     		str	r3, [r7, #20]
 2284              	.L167:
1686:Source/tasks.c **** 			}
1687:Source/tasks.c **** 		}
1688:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1689:Source/tasks.c **** 		
1690:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1691:Source/tasks.c **** 		{
1692:Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1693:Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1694:Source/tasks.c **** 			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
 2285              		.loc 1 1694 0
 2286 014e 154B     		ldr	r3, .L172+36
 2287 0150 1B68     		ldr	r3, [r3]
 2288 0152 002B     		cmp	r3, #0
 2289 0154 09D1     		bne	.L169
1695:Source/tasks.c **** 			{
1696:Source/tasks.c **** 				vApplicationTickHook();
 2290              		.loc 1 1696 0
 2291 0156 FFF7FEFF 		bl	vApplicationTickHook
 2292 015a 06E0     		b	.L169
 2293              	.L151:
1697:Source/tasks.c **** 			}
1698:Source/tasks.c **** 		}
1699:Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */		
1700:Source/tasks.c **** 	}
1701:Source/tasks.c **** 	else
1702:Source/tasks.c **** 	{
1703:Source/tasks.c **** 		++uxPendedTicks;
 2294              		.loc 1 1703 0
 2295 015c 114B     		ldr	r3, .L172+36
 2296 015e 1B68     		ldr	r3, [r3]
 2297 0160 5A1C     		adds	r2, r3, #1
 2298 0162 104B     		ldr	r3, .L172+36
 2299 0164 1A60     		str	r2, [r3]
1704:Source/tasks.c **** 
1705:Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1706:Source/tasks.c **** 		scheduler is locked. */
1707:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1708:Source/tasks.c **** 		{
1709:Source/tasks.c **** 			vApplicationTickHook();
 2300              		.loc 1 1709 0
 2301 0166 FFF7FEFF 		bl	vApplicationTickHook
 2302              	.L169:
1710:Source/tasks.c **** 		}
1711:Source/tasks.c **** 		#endif
1712:Source/tasks.c **** 	}
1713:Source/tasks.c **** 
1714:Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
1715:Source/tasks.c **** 	{
1716:Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 2303              		.loc 1 1716 0
 2304 016a 0F4B     		ldr	r3, .L172+40
 2305 016c 1B68     		ldr	r3, [r3]
 2306 016e 002B     		cmp	r3, #0
 2307 0170 01D0     		beq	.L170
1717:Source/tasks.c **** 		{
1718:Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 2308              		.loc 1 1718 0
 2309 0172 0123     		movs	r3, #1
 2310 0174 7B61     		str	r3, [r7, #20]
 2311              	.L170:
1719:Source/tasks.c **** 		}
1720:Source/tasks.c **** 	}
1721:Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
1722:Source/tasks.c **** 
1723:Source/tasks.c **** 	return xSwitchRequired;
 2312              		.loc 1 1723 0
 2313 0176 7B69     		ldr	r3, [r7, #20]
1724:Source/tasks.c **** }
 2314              		.loc 1 1724 0
 2315 0178 1846     		mov	r0, r3
 2316 017a 1837     		adds	r7, r7, #24
 2317 017c BD46     		mov	sp, r7
 2318              		@ sp needed
 2319 017e 80BD     		pop	{r7, pc}
 2320              	.L173:
 2321              		.align	2
 2322              	.L172:
 2323 0180 00000000 		.word	uxSchedulerSuspended
 2324 0184 00000000 		.word	xTickCount
 2325 0188 00000000 		.word	pxDelayedTaskList
 2326 018c 00000000 		.word	pxOverflowDelayedTaskList
 2327 0190 00000000 		.word	xNumOfOverflows
 2328 0194 00000000 		.word	xNextTaskUnblockTime
 2329 0198 00000000 		.word	uxTopReadyPriority
 2330 019c 00000000 		.word	pxReadyTasksLists
 2331 01a0 00000000 		.word	pxCurrentTCB
 2332 01a4 00000000 		.word	uxPendedTicks
 2333 01a8 00000000 		.word	xYieldPending
 2334              		.cfi_endproc
 2335              	.LFE128:
 2337              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2338              		.align	2
 2339              		.global	vTaskSwitchContext
 2340              		.thumb
 2341              		.thumb_func
 2343              	vTaskSwitchContext:
 2344              	.LFB129:
1725:Source/tasks.c **** /*-----------------------------------------------------------*/
1726:Source/tasks.c **** 
1727:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1728:Source/tasks.c **** 
1729:Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1730:Source/tasks.c **** 	{
1731:Source/tasks.c **** 	tskTCB *xTCB;
1732:Source/tasks.c **** 
1733:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1734:Source/tasks.c **** 		if( xTask == NULL )
1735:Source/tasks.c **** 		{
1736:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1737:Source/tasks.c **** 		}
1738:Source/tasks.c **** 		else
1739:Source/tasks.c **** 		{
1740:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1741:Source/tasks.c **** 		}
1742:Source/tasks.c **** 
1743:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1744:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1745:Source/tasks.c **** 		taskENTER_CRITICAL();
1746:Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1747:Source/tasks.c **** 		taskEXIT_CRITICAL();
1748:Source/tasks.c **** 	}
1749:Source/tasks.c **** 
1750:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1751:Source/tasks.c **** /*-----------------------------------------------------------*/
1752:Source/tasks.c **** 
1753:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1754:Source/tasks.c **** 
1755:Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1756:Source/tasks.c **** 	{
1757:Source/tasks.c **** 	tskTCB *xTCB;
1758:Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1759:Source/tasks.c **** 
1760:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1761:Source/tasks.c **** 		if( xTask == NULL )
1762:Source/tasks.c **** 		{
1763:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1764:Source/tasks.c **** 		}
1765:Source/tasks.c **** 		else
1766:Source/tasks.c **** 		{
1767:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1768:Source/tasks.c **** 		}
1769:Source/tasks.c **** 
1770:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1771:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1772:Source/tasks.c **** 		taskENTER_CRITICAL();
1773:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1774:Source/tasks.c **** 		taskEXIT_CRITICAL();
1775:Source/tasks.c **** 
1776:Source/tasks.c **** 		return xReturn;
1777:Source/tasks.c **** 	}
1778:Source/tasks.c **** 
1779:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1780:Source/tasks.c **** /*-----------------------------------------------------------*/
1781:Source/tasks.c **** 
1782:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1783:Source/tasks.c **** 
1784:Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1785:Source/tasks.c **** 	{
1786:Source/tasks.c **** 	tskTCB *xTCB;
1787:Source/tasks.c **** 	portBASE_TYPE xReturn;
1788:Source/tasks.c **** 
1789:Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1790:Source/tasks.c **** 		if( xTask == NULL )
1791:Source/tasks.c **** 		{
1792:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1793:Source/tasks.c **** 		}
1794:Source/tasks.c **** 		else
1795:Source/tasks.c **** 		{
1796:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1797:Source/tasks.c **** 		}
1798:Source/tasks.c **** 
1799:Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1800:Source/tasks.c **** 		{
1801:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1802:Source/tasks.c **** 		}
1803:Source/tasks.c **** 		else
1804:Source/tasks.c **** 		{
1805:Source/tasks.c **** 			xReturn = pdFAIL;
1806:Source/tasks.c **** 		}
1807:Source/tasks.c **** 
1808:Source/tasks.c **** 		return xReturn;
1809:Source/tasks.c **** 	}
1810:Source/tasks.c **** 
1811:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1812:Source/tasks.c **** /*-----------------------------------------------------------*/
1813:Source/tasks.c **** 
1814:Source/tasks.c **** void vTaskSwitchContext( void )
1815:Source/tasks.c **** {
 2345              		.loc 1 1815 0
 2346              		.cfi_startproc
 2347              		@ args = 0, pretend = 0, frame = 8
 2348              		@ frame_needed = 1, uses_anonymous_args = 0
 2349 0000 80B5     		push	{r7, lr}
 2350              	.LCFI54:
 2351              		.cfi_def_cfa_offset 8
 2352              		.cfi_offset 7, -8
 2353              		.cfi_offset 14, -4
 2354 0002 82B0     		sub	sp, sp, #8
 2355              	.LCFI55:
 2356              		.cfi_def_cfa_offset 16
 2357 0004 00AF     		add	r7, sp, #0
 2358              	.LCFI56:
 2359              		.cfi_def_cfa_register 7
1816:Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2360              		.loc 1 1816 0
 2361 0006 354B     		ldr	r3, .L184
 2362 0008 1B68     		ldr	r3, [r3]
 2363 000a 002B     		cmp	r3, #0
 2364 000c 03D0     		beq	.L175
1817:Source/tasks.c **** 	{
1818:Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1819:Source/tasks.c **** 		switch. */
1820:Source/tasks.c **** 		xYieldPending = pdTRUE;
 2365              		.loc 1 1820 0
 2366 000e 344B     		ldr	r3, .L184+4
 2367 0010 0122     		movs	r2, #1
 2368 0012 1A60     		str	r2, [r3]
 2369 0014 5EE0     		b	.L174
 2370              	.L175:
1821:Source/tasks.c **** 	}
1822:Source/tasks.c **** 	else
1823:Source/tasks.c **** 	{
1824:Source/tasks.c **** 		xYieldPending = pdFALSE;
 2371              		.loc 1 1824 0
 2372 0016 324B     		ldr	r3, .L184+4
 2373 0018 0022     		movs	r2, #0
 2374 001a 1A60     		str	r2, [r3]
1825:Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1826:Source/tasks.c **** 
1827:Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1828:Source/tasks.c **** 		{
1829:Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1830:Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1831:Source/tasks.c **** 				#else
1832:Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1833:Source/tasks.c **** 				#endif
1834:Source/tasks.c **** 
1835:Source/tasks.c **** 				/* Add the amount of time the task has been running to the
1836:Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
1837:Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
1838:Source/tasks.c **** 				protection here	so count values are only valid until the timer
1839:Source/tasks.c **** 				overflows.  The guard against negative values is to protect
1840:Source/tasks.c **** 				against suspect run time stat counter implementations - which
1841:Source/tasks.c **** 				are provided by the application, not the kernel. */
1842:Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
1843:Source/tasks.c **** 				{
1844:Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1845:Source/tasks.c **** 				}
1846:Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
1847:Source/tasks.c **** 		}
1848:Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
1849:Source/tasks.c **** 
1850:Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2375              		.loc 1 1850 0
 2376 001c 314B     		ldr	r3, .L184+8
 2377 001e 1B68     		ldr	r3, [r3]
 2378 0020 1A68     		ldr	r2, [r3]
 2379 0022 304B     		ldr	r3, .L184+8
 2380 0024 1B68     		ldr	r3, [r3]
 2381 0026 1B6B     		ldr	r3, [r3, #48]
 2382 0028 9A42     		cmp	r2, r3
 2383 002a 08D8     		bhi	.L177
 2384              		.loc 1 1850 0 is_stmt 0 discriminator 1
 2385 002c 2D4B     		ldr	r3, .L184+8
 2386 002e 1A68     		ldr	r2, [r3]
 2387 0030 2C4B     		ldr	r3, .L184+8
 2388 0032 1B68     		ldr	r3, [r3]
 2389 0034 3433     		adds	r3, r3, #52
 2390 0036 1046     		mov	r0, r2
 2391 0038 1946     		mov	r1, r3
 2392 003a FFF7FEFF 		bl	vApplicationStackOverflowHook
 2393              	.L177:
 2394              	.LBB6:
1851:Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 2395              		.loc 1 1851 0 is_stmt 1
 2396 003e 294B     		ldr	r3, .L184+8
 2397 0040 1B68     		ldr	r3, [r3]
 2398 0042 1B6B     		ldr	r3, [r3, #48]
 2399 0044 1846     		mov	r0, r3
 2400 0046 2849     		ldr	r1, .L184+12
 2401 0048 1422     		movs	r2, #20
 2402 004a FFF7FEFF 		bl	memcmp
 2403 004e 0346     		mov	r3, r0
 2404 0050 002B     		cmp	r3, #0
 2405 0052 09D0     		beq	.L178
 2406              		.loc 1 1851 0 is_stmt 0 discriminator 1
 2407 0054 234B     		ldr	r3, .L184+8
 2408 0056 1A68     		ldr	r2, [r3]
 2409 0058 224B     		ldr	r3, .L184+8
 2410 005a 1B68     		ldr	r3, [r3]
 2411 005c 3433     		adds	r3, r3, #52
 2412 005e 1046     		mov	r0, r2
 2413 0060 1946     		mov	r1, r3
 2414 0062 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2415              	.LBE6:
1852:Source/tasks.c **** 
1853:Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2416              		.loc 1 1853 0 is_stmt 1 discriminator 1
 2417 0066 0CE0     		b	.L179
 2418              	.L178:
 2419              		.loc 1 1853 0 is_stmt 0
 2420 0068 0BE0     		b	.L179
 2421              	.L182:
 2422              		.loc 1 1853 0 discriminator 2
 2423 006a 204B     		ldr	r3, .L184+16
 2424 006c 1B68     		ldr	r3, [r3]
 2425 006e 002B     		cmp	r3, #0
 2426 0070 02D1     		bne	.L180
 2427              		.loc 1 1853 0 discriminator 1
 2428 0072 FFF7FEFF 		bl	ulPortSetInterruptMask
 2429              	.L181:
 2430 0076 FEE7     		b	.L181
 2431              	.L180:
 2432              		.loc 1 1853 0 discriminator 2
 2433 0078 1C4B     		ldr	r3, .L184+16
 2434 007a 1B68     		ldr	r3, [r3]
 2435 007c 5A1E     		subs	r2, r3, #1
 2436 007e 1B4B     		ldr	r3, .L184+16
 2437 0080 1A60     		str	r2, [r3]
 2438              	.L179:
 2439              		.loc 1 1853 0 discriminator 1
 2440 0082 1A4B     		ldr	r3, .L184+16
 2441 0084 1A68     		ldr	r2, [r3]
 2442 0086 1A49     		ldr	r1, .L184+20
 2443 0088 1346     		mov	r3, r2
 2444 008a 9B00     		lsls	r3, r3, #2
 2445 008c 1344     		add	r3, r3, r2
 2446 008e 9B00     		lsls	r3, r3, #2
 2447 0090 0B44     		add	r3, r3, r1
 2448 0092 1B68     		ldr	r3, [r3]
 2449 0094 002B     		cmp	r3, #0
 2450 0096 E8D0     		beq	.L182
 2451              	.LBB7:
 2452              		.loc 1 1853 0 discriminator 3
 2453 0098 144B     		ldr	r3, .L184+16
 2454 009a 1A68     		ldr	r2, [r3]
 2455 009c 1346     		mov	r3, r2
 2456 009e 9B00     		lsls	r3, r3, #2
 2457 00a0 1344     		add	r3, r3, r2
 2458 00a2 9B00     		lsls	r3, r3, #2
 2459 00a4 124A     		ldr	r2, .L184+20
 2460 00a6 1344     		add	r3, r3, r2
 2461 00a8 7B60     		str	r3, [r7, #4]
 2462 00aa 7B68     		ldr	r3, [r7, #4]
 2463 00ac 5B68     		ldr	r3, [r3, #4]
 2464 00ae 5A68     		ldr	r2, [r3, #4]
 2465 00b0 7B68     		ldr	r3, [r7, #4]
 2466 00b2 5A60     		str	r2, [r3, #4]
 2467 00b4 7B68     		ldr	r3, [r7, #4]
 2468 00b6 5A68     		ldr	r2, [r3, #4]
 2469 00b8 7B68     		ldr	r3, [r7, #4]
 2470 00ba 0833     		adds	r3, r3, #8
 2471 00bc 9A42     		cmp	r2, r3
 2472 00be 04D1     		bne	.L183
 2473              		.loc 1 1853 0 discriminator 1
 2474 00c0 7B68     		ldr	r3, [r7, #4]
 2475 00c2 5B68     		ldr	r3, [r3, #4]
 2476 00c4 5A68     		ldr	r2, [r3, #4]
 2477 00c6 7B68     		ldr	r3, [r7, #4]
 2478 00c8 5A60     		str	r2, [r3, #4]
 2479              	.L183:
 2480              		.loc 1 1853 0 discriminator 2
 2481 00ca 7B68     		ldr	r3, [r7, #4]
 2482 00cc 5B68     		ldr	r3, [r3, #4]
 2483 00ce DA68     		ldr	r2, [r3, #12]
 2484 00d0 044B     		ldr	r3, .L184+8
 2485 00d2 1A60     		str	r2, [r3]
 2486              	.L174:
 2487              	.LBE7:
1854:Source/tasks.c **** 
1855:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1856:Source/tasks.c **** 
1857:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1858:Source/tasks.c **** 		{
1859:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1860:Source/tasks.c **** 			structure specific to this task. */
1861:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1862:Source/tasks.c **** 		}
1863:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1864:Source/tasks.c **** 	}
1865:Source/tasks.c **** }
 2488              		.loc 1 1865 0 is_stmt 1
 2489 00d4 0837     		adds	r7, r7, #8
 2490 00d6 BD46     		mov	sp, r7
 2491              		@ sp needed
 2492 00d8 80BD     		pop	{r7, pc}
 2493              	.L185:
 2494 00da 00BF     		.align	2
 2495              	.L184:
 2496 00dc 00000000 		.word	uxSchedulerSuspended
 2497 00e0 00000000 		.word	xYieldPending
 2498 00e4 00000000 		.word	pxCurrentTCB
 2499 00e8 00000000 		.word	ucExpectedStackBytes.8469
 2500 00ec 00000000 		.word	uxTopReadyPriority
 2501 00f0 00000000 		.word	pxReadyTasksLists
 2502              		.cfi_endproc
 2503              	.LFE129:
 2505              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2506              		.align	2
 2507              		.global	vTaskPlaceOnEventList
 2508              		.thumb
 2509              		.thumb_func
 2511              	vTaskPlaceOnEventList:
 2512              	.LFB130:
1866:Source/tasks.c **** /*-----------------------------------------------------------*/
1867:Source/tasks.c **** 
1868:Source/tasks.c **** void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
1869:Source/tasks.c **** {
 2513              		.loc 1 1869 0
 2514              		.cfi_startproc
 2515              		@ args = 0, pretend = 0, frame = 16
 2516              		@ frame_needed = 1, uses_anonymous_args = 0
 2517 0000 80B5     		push	{r7, lr}
 2518              	.LCFI57:
 2519              		.cfi_def_cfa_offset 8
 2520              		.cfi_offset 7, -8
 2521              		.cfi_offset 14, -4
 2522 0002 84B0     		sub	sp, sp, #16
 2523              	.LCFI58:
 2524              		.cfi_def_cfa_offset 24
 2525 0004 00AF     		add	r7, sp, #0
 2526              	.LCFI59:
 2527              		.cfi_def_cfa_register 7
 2528 0006 7860     		str	r0, [r7, #4]
 2529 0008 3960     		str	r1, [r7]
1870:Source/tasks.c **** portTickType xTimeToWake;
1871:Source/tasks.c **** 
1872:Source/tasks.c **** 	configASSERT( pxEventList );
 2530              		.loc 1 1872 0
 2531 000a 7B68     		ldr	r3, [r7, #4]
 2532 000c 002B     		cmp	r3, #0
 2533 000e 02D1     		bne	.L187
 2534              		.loc 1 1872 0 is_stmt 0 discriminator 1
 2535 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2536              	.L188:
 2537 0014 FEE7     		b	.L188
 2538              	.L187:
1873:Source/tasks.c **** 
1874:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1875:Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1876:Source/tasks.c **** 
1877:Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1878:Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1879:Source/tasks.c **** 	is the first to be woken by the event. */
1880:Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2539              		.loc 1 1880 0 is_stmt 1
 2540 0016 124B     		ldr	r3, .L191
 2541 0018 1B68     		ldr	r3, [r3]
 2542 001a 1833     		adds	r3, r3, #24
 2543 001c 7868     		ldr	r0, [r7, #4]
 2544 001e 1946     		mov	r1, r3
 2545 0020 FFF7FEFF 		bl	vListInsert
1881:Source/tasks.c **** 
1882:Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1883:Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1884:Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1885:Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 2546              		.loc 1 1885 0
 2547 0024 0E4B     		ldr	r3, .L191
 2548 0026 1B68     		ldr	r3, [r3]
 2549 0028 0433     		adds	r3, r3, #4
 2550 002a 1846     		mov	r0, r3
 2551 002c FFF7FEFF 		bl	uxListRemove
1886:Source/tasks.c **** 	{
1887:Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1888:Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1889:Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1890:Source/tasks.c **** 	}
1891:Source/tasks.c **** 
1892:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1893:Source/tasks.c **** 	{
1894:Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2552              		.loc 1 1894 0
 2553 0030 3B68     		ldr	r3, [r7]
 2554 0032 B3F1FF3F 		cmp	r3, #-1
 2555 0036 07D1     		bne	.L189
1895:Source/tasks.c **** 		{
1896:Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1897:Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1898:Source/tasks.c **** 			indefinitely. */
1899:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2556              		.loc 1 1899 0
 2557 0038 094B     		ldr	r3, .L191
 2558 003a 1B68     		ldr	r3, [r3]
 2559 003c 0433     		adds	r3, r3, #4
 2560 003e 0948     		ldr	r0, .L191+4
 2561 0040 1946     		mov	r1, r3
 2562 0042 FFF7FEFF 		bl	vListInsertEnd
 2563 0046 07E0     		b	.L186
 2564              	.L189:
1900:Source/tasks.c **** 		}
1901:Source/tasks.c **** 		else
1902:Source/tasks.c **** 		{
1903:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1904:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1905:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2565              		.loc 1 1905 0
 2566 0048 074B     		ldr	r3, .L191+8
 2567 004a 1A68     		ldr	r2, [r3]
 2568 004c 3B68     		ldr	r3, [r7]
 2569 004e 1344     		add	r3, r3, r2
 2570 0050 FB60     		str	r3, [r7, #12]
1906:Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2571              		.loc 1 1906 0
 2572 0052 F868     		ldr	r0, [r7, #12]
 2573 0054 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2574              	.L186:
1907:Source/tasks.c **** 		}
1908:Source/tasks.c **** 	}
1909:Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
1910:Source/tasks.c **** 	{
1911:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1912:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1913:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1914:Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1915:Source/tasks.c **** 	}
1916:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
1917:Source/tasks.c **** }
 2575              		.loc 1 1917 0
 2576 0058 1037     		adds	r7, r7, #16
 2577 005a BD46     		mov	sp, r7
 2578              		@ sp needed
 2579 005c 80BD     		pop	{r7, pc}
 2580              	.L192:
 2581 005e 00BF     		.align	2
 2582              	.L191:
 2583 0060 00000000 		.word	pxCurrentTCB
 2584 0064 00000000 		.word	xSuspendedTaskList
 2585 0068 00000000 		.word	xTickCount
 2586              		.cfi_endproc
 2587              	.LFE130:
 2589              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2590              		.align	2
 2591              		.global	vTaskPlaceOnEventListRestricted
 2592              		.thumb
 2593              		.thumb_func
 2595              	vTaskPlaceOnEventListRestricted:
 2596              	.LFB131:
1918:Source/tasks.c **** /*-----------------------------------------------------------*/
1919:Source/tasks.c **** 
1920:Source/tasks.c **** #if configUSE_TIMERS == 1
1921:Source/tasks.c **** 
1922:Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
1923:Source/tasks.c **** 	{
 2597              		.loc 1 1923 0
 2598              		.cfi_startproc
 2599              		@ args = 0, pretend = 0, frame = 16
 2600              		@ frame_needed = 1, uses_anonymous_args = 0
 2601 0000 80B5     		push	{r7, lr}
 2602              	.LCFI60:
 2603              		.cfi_def_cfa_offset 8
 2604              		.cfi_offset 7, -8
 2605              		.cfi_offset 14, -4
 2606 0002 84B0     		sub	sp, sp, #16
 2607              	.LCFI61:
 2608              		.cfi_def_cfa_offset 24
 2609 0004 00AF     		add	r7, sp, #0
 2610              	.LCFI62:
 2611              		.cfi_def_cfa_register 7
 2612 0006 7860     		str	r0, [r7, #4]
 2613 0008 3960     		str	r1, [r7]
1924:Source/tasks.c **** 	portTickType xTimeToWake;
1925:Source/tasks.c **** 
1926:Source/tasks.c **** 		configASSERT( pxEventList );
 2614              		.loc 1 1926 0
 2615 000a 7B68     		ldr	r3, [r7, #4]
 2616 000c 002B     		cmp	r3, #0
 2617 000e 02D1     		bne	.L194
 2618              		.loc 1 1926 0 is_stmt 0 discriminator 1
 2619 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2620              	.L195:
 2621 0014 FEE7     		b	.L195
 2622              	.L194:
1927:Source/tasks.c **** 
1928:Source/tasks.c **** 		/* This function should not be called by application code hence the
1929:Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1930:Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1931:Source/tasks.c **** 		it should be called from a critical section. */
1932:Source/tasks.c **** 
1933:Source/tasks.c **** 
1934:Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1935:Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1936:Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1937:Source/tasks.c **** 		can be used in place of vListInsert. */
1938:Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2623              		.loc 1 1938 0 is_stmt 1
 2624 0016 0C4B     		ldr	r3, .L196
 2625 0018 1B68     		ldr	r3, [r3]
 2626 001a 1833     		adds	r3, r3, #24
 2627 001c 7868     		ldr	r0, [r7, #4]
 2628 001e 1946     		mov	r1, r3
 2629 0020 FFF7FEFF 		bl	vListInsertEnd
1939:Source/tasks.c **** 
1940:Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1941:Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1942:Source/tasks.c **** 		function is called form a critical section. */
1943:Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 2630              		.loc 1 1943 0
 2631 0024 084B     		ldr	r3, .L196
 2632 0026 1B68     		ldr	r3, [r3]
 2633 0028 0433     		adds	r3, r3, #4
 2634 002a 1846     		mov	r0, r3
 2635 002c FFF7FEFF 		bl	uxListRemove
1944:Source/tasks.c **** 		{
1945:Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1946:Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1947:Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1948:Source/tasks.c **** 		}
1949:Source/tasks.c **** 
1950:Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1951:Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1952:Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2636              		.loc 1 1952 0
 2637 0030 064B     		ldr	r3, .L196+4
 2638 0032 1A68     		ldr	r2, [r3]
 2639 0034 3B68     		ldr	r3, [r7]
 2640 0036 1344     		add	r3, r3, r2
 2641 0038 FB60     		str	r3, [r7, #12]
1953:Source/tasks.c **** 
1954:Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1955:Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2642              		.loc 1 1955 0
 2643 003a F868     		ldr	r0, [r7, #12]
 2644 003c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1956:Source/tasks.c **** 	}
 2645              		.loc 1 1956 0
 2646 0040 1037     		adds	r7, r7, #16
 2647 0042 BD46     		mov	sp, r7
 2648              		@ sp needed
 2649 0044 80BD     		pop	{r7, pc}
 2650              	.L197:
 2651 0046 00BF     		.align	2
 2652              	.L196:
 2653 0048 00000000 		.word	pxCurrentTCB
 2654 004c 00000000 		.word	xTickCount
 2655              		.cfi_endproc
 2656              	.LFE131:
 2658              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2659              		.align	2
 2660              		.global	xTaskRemoveFromEventList
 2661              		.thumb
 2662              		.thumb_func
 2664              	xTaskRemoveFromEventList:
 2665              	.LFB132:
1957:Source/tasks.c **** 
1958:Source/tasks.c **** #endif /* configUSE_TIMERS */
1959:Source/tasks.c **** /*-----------------------------------------------------------*/
1960:Source/tasks.c **** 
1961:Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1962:Source/tasks.c **** {
 2666              		.loc 1 1962 0
 2667              		.cfi_startproc
 2668              		@ args = 0, pretend = 0, frame = 16
 2669              		@ frame_needed = 1, uses_anonymous_args = 0
 2670 0000 80B5     		push	{r7, lr}
 2671              	.LCFI63:
 2672              		.cfi_def_cfa_offset 8
 2673              		.cfi_offset 7, -8
 2674              		.cfi_offset 14, -4
 2675 0002 84B0     		sub	sp, sp, #16
 2676              	.LCFI64:
 2677              		.cfi_def_cfa_offset 24
 2678 0004 00AF     		add	r7, sp, #0
 2679              	.LCFI65:
 2680              		.cfi_def_cfa_register 7
 2681 0006 7860     		str	r0, [r7, #4]
1963:Source/tasks.c **** tskTCB *pxUnblockedTCB;
1964:Source/tasks.c **** portBASE_TYPE xReturn;
1965:Source/tasks.c **** 
1966:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1967:Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1968:Source/tasks.c **** 
1969:Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1970:Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1971:Source/tasks.c **** 	it to the ready list.
1972:Source/tasks.c **** 
1973:Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1974:Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1975:Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1976:Source/tasks.c **** 
1977:Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1978:Source/tasks.c **** 	pxEventList is not empty. */
1979:Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2682              		.loc 1 1979 0
 2683 0008 7B68     		ldr	r3, [r7, #4]
 2684 000a DB68     		ldr	r3, [r3, #12]
 2685 000c DB68     		ldr	r3, [r3, #12]
 2686 000e BB60     		str	r3, [r7, #8]
1980:Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2687              		.loc 1 1980 0
 2688 0010 BB68     		ldr	r3, [r7, #8]
 2689 0012 002B     		cmp	r3, #0
 2690 0014 02D1     		bne	.L199
 2691              		.loc 1 1980 0 is_stmt 0 discriminator 1
 2692 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 2693              	.L200:
 2694 001a FEE7     		b	.L200
 2695              	.L199:
1981:Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2696              		.loc 1 1981 0 is_stmt 1
 2697 001c BB68     		ldr	r3, [r7, #8]
 2698 001e 1833     		adds	r3, r3, #24
 2699 0020 1846     		mov	r0, r3
 2700 0022 FFF7FEFF 		bl	uxListRemove
1982:Source/tasks.c **** 
1983:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2701              		.loc 1 1983 0
 2702 0026 1E4B     		ldr	r3, .L207
 2703 0028 1B68     		ldr	r3, [r3]
 2704 002a 002B     		cmp	r3, #0
 2705 002c 1DD1     		bne	.L201
1984:Source/tasks.c **** 	{
1985:Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2706              		.loc 1 1985 0
 2707 002e BB68     		ldr	r3, [r7, #8]
 2708 0030 0433     		adds	r3, r3, #4
 2709 0032 1846     		mov	r0, r3
 2710 0034 FFF7FEFF 		bl	uxListRemove
1986:Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2711              		.loc 1 1986 0
 2712 0038 BB68     		ldr	r3, [r7, #8]
 2713 003a DA6A     		ldr	r2, [r3, #44]
 2714 003c 194B     		ldr	r3, .L207+4
 2715 003e 1B68     		ldr	r3, [r3]
 2716 0040 9A42     		cmp	r2, r3
 2717 0042 03D9     		bls	.L202
 2718              		.loc 1 1986 0 is_stmt 0 discriminator 1
 2719 0044 BB68     		ldr	r3, [r7, #8]
 2720 0046 DA6A     		ldr	r2, [r3, #44]
 2721 0048 164B     		ldr	r3, .L207+4
 2722 004a 1A60     		str	r2, [r3]
 2723              	.L202:
 2724              		.loc 1 1986 0 discriminator 2
 2725 004c BB68     		ldr	r3, [r7, #8]
 2726 004e DA6A     		ldr	r2, [r3, #44]
 2727 0050 1346     		mov	r3, r2
 2728 0052 9B00     		lsls	r3, r3, #2
 2729 0054 1344     		add	r3, r3, r2
 2730 0056 9B00     		lsls	r3, r3, #2
 2731 0058 134A     		ldr	r2, .L207+8
 2732 005a 1A44     		add	r2, r2, r3
 2733 005c BB68     		ldr	r3, [r7, #8]
 2734 005e 0433     		adds	r3, r3, #4
 2735 0060 1046     		mov	r0, r2
 2736 0062 1946     		mov	r1, r3
 2737 0064 FFF7FEFF 		bl	vListInsertEnd
 2738 0068 05E0     		b	.L203
 2739              	.L201:
1987:Source/tasks.c **** 	}
1988:Source/tasks.c **** 	else
1989:Source/tasks.c **** 	{
1990:Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1991:Source/tasks.c **** 		task pending until the scheduler is resumed. */
1992:Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2740              		.loc 1 1992 0 is_stmt 1
 2741 006a BB68     		ldr	r3, [r7, #8]
 2742 006c 1833     		adds	r3, r3, #24
 2743 006e 0F48     		ldr	r0, .L207+12
 2744 0070 1946     		mov	r1, r3
 2745 0072 FFF7FEFF 		bl	vListInsertEnd
 2746              	.L203:
1993:Source/tasks.c **** 	}
1994:Source/tasks.c **** 
1995:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2747              		.loc 1 1995 0
 2748 0076 BB68     		ldr	r3, [r7, #8]
 2749 0078 DA6A     		ldr	r2, [r3, #44]
 2750 007a 0D4B     		ldr	r3, .L207+16
 2751 007c 1B68     		ldr	r3, [r3]
 2752 007e DB6A     		ldr	r3, [r3, #44]
 2753 0080 9A42     		cmp	r2, r3
 2754 0082 05D3     		bcc	.L204
1996:Source/tasks.c **** 	{
1997:Source/tasks.c **** 		/* Return true if the task removed from the event list has
1998:Source/tasks.c **** 		a higher priority than the calling task.  This allows
1999:Source/tasks.c **** 		the calling task to know if it should force a context
2000:Source/tasks.c **** 		switch now. */
2001:Source/tasks.c **** 		xReturn = pdTRUE;
 2755              		.loc 1 2001 0
 2756 0084 0123     		movs	r3, #1
 2757 0086 FB60     		str	r3, [r7, #12]
2002:Source/tasks.c **** 
2003:Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2004:Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2005:Source/tasks.c **** 		xYieldPending = pdTRUE;
 2758              		.loc 1 2005 0
 2759 0088 0A4B     		ldr	r3, .L207+20
 2760 008a 0122     		movs	r2, #1
 2761 008c 1A60     		str	r2, [r3]
 2762 008e 01E0     		b	.L205
 2763              	.L204:
2006:Source/tasks.c **** 	}
2007:Source/tasks.c **** 	else
2008:Source/tasks.c **** 	{
2009:Source/tasks.c **** 		xReturn = pdFALSE;
 2764              		.loc 1 2009 0
 2765 0090 0023     		movs	r3, #0
 2766 0092 FB60     		str	r3, [r7, #12]
 2767              	.L205:
2010:Source/tasks.c **** 	}
2011:Source/tasks.c **** 
2012:Source/tasks.c **** 	return xReturn;
 2768              		.loc 1 2012 0
 2769 0094 FB68     		ldr	r3, [r7, #12]
2013:Source/tasks.c **** }
 2770              		.loc 1 2013 0
 2771 0096 1846     		mov	r0, r3
 2772 0098 1037     		adds	r7, r7, #16
 2773 009a BD46     		mov	sp, r7
 2774              		@ sp needed
 2775 009c 80BD     		pop	{r7, pc}
 2776              	.L208:
 2777 009e 00BF     		.align	2
 2778              	.L207:
 2779 00a0 00000000 		.word	uxSchedulerSuspended
 2780 00a4 00000000 		.word	uxTopReadyPriority
 2781 00a8 00000000 		.word	pxReadyTasksLists
 2782 00ac 00000000 		.word	xPendingReadyList
 2783 00b0 00000000 		.word	pxCurrentTCB
 2784 00b4 00000000 		.word	xYieldPending
 2785              		.cfi_endproc
 2786              	.LFE132:
 2788              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2789              		.align	2
 2790              		.global	vTaskSetTimeOutState
 2791              		.thumb
 2792              		.thumb_func
 2794              	vTaskSetTimeOutState:
 2795              	.LFB133:
2014:Source/tasks.c **** /*-----------------------------------------------------------*/
2015:Source/tasks.c **** 
2016:Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2017:Source/tasks.c **** {
 2796              		.loc 1 2017 0
 2797              		.cfi_startproc
 2798              		@ args = 0, pretend = 0, frame = 8
 2799              		@ frame_needed = 1, uses_anonymous_args = 0
 2800 0000 80B5     		push	{r7, lr}
 2801              	.LCFI66:
 2802              		.cfi_def_cfa_offset 8
 2803              		.cfi_offset 7, -8
 2804              		.cfi_offset 14, -4
 2805 0002 82B0     		sub	sp, sp, #8
 2806              	.LCFI67:
 2807              		.cfi_def_cfa_offset 16
 2808 0004 00AF     		add	r7, sp, #0
 2809              	.LCFI68:
 2810              		.cfi_def_cfa_register 7
 2811 0006 7860     		str	r0, [r7, #4]
2018:Source/tasks.c **** 	configASSERT( pxTimeOut );
 2812              		.loc 1 2018 0
 2813 0008 7B68     		ldr	r3, [r7, #4]
 2814 000a 002B     		cmp	r3, #0
 2815 000c 02D1     		bne	.L210
 2816              		.loc 1 2018 0 is_stmt 0 discriminator 1
 2817 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2818              	.L211:
 2819 0012 FEE7     		b	.L211
 2820              	.L210:
2019:Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2821              		.loc 1 2019 0 is_stmt 1
 2822 0014 054B     		ldr	r3, .L212
 2823 0016 1A68     		ldr	r2, [r3]
 2824 0018 7B68     		ldr	r3, [r7, #4]
 2825 001a 1A60     		str	r2, [r3]
2020:Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2826              		.loc 1 2020 0
 2827 001c 044B     		ldr	r3, .L212+4
 2828 001e 1A68     		ldr	r2, [r3]
 2829 0020 7B68     		ldr	r3, [r7, #4]
 2830 0022 5A60     		str	r2, [r3, #4]
2021:Source/tasks.c **** }
 2831              		.loc 1 2021 0
 2832 0024 0837     		adds	r7, r7, #8
 2833 0026 BD46     		mov	sp, r7
 2834              		@ sp needed
 2835 0028 80BD     		pop	{r7, pc}
 2836              	.L213:
 2837 002a 00BF     		.align	2
 2838              	.L212:
 2839 002c 00000000 		.word	xNumOfOverflows
 2840 0030 00000000 		.word	xTickCount
 2841              		.cfi_endproc
 2842              	.LFE133:
 2844              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2845              		.align	2
 2846              		.global	xTaskCheckForTimeOut
 2847              		.thumb
 2848              		.thumb_func
 2850              	xTaskCheckForTimeOut:
 2851              	.LFB134:
2022:Source/tasks.c **** /*-----------------------------------------------------------*/
2023:Source/tasks.c **** 
2024:Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2025:Source/tasks.c **** {
 2852              		.loc 1 2025 0
 2853              		.cfi_startproc
 2854              		@ args = 0, pretend = 0, frame = 16
 2855              		@ frame_needed = 1, uses_anonymous_args = 0
 2856 0000 80B5     		push	{r7, lr}
 2857              	.LCFI69:
 2858              		.cfi_def_cfa_offset 8
 2859              		.cfi_offset 7, -8
 2860              		.cfi_offset 14, -4
 2861 0002 84B0     		sub	sp, sp, #16
 2862              	.LCFI70:
 2863              		.cfi_def_cfa_offset 24
 2864 0004 00AF     		add	r7, sp, #0
 2865              	.LCFI71:
 2866              		.cfi_def_cfa_register 7
 2867 0006 7860     		str	r0, [r7, #4]
 2868 0008 3960     		str	r1, [r7]
2026:Source/tasks.c **** portBASE_TYPE xReturn;
2027:Source/tasks.c **** 
2028:Source/tasks.c **** 	configASSERT( pxTimeOut );
 2869              		.loc 1 2028 0
 2870 000a 7B68     		ldr	r3, [r7, #4]
 2871 000c 002B     		cmp	r3, #0
 2872 000e 02D1     		bne	.L215
 2873              		.loc 1 2028 0 is_stmt 0 discriminator 1
 2874 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2875              	.L216:
 2876 0014 FEE7     		b	.L216
 2877              	.L215:
2029:Source/tasks.c **** 	configASSERT( pxTicksToWait );
 2878              		.loc 1 2029 0 is_stmt 1
 2879 0016 3B68     		ldr	r3, [r7]
 2880 0018 002B     		cmp	r3, #0
 2881 001a 02D1     		bne	.L217
 2882              		.loc 1 2029 0 is_stmt 0 discriminator 1
 2883 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 2884              	.L218:
 2885 0020 FEE7     		b	.L218
 2886              	.L217:
2030:Source/tasks.c **** 
2031:Source/tasks.c **** 	taskENTER_CRITICAL();
 2887              		.loc 1 2031 0 is_stmt 1
 2888 0022 FFF7FEFF 		bl	vPortEnterCritical
 2889              	.LBB8:
2032:Source/tasks.c **** 	{
2033:Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2034:Source/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
 2890              		.loc 1 2034 0
 2891 0026 1C4B     		ldr	r3, .L224
 2892 0028 1B68     		ldr	r3, [r3]
 2893 002a BB60     		str	r3, [r7, #8]
2035:Source/tasks.c **** 
2036:Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2037:Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2038:Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2039:Source/tasks.c **** 			therefore never time out. */
2040:Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2894              		.loc 1 2040 0
 2895 002c 3B68     		ldr	r3, [r7]
 2896 002e 1B68     		ldr	r3, [r3]
 2897 0030 B3F1FF3F 		cmp	r3, #-1
 2898 0034 02D1     		bne	.L219
2041:Source/tasks.c **** 			{
2042:Source/tasks.c **** 				xReturn = pdFALSE;
 2899              		.loc 1 2042 0
 2900 0036 0023     		movs	r3, #0
 2901 0038 FB60     		str	r3, [r7, #12]
 2902 003a 26E0     		b	.L220
 2903              	.L219:
2043:Source/tasks.c **** 			}
2044:Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2045:Source/tasks.c **** 		#endif
2046:Source/tasks.c **** 
2047:Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2904              		.loc 1 2047 0
 2905 003c 7B68     		ldr	r3, [r7, #4]
 2906 003e 1A68     		ldr	r2, [r3]
 2907 0040 164B     		ldr	r3, .L224+4
 2908 0042 1B68     		ldr	r3, [r3]
 2909 0044 9A42     		cmp	r2, r3
 2910 0046 07D0     		beq	.L221
 2911              		.loc 1 2047 0 is_stmt 0 discriminator 1
 2912 0048 7B68     		ldr	r3, [r7, #4]
 2913 004a 5A68     		ldr	r2, [r3, #4]
 2914 004c BB68     		ldr	r3, [r7, #8]
 2915 004e 9A42     		cmp	r2, r3
 2916 0050 02D8     		bhi	.L221
2048:Source/tasks.c **** 		{
2049:Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2050:Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2051:Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2052:Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2053:Source/tasks.c **** 			xReturn = pdTRUE;
 2917              		.loc 1 2053 0 is_stmt 1
 2918 0052 0123     		movs	r3, #1
 2919 0054 FB60     		str	r3, [r7, #12]
 2920 0056 18E0     		b	.L220
 2921              	.L221:
2054:Source/tasks.c **** 		}
2055:Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2922              		.loc 1 2055 0
 2923 0058 7B68     		ldr	r3, [r7, #4]
 2924 005a 5B68     		ldr	r3, [r3, #4]
 2925 005c BA68     		ldr	r2, [r7, #8]
 2926 005e D21A     		subs	r2, r2, r3
 2927 0060 3B68     		ldr	r3, [r7]
 2928 0062 1B68     		ldr	r3, [r3]
 2929 0064 9A42     		cmp	r2, r3
 2930 0066 0ED2     		bcs	.L222
2056:Source/tasks.c **** 		{
2057:Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2058:Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2931              		.loc 1 2058 0
 2932 0068 3B68     		ldr	r3, [r7]
 2933 006a 1A68     		ldr	r2, [r3]
 2934 006c 7B68     		ldr	r3, [r7, #4]
 2935 006e 5968     		ldr	r1, [r3, #4]
 2936 0070 BB68     		ldr	r3, [r7, #8]
 2937 0072 CB1A     		subs	r3, r1, r3
 2938 0074 1A44     		add	r2, r2, r3
 2939 0076 3B68     		ldr	r3, [r7]
 2940 0078 1A60     		str	r2, [r3]
2059:Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2941              		.loc 1 2059 0
 2942 007a 7868     		ldr	r0, [r7, #4]
 2943 007c FFF7FEFF 		bl	vTaskSetTimeOutState
2060:Source/tasks.c **** 			xReturn = pdFALSE;
 2944              		.loc 1 2060 0
 2945 0080 0023     		movs	r3, #0
 2946 0082 FB60     		str	r3, [r7, #12]
 2947 0084 01E0     		b	.L220
 2948              	.L222:
2061:Source/tasks.c **** 		}
2062:Source/tasks.c **** 		else
2063:Source/tasks.c **** 		{
2064:Source/tasks.c **** 			xReturn = pdTRUE;
 2949              		.loc 1 2064 0
 2950 0086 0123     		movs	r3, #1
 2951 0088 FB60     		str	r3, [r7, #12]
 2952              	.L220:
 2953              	.LBE8:
2065:Source/tasks.c **** 		}
2066:Source/tasks.c **** 	}
2067:Source/tasks.c **** 	taskEXIT_CRITICAL();
 2954              		.loc 1 2067 0
 2955 008a FFF7FEFF 		bl	vPortExitCritical
2068:Source/tasks.c **** 
2069:Source/tasks.c **** 	return xReturn;
 2956              		.loc 1 2069 0
 2957 008e FB68     		ldr	r3, [r7, #12]
2070:Source/tasks.c **** }
 2958              		.loc 1 2070 0
 2959 0090 1846     		mov	r0, r3
 2960 0092 1037     		adds	r7, r7, #16
 2961 0094 BD46     		mov	sp, r7
 2962              		@ sp needed
 2963 0096 80BD     		pop	{r7, pc}
 2964              	.L225:
 2965              		.align	2
 2966              	.L224:
 2967 0098 00000000 		.word	xTickCount
 2968 009c 00000000 		.word	xNumOfOverflows
 2969              		.cfi_endproc
 2970              	.LFE134:
 2972              		.section	.text.vTaskMissedYield,"ax",%progbits
 2973              		.align	2
 2974              		.global	vTaskMissedYield
 2975              		.thumb
 2976              		.thumb_func
 2978              	vTaskMissedYield:
 2979              	.LFB135:
2071:Source/tasks.c **** /*-----------------------------------------------------------*/
2072:Source/tasks.c **** 
2073:Source/tasks.c **** void vTaskMissedYield( void )
2074:Source/tasks.c **** {
 2980              		.loc 1 2074 0
 2981              		.cfi_startproc
 2982              		@ args = 0, pretend = 0, frame = 0
 2983              		@ frame_needed = 1, uses_anonymous_args = 0
 2984              		@ link register save eliminated.
 2985 0000 80B4     		push	{r7}
 2986              	.LCFI72:
 2987              		.cfi_def_cfa_offset 4
 2988              		.cfi_offset 7, -4
 2989 0002 00AF     		add	r7, sp, #0
 2990              	.LCFI73:
 2991              		.cfi_def_cfa_register 7
2075:Source/tasks.c **** 	xYieldPending = pdTRUE;
 2992              		.loc 1 2075 0
 2993 0004 034B     		ldr	r3, .L227
 2994 0006 0122     		movs	r2, #1
 2995 0008 1A60     		str	r2, [r3]
2076:Source/tasks.c **** }
 2996              		.loc 1 2076 0
 2997 000a BD46     		mov	sp, r7
 2998              		@ sp needed
 2999 000c 5DF8047B 		ldr	r7, [sp], #4
 3000 0010 7047     		bx	lr
 3001              	.L228:
 3002 0012 00BF     		.align	2
 3003              	.L227:
 3004 0014 00000000 		.word	xYieldPending
 3005              		.cfi_endproc
 3006              	.LFE135:
 3008              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 3009              		.align	2
 3010              		.global	uxTaskGetTaskNumber
 3011              		.thumb
 3012              		.thumb_func
 3014              	uxTaskGetTaskNumber:
 3015              	.LFB136:
2077:Source/tasks.c **** /*-----------------------------------------------------------*/
2078:Source/tasks.c **** 
2079:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2080:Source/tasks.c **** 
2081:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2082:Source/tasks.c **** 	{
 3016              		.loc 1 2082 0
 3017              		.cfi_startproc
 3018              		@ args = 0, pretend = 0, frame = 16
 3019              		@ frame_needed = 1, uses_anonymous_args = 0
 3020              		@ link register save eliminated.
 3021 0000 80B4     		push	{r7}
 3022              	.LCFI74:
 3023              		.cfi_def_cfa_offset 4
 3024              		.cfi_offset 7, -4
 3025 0002 85B0     		sub	sp, sp, #20
 3026              	.LCFI75:
 3027              		.cfi_def_cfa_offset 24
 3028 0004 00AF     		add	r7, sp, #0
 3029              	.LCFI76:
 3030              		.cfi_def_cfa_register 7
 3031 0006 7860     		str	r0, [r7, #4]
2083:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2084:Source/tasks.c **** 	tskTCB *pxTCB;
2085:Source/tasks.c **** 
2086:Source/tasks.c **** 		if( xTask != NULL )
 3032              		.loc 1 2086 0
 3033 0008 7B68     		ldr	r3, [r7, #4]
 3034 000a 002B     		cmp	r3, #0
 3035 000c 05D0     		beq	.L230
2087:Source/tasks.c **** 		{
2088:Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3036              		.loc 1 2088 0
 3037 000e 7B68     		ldr	r3, [r7, #4]
 3038 0010 BB60     		str	r3, [r7, #8]
2089:Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 3039              		.loc 1 2089 0
 3040 0012 BB68     		ldr	r3, [r7, #8]
 3041 0014 5B6C     		ldr	r3, [r3, #68]
 3042 0016 FB60     		str	r3, [r7, #12]
 3043 0018 01E0     		b	.L231
 3044              	.L230:
2090:Source/tasks.c **** 		}
2091:Source/tasks.c **** 		else
2092:Source/tasks.c **** 		{
2093:Source/tasks.c **** 			uxReturn = 0U;
 3045              		.loc 1 2093 0
 3046 001a 0023     		movs	r3, #0
 3047 001c FB60     		str	r3, [r7, #12]
 3048              	.L231:
2094:Source/tasks.c **** 		}
2095:Source/tasks.c **** 
2096:Source/tasks.c **** 		return uxReturn;
 3049              		.loc 1 2096 0
 3050 001e FB68     		ldr	r3, [r7, #12]
2097:Source/tasks.c **** 	}
 3051              		.loc 1 2097 0
 3052 0020 1846     		mov	r0, r3
 3053 0022 1437     		adds	r7, r7, #20
 3054 0024 BD46     		mov	sp, r7
 3055              		@ sp needed
 3056 0026 5DF8047B 		ldr	r7, [sp], #4
 3057 002a 7047     		bx	lr
 3058              		.cfi_endproc
 3059              	.LFE136:
 3061              		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3062              		.align	2
 3063              		.global	vTaskSetTaskNumber
 3064              		.thumb
 3065              		.thumb_func
 3067              	vTaskSetTaskNumber:
 3068              	.LFB137:
2098:Source/tasks.c **** 
2099:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2100:Source/tasks.c **** /*-----------------------------------------------------------*/
2101:Source/tasks.c **** 
2102:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2103:Source/tasks.c **** 
2104:Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2105:Source/tasks.c **** 	{
 3069              		.loc 1 2105 0
 3070              		.cfi_startproc
 3071              		@ args = 0, pretend = 0, frame = 16
 3072              		@ frame_needed = 1, uses_anonymous_args = 0
 3073              		@ link register save eliminated.
 3074 0000 80B4     		push	{r7}
 3075              	.LCFI77:
 3076              		.cfi_def_cfa_offset 4
 3077              		.cfi_offset 7, -4
 3078 0002 85B0     		sub	sp, sp, #20
 3079              	.LCFI78:
 3080              		.cfi_def_cfa_offset 24
 3081 0004 00AF     		add	r7, sp, #0
 3082              	.LCFI79:
 3083              		.cfi_def_cfa_register 7
 3084 0006 7860     		str	r0, [r7, #4]
 3085 0008 3960     		str	r1, [r7]
2106:Source/tasks.c **** 	tskTCB *pxTCB;
2107:Source/tasks.c **** 
2108:Source/tasks.c **** 		if( xTask != NULL )
 3086              		.loc 1 2108 0
 3087 000a 7B68     		ldr	r3, [r7, #4]
 3088 000c 002B     		cmp	r3, #0
 3089 000e 04D0     		beq	.L233
2109:Source/tasks.c **** 		{
2110:Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3090              		.loc 1 2110 0
 3091 0010 7B68     		ldr	r3, [r7, #4]
 3092 0012 FB60     		str	r3, [r7, #12]
2111:Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 3093              		.loc 1 2111 0
 3094 0014 FB68     		ldr	r3, [r7, #12]
 3095 0016 3A68     		ldr	r2, [r7]
 3096 0018 5A64     		str	r2, [r3, #68]
 3097              	.L233:
2112:Source/tasks.c **** 		}
2113:Source/tasks.c **** 	}
 3098              		.loc 1 2113 0
 3099 001a 1437     		adds	r7, r7, #20
 3100 001c BD46     		mov	sp, r7
 3101              		@ sp needed
 3102 001e 5DF8047B 		ldr	r7, [sp], #4
 3103 0022 7047     		bx	lr
 3104              		.cfi_endproc
 3105              	.LFE137:
 3107              		.section	.text.prvIdleTask,"ax",%progbits
 3108              		.align	2
 3109              		.thumb
 3110              		.thumb_func
 3112              	prvIdleTask:
 3113              	.LFB138:
2114:Source/tasks.c **** 
2115:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2116:Source/tasks.c **** 
2117:Source/tasks.c **** /*
2118:Source/tasks.c ****  * -----------------------------------------------------------
2119:Source/tasks.c ****  * The Idle task.
2120:Source/tasks.c ****  * ----------------------------------------------------------
2121:Source/tasks.c ****  *
2122:Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2123:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2124:Source/tasks.c ****  *
2125:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2126:Source/tasks.c ****  *
2127:Source/tasks.c ****  */
2128:Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2129:Source/tasks.c **** {
 3114              		.loc 1 2129 0
 3115              		.cfi_startproc
 3116              		@ args = 0, pretend = 0, frame = 8
 3117              		@ frame_needed = 1, uses_anonymous_args = 0
 3118 0000 80B5     		push	{r7, lr}
 3119              	.LCFI80:
 3120              		.cfi_def_cfa_offset 8
 3121              		.cfi_offset 7, -8
 3122              		.cfi_offset 14, -4
 3123 0002 82B0     		sub	sp, sp, #8
 3124              	.LCFI81:
 3125              		.cfi_def_cfa_offset 16
 3126 0004 00AF     		add	r7, sp, #0
 3127              	.LCFI82:
 3128              		.cfi_def_cfa_register 7
 3129 0006 7860     		str	r0, [r7, #4]
 3130              	.L237:
2130:Source/tasks.c **** 	/* Stop warnings. */
2131:Source/tasks.c **** 	( void ) pvParameters;
2132:Source/tasks.c **** 
2133:Source/tasks.c **** 	for( ;; )
2134:Source/tasks.c **** 	{
2135:Source/tasks.c **** 		/* See if any tasks have been deleted. */
2136:Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3131              		.loc 1 2136 0
 3132 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
2137:Source/tasks.c **** 
2138:Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2139:Source/tasks.c **** 		{
2140:Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2141:Source/tasks.c **** 			see if any other task has become available.  If we are using
2142:Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2143:Source/tasks.c **** 			will automatically get the processor anyway. */
2144:Source/tasks.c **** 			taskYIELD();
2145:Source/tasks.c **** 		}
2146:Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2147:Source/tasks.c **** 
2148:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2149:Source/tasks.c **** 		{
2150:Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2151:Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2152:Source/tasks.c **** 			to run then the idle task should yield before the end of the
2153:Source/tasks.c **** 			timeslice.
2154:Source/tasks.c **** 
2155:Source/tasks.c **** 			A critical region is not required here as we are just reading from
2156:Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2157:Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2158:Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2159:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 3133              		.loc 1 2159 0
 3134 000c 044B     		ldr	r3, .L238
 3135 000e 1B68     		ldr	r3, [r3]
 3136 0010 012B     		cmp	r3, #1
 3137 0012 01D9     		bls	.L236
2160:Source/tasks.c **** 			{
2161:Source/tasks.c **** 				taskYIELD();
 3138              		.loc 1 2161 0
 3139 0014 FFF7FEFF 		bl	vPortYield
 3140              	.L236:
 3141              	.LBB9:
2162:Source/tasks.c **** 			}
2163:Source/tasks.c **** 		}
2164:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2165:Source/tasks.c **** 
2166:Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2167:Source/tasks.c **** 		{
2168:Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2169:Source/tasks.c **** 
2170:Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2171:Source/tasks.c **** 			allows the application designer to add background functionality
2172:Source/tasks.c **** 			without the overhead of a separate task.
2173:Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2174:Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2175:Source/tasks.c **** 			vApplicationIdleHook();
 3142              		.loc 1 2175 0
 3143 0018 FFF7FEFF 		bl	vApplicationIdleHook
 3144              	.LBE9:
2176:Source/tasks.c **** 		}
2177:Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2178:Source/tasks.c **** 
2179:Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2180:Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2181:Source/tasks.c **** 		user defined low power mode	implementations require
2182:Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2183:Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2184:Source/tasks.c **** 		{
2185:Source/tasks.c **** 		portTickType xExpectedIdleTime;
2186:Source/tasks.c **** 
2187:Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2188:Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2189:Source/tasks.c **** 			test of the expected idle time is performed without the
2190:Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2191:Source/tasks.c **** 			valid. */
2192:Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2193:Source/tasks.c **** 
2194:Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2195:Source/tasks.c **** 			{
2196:Source/tasks.c **** 				vTaskSuspendAll();
2197:Source/tasks.c **** 				{
2198:Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2199:Source/tasks.c **** 					time can be sampled again, and this time its value can
2200:Source/tasks.c **** 					be used. */
2201:Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2202:Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2203:Source/tasks.c **** 
2204:Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2205:Source/tasks.c **** 					{
2206:Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2207:Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2208:Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2209:Source/tasks.c **** 					}
2210:Source/tasks.c **** 				}
2211:Source/tasks.c **** 				( void ) xTaskResumeAll();
2212:Source/tasks.c **** 			}
2213:Source/tasks.c **** 		}
2214:Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2215:Source/tasks.c **** 	}
 3145              		.loc 1 2215 0
 3146 001c F4E7     		b	.L237
 3147              	.L239:
 3148 001e 00BF     		.align	2
 3149              	.L238:
 3150 0020 00000000 		.word	pxReadyTasksLists
 3151              		.cfi_endproc
 3152              	.LFE138:
 3154              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 3155              		.align	2
 3156              		.thumb
 3157              		.thumb_func
 3159              	prvInitialiseTCBVariables:
 3160              	.LFB139:
2216:Source/tasks.c **** }
2217:Source/tasks.c **** /*-----------------------------------------------------------*/
2218:Source/tasks.c **** 
2219:Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2220:Source/tasks.c **** 
2221:Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2222:Source/tasks.c **** 	{
2223:Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2224:Source/tasks.c **** 
2225:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2226:Source/tasks.c **** 		{
2227:Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2228:Source/tasks.c **** 			eReturn = eAbortSleep;
2229:Source/tasks.c **** 		}
2230:Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2231:Source/tasks.c **** 		{
2232:Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2233:Source/tasks.c **** 			eReturn = eAbortSleep;
2234:Source/tasks.c **** 		}
2235:Source/tasks.c **** 		else
2236:Source/tasks.c **** 		{
2237:Source/tasks.c **** 			#if configUSE_TIMERS == 0
2238:Source/tasks.c **** 			{
2239:Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2240:Source/tasks.c **** 				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2241:Source/tasks.c **** 
2242:Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2243:Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2244:Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2245:Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2246:Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2247:Source/tasks.c **** 				{
2248:Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2249:Source/tasks.c **** 				}
2250:Source/tasks.c **** 			}
2251:Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2252:Source/tasks.c **** 		}
2253:Source/tasks.c **** 
2254:Source/tasks.c **** 		return eReturn;
2255:Source/tasks.c **** 	}
2256:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2257:Source/tasks.c **** /*-----------------------------------------------------------*/
2258:Source/tasks.c **** 
2259:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2260:Source/tasks.c **** {
 3161              		.loc 1 2260 0
 3162              		.cfi_startproc
 3163              		@ args = 4, pretend = 0, frame = 24
 3164              		@ frame_needed = 1, uses_anonymous_args = 0
 3165 0000 80B5     		push	{r7, lr}
 3166              	.LCFI83:
 3167              		.cfi_def_cfa_offset 8
 3168              		.cfi_offset 7, -8
 3169              		.cfi_offset 14, -4
 3170 0002 86B0     		sub	sp, sp, #24
 3171              	.LCFI84:
 3172              		.cfi_def_cfa_offset 32
 3173 0004 00AF     		add	r7, sp, #0
 3174              	.LCFI85:
 3175              		.cfi_def_cfa_register 7
 3176 0006 F860     		str	r0, [r7, #12]
 3177 0008 B960     		str	r1, [r7, #8]
 3178 000a 7A60     		str	r2, [r7, #4]
 3179 000c 3B60     		str	r3, [r7]
2261:Source/tasks.c **** unsigned portBASE_TYPE x;
2262:Source/tasks.c **** 
2263:Source/tasks.c **** 	/* Store the task name in the TCB. */
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3180              		.loc 1 2264 0
 3181 000e 0023     		movs	r3, #0
 3182 0010 7B61     		str	r3, [r7, #20]
 3183 0012 12E0     		b	.L241
 3184              	.L244:
2265:Source/tasks.c **** 	{
2266:Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 3185              		.loc 1 2266 0
 3186 0014 BA68     		ldr	r2, [r7, #8]
 3187 0016 7B69     		ldr	r3, [r7, #20]
 3188 0018 1344     		add	r3, r3, r2
 3189 001a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3190 001c F968     		ldr	r1, [r7, #12]
 3191 001e 7B69     		ldr	r3, [r7, #20]
 3192 0020 0B44     		add	r3, r3, r1
 3193 0022 3033     		adds	r3, r3, #48
 3194 0024 1A71     		strb	r2, [r3, #4]
2267:Source/tasks.c **** 
2268:Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2269:Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2270:Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2271:Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 3195              		.loc 1 2271 0
 3196 0026 BA68     		ldr	r2, [r7, #8]
 3197 0028 7B69     		ldr	r3, [r7, #20]
 3198 002a 1344     		add	r3, r3, r2
 3199 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3200 002e 002B     		cmp	r3, #0
 3201 0030 00D1     		bne	.L242
2272:Source/tasks.c **** 		{
2273:Source/tasks.c **** 			break;
 3202              		.loc 1 2273 0
 3203 0032 05E0     		b	.L243
 3204              	.L242:
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3205              		.loc 1 2264 0
 3206 0034 7B69     		ldr	r3, [r7, #20]
 3207 0036 0133     		adds	r3, r3, #1
 3208 0038 7B61     		str	r3, [r7, #20]
 3209              	.L241:
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3210              		.loc 1 2264 0 is_stmt 0 discriminator 1
 3211 003a 7B69     		ldr	r3, [r7, #20]
 3212 003c 092B     		cmp	r3, #9
 3213 003e E9D9     		bls	.L244
 3214              	.L243:
2274:Source/tasks.c **** 		}
2275:Source/tasks.c **** 	}
2276:Source/tasks.c **** 
2277:Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2278:Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2279:Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 3215              		.loc 1 2279 0 is_stmt 1
 3216 0040 FB68     		ldr	r3, [r7, #12]
 3217 0042 0022     		movs	r2, #0
 3218 0044 83F83D20 		strb	r2, [r3, #61]
2280:Source/tasks.c **** 
2281:Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2282:Source/tasks.c **** 	remove the privilege bit if one is present. */
2283:Source/tasks.c **** 	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 3219              		.loc 1 2283 0
 3220 0048 7B68     		ldr	r3, [r7, #4]
 3221 004a 042B     		cmp	r3, #4
 3222 004c 01D9     		bls	.L245
2284:Source/tasks.c **** 	{
2285:Source/tasks.c **** 		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 3223              		.loc 1 2285 0
 3224 004e 0423     		movs	r3, #4
 3225 0050 7B60     		str	r3, [r7, #4]
 3226              	.L245:
2286:Source/tasks.c **** 	}
2287:Source/tasks.c **** 
2288:Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3227              		.loc 1 2288 0
 3228 0052 FB68     		ldr	r3, [r7, #12]
 3229 0054 7A68     		ldr	r2, [r7, #4]
 3230 0056 DA62     		str	r2, [r3, #44]
2289:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2290:Source/tasks.c **** 	{
2291:Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3231              		.loc 1 2291 0
 3232 0058 FB68     		ldr	r3, [r7, #12]
 3233 005a 7A68     		ldr	r2, [r7, #4]
 3234 005c 9A64     		str	r2, [r3, #72]
2292:Source/tasks.c **** 	}
2293:Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2294:Source/tasks.c **** 
2295:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3235              		.loc 1 2295 0
 3236 005e FB68     		ldr	r3, [r7, #12]
 3237 0060 0433     		adds	r3, r3, #4
 3238 0062 1846     		mov	r0, r3
 3239 0064 FFF7FEFF 		bl	vListInitialiseItem
2296:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3240              		.loc 1 2296 0
 3241 0068 FB68     		ldr	r3, [r7, #12]
 3242 006a 1833     		adds	r3, r3, #24
 3243 006c 1846     		mov	r0, r3
 3244 006e FFF7FEFF 		bl	vListInitialiseItem
2297:Source/tasks.c **** 
2298:Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2299:Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2300:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3245              		.loc 1 2300 0
 3246 0072 FB68     		ldr	r3, [r7, #12]
 3247 0074 FA68     		ldr	r2, [r7, #12]
 3248 0076 1A61     		str	r2, [r3, #16]
2301:Source/tasks.c **** 
2302:Source/tasks.c **** 	/* Event lists are always in priority order. */
2303:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
 3249              		.loc 1 2303 0
 3250 0078 7B68     		ldr	r3, [r7, #4]
 3251 007a C3F10502 		rsb	r2, r3, #5
 3252 007e FB68     		ldr	r3, [r7, #12]
 3253 0080 9A61     		str	r2, [r3, #24]
2304:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3254              		.loc 1 2304 0
 3255 0082 FB68     		ldr	r3, [r7, #12]
 3256 0084 FA68     		ldr	r2, [r7, #12]
 3257 0086 5A62     		str	r2, [r3, #36]
2305:Source/tasks.c **** 
2306:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2307:Source/tasks.c **** 	{
2308:Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2309:Source/tasks.c **** 	}
2310:Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2311:Source/tasks.c **** 
2312:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2313:Source/tasks.c **** 	{
2314:Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2315:Source/tasks.c **** 	}
2316:Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2317:Source/tasks.c **** 
2318:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2319:Source/tasks.c **** 	{
2320:Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2321:Source/tasks.c **** 	}
2322:Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2323:Source/tasks.c **** 
2324:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2325:Source/tasks.c **** 	{
2326:Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2327:Source/tasks.c **** 	}
2328:Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2329:Source/tasks.c **** 	{
2330:Source/tasks.c **** 		( void ) xRegions;
2331:Source/tasks.c **** 		( void ) usStackDepth;
2332:Source/tasks.c **** 	}
2333:Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2334:Source/tasks.c **** 
2335:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2336:Source/tasks.c **** 	{
2337:Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2338:Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2339:Source/tasks.c **** 	}
2340:Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2341:Source/tasks.c **** }
 3258              		.loc 1 2341 0
 3259 0088 1837     		adds	r7, r7, #24
 3260 008a BD46     		mov	sp, r7
 3261              		@ sp needed
 3262 008c 80BD     		pop	{r7, pc}
 3263              		.cfi_endproc
 3264              	.LFE139:
 3266 008e 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3267              		.align	2
 3268              		.thumb
 3269              		.thumb_func
 3271              	prvInitialiseTaskLists:
 3272              	.LFB140:
2342:Source/tasks.c **** /*-----------------------------------------------------------*/
2343:Source/tasks.c **** 
2344:Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2345:Source/tasks.c **** 
2346:Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2347:Source/tasks.c **** 	{
2348:Source/tasks.c **** 	tskTCB *pxTCB;
2349:Source/tasks.c **** 
2350:Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2351:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2352:Source/tasks.c **** 
2353:Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2354:Source/tasks.c **** 	}
2355:Source/tasks.c **** 
2356:Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2357:Source/tasks.c **** /*-----------------------------------------------------------*/
2358:Source/tasks.c **** 
2359:Source/tasks.c **** static void prvInitialiseTaskLists( void )
2360:Source/tasks.c **** {
 3273              		.loc 1 2360 0
 3274              		.cfi_startproc
 3275              		@ args = 0, pretend = 0, frame = 8
 3276              		@ frame_needed = 1, uses_anonymous_args = 0
 3277 0000 80B5     		push	{r7, lr}
 3278              	.LCFI86:
 3279              		.cfi_def_cfa_offset 8
 3280              		.cfi_offset 7, -8
 3281              		.cfi_offset 14, -4
 3282 0002 82B0     		sub	sp, sp, #8
 3283              	.LCFI87:
 3284              		.cfi_def_cfa_offset 16
 3285 0004 00AF     		add	r7, sp, #0
 3286              	.LCFI88:
 3287              		.cfi_def_cfa_register 7
2361:Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2362:Source/tasks.c **** 
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3288              		.loc 1 2363 0
 3289 0006 0023     		movs	r3, #0
 3290 0008 7B60     		str	r3, [r7, #4]
 3291 000a 0CE0     		b	.L247
 3292              	.L248:
2364:Source/tasks.c **** 	{
2365:Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3293              		.loc 1 2365 0 discriminator 2
 3294 000c 7A68     		ldr	r2, [r7, #4]
 3295 000e 1346     		mov	r3, r2
 3296 0010 9B00     		lsls	r3, r3, #2
 3297 0012 1344     		add	r3, r3, r2
 3298 0014 9B00     		lsls	r3, r3, #2
 3299 0016 114A     		ldr	r2, .L249
 3300 0018 1344     		add	r3, r3, r2
 3301 001a 1846     		mov	r0, r3
 3302 001c FFF7FEFF 		bl	vListInitialise
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3303              		.loc 1 2363 0 discriminator 2
 3304 0020 7B68     		ldr	r3, [r7, #4]
 3305 0022 0133     		adds	r3, r3, #1
 3306 0024 7B60     		str	r3, [r7, #4]
 3307              	.L247:
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3308              		.loc 1 2363 0 is_stmt 0 discriminator 1
 3309 0026 7B68     		ldr	r3, [r7, #4]
 3310 0028 042B     		cmp	r3, #4
 3311 002a EFD9     		bls	.L248
2366:Source/tasks.c **** 	}
2367:Source/tasks.c **** 
2368:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3312              		.loc 1 2368 0 is_stmt 1
 3313 002c 0C48     		ldr	r0, .L249+4
 3314 002e FFF7FEFF 		bl	vListInitialise
2369:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3315              		.loc 1 2369 0
 3316 0032 0C48     		ldr	r0, .L249+8
 3317 0034 FFF7FEFF 		bl	vListInitialise
2370:Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3318              		.loc 1 2370 0
 3319 0038 0B48     		ldr	r0, .L249+12
 3320 003a FFF7FEFF 		bl	vListInitialise
2371:Source/tasks.c **** 
2372:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2373:Source/tasks.c **** 	{
2374:Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3321              		.loc 1 2374 0
 3322 003e 0B48     		ldr	r0, .L249+16
 3323 0040 FFF7FEFF 		bl	vListInitialise
2375:Source/tasks.c **** 	}
2376:Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2377:Source/tasks.c **** 
2378:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2379:Source/tasks.c **** 	{
2380:Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3324              		.loc 1 2380 0
 3325 0044 0A48     		ldr	r0, .L249+20
 3326 0046 FFF7FEFF 		bl	vListInitialise
2381:Source/tasks.c **** 	}
2382:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2383:Source/tasks.c **** 
2384:Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2385:Source/tasks.c **** 	using list2. */
2386:Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3327              		.loc 1 2386 0
 3328 004a 0A4B     		ldr	r3, .L249+24
 3329 004c 044A     		ldr	r2, .L249+4
 3330 004e 1A60     		str	r2, [r3]
2387:Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3331              		.loc 1 2387 0
 3332 0050 094B     		ldr	r3, .L249+28
 3333 0052 044A     		ldr	r2, .L249+8
 3334 0054 1A60     		str	r2, [r3]
2388:Source/tasks.c **** }
 3335              		.loc 1 2388 0
 3336 0056 0837     		adds	r7, r7, #8
 3337 0058 BD46     		mov	sp, r7
 3338              		@ sp needed
 3339 005a 80BD     		pop	{r7, pc}
 3340              	.L250:
 3341              		.align	2
 3342              	.L249:
 3343 005c 00000000 		.word	pxReadyTasksLists
 3344 0060 00000000 		.word	xDelayedTaskList1
 3345 0064 00000000 		.word	xDelayedTaskList2
 3346 0068 00000000 		.word	xPendingReadyList
 3347 006c 00000000 		.word	xTasksWaitingTermination
 3348 0070 00000000 		.word	xSuspendedTaskList
 3349 0074 00000000 		.word	pxDelayedTaskList
 3350 0078 00000000 		.word	pxOverflowDelayedTaskList
 3351              		.cfi_endproc
 3352              	.LFE140:
 3354              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3355              		.align	2
 3356              		.thumb
 3357              		.thumb_func
 3359              	prvCheckTasksWaitingTermination:
 3360              	.LFB141:
2389:Source/tasks.c **** /*-----------------------------------------------------------*/
2390:Source/tasks.c **** 
2391:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2392:Source/tasks.c **** {
 3361              		.loc 1 2392 0
 3362              		.cfi_startproc
 3363              		@ args = 0, pretend = 0, frame = 8
 3364              		@ frame_needed = 1, uses_anonymous_args = 0
 3365 0000 80B5     		push	{r7, lr}
 3366              	.LCFI89:
 3367              		.cfi_def_cfa_offset 8
 3368              		.cfi_offset 7, -8
 3369              		.cfi_offset 14, -4
 3370 0002 82B0     		sub	sp, sp, #8
 3371              	.LCFI90:
 3372              		.cfi_def_cfa_offset 16
 3373 0004 00AF     		add	r7, sp, #0
 3374              	.LCFI91:
 3375              		.cfi_def_cfa_register 7
 3376              	.LBB10:
2393:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2394:Source/tasks.c **** 	{
2395:Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2396:Source/tasks.c **** 
2397:Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2398:Source/tasks.c **** 		too often in the idle task. */
2399:Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3377              		.loc 1 2399 0
 3378 0006 28E0     		b	.L252
 3379              	.L253:
2400:Source/tasks.c **** 		{
2401:Source/tasks.c **** 			vTaskSuspendAll();
 3380              		.loc 1 2401 0
 3381 0008 FFF7FEFF 		bl	vTaskSuspendAll
2402:Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3382              		.loc 1 2402 0
 3383 000c 164B     		ldr	r3, .L254
 3384 000e 1B68     		ldr	r3, [r3]
 3385 0010 002B     		cmp	r3, #0
 3386 0012 14BF     		ite	ne
 3387 0014 0023     		movne	r3, #0
 3388 0016 0123     		moveq	r3, #1
 3389 0018 DBB2     		uxtb	r3, r3
 3390 001a 7B60     		str	r3, [r7, #4]
2403:Source/tasks.c **** 			( void ) xTaskResumeAll();
 3391              		.loc 1 2403 0
 3392 001c FFF7FEFF 		bl	xTaskResumeAll
2404:Source/tasks.c **** 
2405:Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3393              		.loc 1 2405 0
 3394 0020 7B68     		ldr	r3, [r7, #4]
 3395 0022 002B     		cmp	r3, #0
 3396 0024 19D1     		bne	.L252
 3397              	.LBB11:
2406:Source/tasks.c **** 			{
2407:Source/tasks.c **** 				tskTCB *pxTCB;
2408:Source/tasks.c **** 
2409:Source/tasks.c **** 				taskENTER_CRITICAL();
 3398              		.loc 1 2409 0
 3399 0026 FFF7FEFF 		bl	vPortEnterCritical
2410:Source/tasks.c **** 				{
2411:Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 3400              		.loc 1 2411 0
 3401 002a 0F4B     		ldr	r3, .L254
 3402 002c DB68     		ldr	r3, [r3, #12]
 3403 002e DB68     		ldr	r3, [r3, #12]
 3404 0030 3B60     		str	r3, [r7]
2412:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3405              		.loc 1 2412 0
 3406 0032 3B68     		ldr	r3, [r7]
 3407 0034 0433     		adds	r3, r3, #4
 3408 0036 1846     		mov	r0, r3
 3409 0038 FFF7FEFF 		bl	uxListRemove
2413:Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3410              		.loc 1 2413 0
 3411 003c 0B4B     		ldr	r3, .L254+4
 3412 003e 1B68     		ldr	r3, [r3]
 3413 0040 5A1E     		subs	r2, r3, #1
 3414 0042 0A4B     		ldr	r3, .L254+4
 3415 0044 1A60     		str	r2, [r3]
2414:Source/tasks.c **** 					--uxTasksDeleted;
 3416              		.loc 1 2414 0
 3417 0046 0A4B     		ldr	r3, .L254+8
 3418 0048 1B68     		ldr	r3, [r3]
 3419 004a 5A1E     		subs	r2, r3, #1
 3420 004c 084B     		ldr	r3, .L254+8
 3421 004e 1A60     		str	r2, [r3]
2415:Source/tasks.c **** 				}
2416:Source/tasks.c **** 				taskEXIT_CRITICAL();
 3422              		.loc 1 2416 0
 3423 0050 FFF7FEFF 		bl	vPortExitCritical
2417:Source/tasks.c **** 
2418:Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3424              		.loc 1 2418 0
 3425 0054 3868     		ldr	r0, [r7]
 3426 0056 FFF7FEFF 		bl	prvDeleteTCB
 3427              	.L252:
 3428              	.LBE11:
2399:Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3429              		.loc 1 2399 0 discriminator 1
 3430 005a 054B     		ldr	r3, .L254+8
 3431 005c 1B68     		ldr	r3, [r3]
 3432 005e 002B     		cmp	r3, #0
 3433 0060 D2D1     		bne	.L253
 3434              	.LBE10:
2419:Source/tasks.c **** 			}
2420:Source/tasks.c **** 		}
2421:Source/tasks.c **** 	}
2422:Source/tasks.c **** 	#endif /* vTaskDelete */
2423:Source/tasks.c **** }
 3435              		.loc 1 2423 0
 3436 0062 0837     		adds	r7, r7, #8
 3437 0064 BD46     		mov	sp, r7
 3438              		@ sp needed
 3439 0066 80BD     		pop	{r7, pc}
 3440              	.L255:
 3441              		.align	2
 3442              	.L254:
 3443 0068 00000000 		.word	xTasksWaitingTermination
 3444 006c 00000000 		.word	uxCurrentNumberOfTasks
 3445 0070 00000000 		.word	uxTasksDeleted
 3446              		.cfi_endproc
 3447              	.LFE141:
 3449              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3450              		.align	2
 3451              		.thumb
 3452              		.thumb_func
 3454              	prvAddCurrentTaskToDelayedList:
 3455              	.LFB142:
2424:Source/tasks.c **** /*-----------------------------------------------------------*/
2425:Source/tasks.c **** 
2426:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2427:Source/tasks.c **** {
 3456              		.loc 1 2427 0
 3457              		.cfi_startproc
 3458              		@ args = 0, pretend = 0, frame = 8
 3459              		@ frame_needed = 1, uses_anonymous_args = 0
 3460 0000 80B5     		push	{r7, lr}
 3461              	.LCFI92:
 3462              		.cfi_def_cfa_offset 8
 3463              		.cfi_offset 7, -8
 3464              		.cfi_offset 14, -4
 3465 0002 82B0     		sub	sp, sp, #8
 3466              	.LCFI93:
 3467              		.cfi_def_cfa_offset 16
 3468 0004 00AF     		add	r7, sp, #0
 3469              	.LCFI94:
 3470              		.cfi_def_cfa_register 7
 3471 0006 7860     		str	r0, [r7, #4]
2428:Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2429:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3472              		.loc 1 2429 0
 3473 0008 134B     		ldr	r3, .L259
 3474 000a 1B68     		ldr	r3, [r3]
 3475 000c 7A68     		ldr	r2, [r7, #4]
 3476 000e 5A60     		str	r2, [r3, #4]
2430:Source/tasks.c **** 
2431:Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3477              		.loc 1 2431 0
 3478 0010 124B     		ldr	r3, .L259+4
 3479 0012 1B68     		ldr	r3, [r3]
 3480 0014 7A68     		ldr	r2, [r7, #4]
 3481 0016 9A42     		cmp	r2, r3
 3482 0018 09D2     		bcs	.L257
2432:Source/tasks.c **** 	{
2433:Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2434:Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3483              		.loc 1 2434 0
 3484 001a 114B     		ldr	r3, .L259+8
 3485 001c 1A68     		ldr	r2, [r3]
 3486 001e 0E4B     		ldr	r3, .L259
 3487 0020 1B68     		ldr	r3, [r3]
 3488 0022 0433     		adds	r3, r3, #4
 3489 0024 1046     		mov	r0, r2
 3490 0026 1946     		mov	r1, r3
 3491 0028 FFF7FEFF 		bl	vListInsert
 3492 002c 10E0     		b	.L256
 3493              	.L257:
2435:Source/tasks.c **** 	}
2436:Source/tasks.c **** 	else
2437:Source/tasks.c **** 	{
2438:Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2439:Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3494              		.loc 1 2439 0
 3495 002e 0D4B     		ldr	r3, .L259+12
 3496 0030 1A68     		ldr	r2, [r3]
 3497 0032 094B     		ldr	r3, .L259
 3498 0034 1B68     		ldr	r3, [r3]
 3499 0036 0433     		adds	r3, r3, #4
 3500 0038 1046     		mov	r0, r2
 3501 003a 1946     		mov	r1, r3
 3502 003c FFF7FEFF 		bl	vListInsert
2440:Source/tasks.c **** 
2441:Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2442:Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2443:Source/tasks.c **** 		too. */
2444:Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3503              		.loc 1 2444 0
 3504 0040 094B     		ldr	r3, .L259+16
 3505 0042 1B68     		ldr	r3, [r3]
 3506 0044 7A68     		ldr	r2, [r7, #4]
 3507 0046 9A42     		cmp	r2, r3
 3508 0048 02D2     		bcs	.L256
2445:Source/tasks.c **** 		{
2446:Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3509              		.loc 1 2446 0
 3510 004a 074B     		ldr	r3, .L259+16
 3511 004c 7A68     		ldr	r2, [r7, #4]
 3512 004e 1A60     		str	r2, [r3]
 3513              	.L256:
2447:Source/tasks.c **** 		}
2448:Source/tasks.c **** 	}
2449:Source/tasks.c **** }
 3514              		.loc 1 2449 0
 3515 0050 0837     		adds	r7, r7, #8
 3516 0052 BD46     		mov	sp, r7
 3517              		@ sp needed
 3518 0054 80BD     		pop	{r7, pc}
 3519              	.L260:
 3520 0056 00BF     		.align	2
 3521              	.L259:
 3522 0058 00000000 		.word	pxCurrentTCB
 3523 005c 00000000 		.word	xTickCount
 3524 0060 00000000 		.word	pxOverflowDelayedTaskList
 3525 0064 00000000 		.word	pxDelayedTaskList
 3526 0068 00000000 		.word	xNextTaskUnblockTime
 3527              		.cfi_endproc
 3528              	.LFE142:
 3530              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3531              		.align	2
 3532              		.thumb
 3533              		.thumb_func
 3535              	prvAllocateTCBAndStack:
 3536              	.LFB143:
2450:Source/tasks.c **** /*-----------------------------------------------------------*/
2451:Source/tasks.c **** 
2452:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2453:Source/tasks.c **** {
 3537              		.loc 1 2453 0
 3538              		.cfi_startproc
 3539              		@ args = 0, pretend = 0, frame = 16
 3540              		@ frame_needed = 1, uses_anonymous_args = 0
 3541 0000 80B5     		push	{r7, lr}
 3542              	.LCFI95:
 3543              		.cfi_def_cfa_offset 8
 3544              		.cfi_offset 7, -8
 3545              		.cfi_offset 14, -4
 3546 0002 84B0     		sub	sp, sp, #16
 3547              	.LCFI96:
 3548              		.cfi_def_cfa_offset 24
 3549 0004 00AF     		add	r7, sp, #0
 3550              	.LCFI97:
 3551              		.cfi_def_cfa_register 7
 3552 0006 0346     		mov	r3, r0
 3553 0008 3960     		str	r1, [r7]
 3554 000a FB80     		strh	r3, [r7, #6]	@ movhi
2454:Source/tasks.c **** tskTCB *pxNewTCB;
2455:Source/tasks.c **** 
2456:Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2457:Source/tasks.c **** 	the implementation of the port malloc function. */
2458:Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3555              		.loc 1 2458 0
 3556 000c 4C20     		movs	r0, #76
 3557 000e FFF7FEFF 		bl	pvPortMalloc
 3558 0012 F860     		str	r0, [r7, #12]
2459:Source/tasks.c **** 
2460:Source/tasks.c **** 	if( pxNewTCB != NULL )
 3559              		.loc 1 2460 0
 3560 0014 FB68     		ldr	r3, [r7, #12]
 3561 0016 002B     		cmp	r3, #0
 3562 0018 1FD0     		beq	.L262
2461:Source/tasks.c **** 	{
2462:Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2463:Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2464:Source/tasks.c **** 		be deleted later if required. */
2465:Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * siz
 3563              		.loc 1 2465 0
 3564 001a 3B68     		ldr	r3, [r7]
 3565 001c 002B     		cmp	r3, #0
 3566 001e 06D1     		bne	.L263
 3567              		.loc 1 2465 0 is_stmt 0 discriminator 1
 3568 0020 FB88     		ldrh	r3, [r7, #6]
 3569 0022 9B00     		lsls	r3, r3, #2
 3570 0024 1846     		mov	r0, r3
 3571 0026 FFF7FEFF 		bl	pvPortMalloc
 3572 002a 0346     		mov	r3, r0
 3573 002c 00E0     		b	.L264
 3574              	.L263:
 3575              		.loc 1 2465 0 discriminator 2
 3576 002e 3B68     		ldr	r3, [r7]
 3577              	.L264:
 3578              		.loc 1 2465 0 discriminator 3
 3579 0030 FA68     		ldr	r2, [r7, #12]
 3580 0032 1363     		str	r3, [r2, #48]
2466:Source/tasks.c **** 
2467:Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3581              		.loc 1 2467 0 is_stmt 1 discriminator 3
 3582 0034 FB68     		ldr	r3, [r7, #12]
 3583 0036 1B6B     		ldr	r3, [r3, #48]
 3584 0038 002B     		cmp	r3, #0
 3585 003a 05D1     		bne	.L265
2468:Source/tasks.c **** 		{
2469:Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2470:Source/tasks.c **** 			vPortFree( pxNewTCB );
 3586              		.loc 1 2470 0
 3587 003c F868     		ldr	r0, [r7, #12]
 3588 003e FFF7FEFF 		bl	vPortFree
2471:Source/tasks.c **** 			pxNewTCB = NULL;
 3589              		.loc 1 2471 0
 3590 0042 0023     		movs	r3, #0
 3591 0044 FB60     		str	r3, [r7, #12]
 3592 0046 08E0     		b	.L262
 3593              	.L265:
2472:Source/tasks.c **** 		}
2473:Source/tasks.c **** 		else
2474:Source/tasks.c **** 		{
2475:Source/tasks.c **** 			/* Just to help debugging. */
2476:Source/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
 3594              		.loc 1 2476 0
 3595 0048 FB68     		ldr	r3, [r7, #12]
 3596 004a 1A6B     		ldr	r2, [r3, #48]
 3597 004c FB88     		ldrh	r3, [r7, #6]
 3598 004e 9B00     		lsls	r3, r3, #2
 3599 0050 1046     		mov	r0, r2
 3600 0052 A521     		movs	r1, #165
 3601 0054 1A46     		mov	r2, r3
 3602 0056 FFF7FEFF 		bl	memset
 3603              	.L262:
2477:Source/tasks.c **** 		}
2478:Source/tasks.c **** 	}
2479:Source/tasks.c **** 
2480:Source/tasks.c **** 	return pxNewTCB;
 3604              		.loc 1 2480 0
 3605 005a FB68     		ldr	r3, [r7, #12]
2481:Source/tasks.c **** }
 3606              		.loc 1 2481 0
 3607 005c 1846     		mov	r0, r3
 3608 005e 1037     		adds	r7, r7, #16
 3609 0060 BD46     		mov	sp, r7
 3610              		@ sp needed
 3611 0062 80BD     		pop	{r7, pc}
 3612              		.cfi_endproc
 3613              	.LFE143:
 3615              		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
 3616              		.align	2
 3617              		.thumb
 3618              		.thumb_func
 3620              	prvListTaskWithinSingleList:
 3621              	.LFB144:
2482:Source/tasks.c **** /*-----------------------------------------------------------*/
2483:Source/tasks.c **** 
2484:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2485:Source/tasks.c **** 
2486:Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
2487:Source/tasks.c **** 	{
 3622              		.loc 1 2487 0
 3623              		.cfi_startproc
 3624              		@ args = 0, pretend = 0, frame = 40
 3625              		@ frame_needed = 1, uses_anonymous_args = 0
 3626 0000 90B5     		push	{r4, r7, lr}
 3627              	.LCFI98:
 3628              		.cfi_def_cfa_offset 12
 3629              		.cfi_offset 4, -12
 3630              		.cfi_offset 7, -8
 3631              		.cfi_offset 14, -4
 3632 0002 8BB0     		sub	sp, sp, #44
 3633              	.LCFI99:
 3634              		.cfi_def_cfa_offset 56
 3635 0004 00AF     		add	r7, sp, #0
 3636              	.LCFI100:
 3637              		.cfi_def_cfa_register 7
 3638 0006 F860     		str	r0, [r7, #12]
 3639 0008 B960     		str	r1, [r7, #8]
 3640 000a 1346     		mov	r3, r2
 3641 000c FB71     		strb	r3, [r7, #7]
2488:Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2489:Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0;
 3642              		.loc 1 2489 0
 3643 000e 0023     		movs	r3, #0
 3644 0010 7B62     		str	r3, [r7, #36]
2490:Source/tasks.c **** 
2491:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
 3645              		.loc 1 2491 0
 3646 0012 BB68     		ldr	r3, [r7, #8]
 3647 0014 1B68     		ldr	r3, [r3]
 3648 0016 002B     		cmp	r3, #0
 3649 0018 6BD0     		beq	.L268
 3650              	.LBB12:
2492:Source/tasks.c **** 		{
2493:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3651              		.loc 1 2493 0
 3652 001a BB68     		ldr	r3, [r7, #8]
 3653 001c 3B62     		str	r3, [r7, #32]
 3654 001e 3B6A     		ldr	r3, [r7, #32]
 3655 0020 5B68     		ldr	r3, [r3, #4]
 3656 0022 5A68     		ldr	r2, [r3, #4]
 3657 0024 3B6A     		ldr	r3, [r7, #32]
 3658 0026 5A60     		str	r2, [r3, #4]
 3659 0028 3B6A     		ldr	r3, [r7, #32]
 3660 002a 5A68     		ldr	r2, [r3, #4]
 3661 002c 3B6A     		ldr	r3, [r7, #32]
 3662 002e 0833     		adds	r3, r3, #8
 3663 0030 9A42     		cmp	r2, r3
 3664 0032 04D1     		bne	.L269
 3665              		.loc 1 2493 0 is_stmt 0 discriminator 1
 3666 0034 3B6A     		ldr	r3, [r7, #32]
 3667 0036 5B68     		ldr	r3, [r3, #4]
 3668 0038 5A68     		ldr	r2, [r3, #4]
 3669 003a 3B6A     		ldr	r3, [r7, #32]
 3670 003c 5A60     		str	r2, [r3, #4]
 3671              	.L269:
 3672              		.loc 1 2493 0 discriminator 2
 3673 003e 3B6A     		ldr	r3, [r7, #32]
 3674 0040 5B68     		ldr	r3, [r3, #4]
 3675 0042 DB68     		ldr	r3, [r3, #12]
 3676 0044 FB61     		str	r3, [r7, #28]
 3677              	.L271:
 3678              	.LBE12:
 3679              	.LBB13:
2494:Source/tasks.c **** 
2495:Source/tasks.c **** 			/* Populate an xTaskStatusType structure within the
2496:Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2497:Source/tasks.c **** 			pxList.  See the definition of xTaskStatusType in task.h for the
2498:Source/tasks.c **** 			meaning of each xTaskStatusType structure member. */
2499:Source/tasks.c **** 			do
2500:Source/tasks.c **** 			{
2501:Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3680              		.loc 1 2501 0 is_stmt 1
 3681 0046 BB68     		ldr	r3, [r7, #8]
 3682 0048 BB61     		str	r3, [r7, #24]
 3683 004a BB69     		ldr	r3, [r7, #24]
 3684 004c 5B68     		ldr	r3, [r3, #4]
 3685 004e 5A68     		ldr	r2, [r3, #4]
 3686 0050 BB69     		ldr	r3, [r7, #24]
 3687 0052 5A60     		str	r2, [r3, #4]
 3688 0054 BB69     		ldr	r3, [r7, #24]
 3689 0056 5A68     		ldr	r2, [r3, #4]
 3690 0058 BB69     		ldr	r3, [r7, #24]
 3691 005a 0833     		adds	r3, r3, #8
 3692 005c 9A42     		cmp	r2, r3
 3693 005e 04D1     		bne	.L270
 3694              		.loc 1 2501 0 is_stmt 0 discriminator 1
 3695 0060 BB69     		ldr	r3, [r7, #24]
 3696 0062 5B68     		ldr	r3, [r3, #4]
 3697 0064 5A68     		ldr	r2, [r3, #4]
 3698 0066 BB69     		ldr	r3, [r7, #24]
 3699 0068 5A60     		str	r2, [r3, #4]
 3700              	.L270:
 3701              		.loc 1 2501 0 discriminator 2
 3702 006a BB69     		ldr	r3, [r7, #24]
 3703 006c 5B68     		ldr	r3, [r3, #4]
 3704 006e DB68     		ldr	r3, [r3, #12]
 3705 0070 7B61     		str	r3, [r7, #20]
 3706              	.LBE13:
2502:Source/tasks.c **** 
2503:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
 3707              		.loc 1 2503 0 is_stmt 1 discriminator 2
 3708 0072 7B6A     		ldr	r3, [r7, #36]
 3709 0074 5B01     		lsls	r3, r3, #5
 3710 0076 FA68     		ldr	r2, [r7, #12]
 3711 0078 1344     		add	r3, r3, r2
 3712 007a 7A69     		ldr	r2, [r7, #20]
 3713 007c 1A60     		str	r2, [r3]
2504:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ]
 3714              		.loc 1 2504 0 discriminator 2
 3715 007e 7B6A     		ldr	r3, [r7, #36]
 3716 0080 5B01     		lsls	r3, r3, #5
 3717 0082 FA68     		ldr	r2, [r7, #12]
 3718 0084 1344     		add	r3, r3, r2
 3719 0086 7A69     		ldr	r2, [r7, #20]
 3720 0088 3432     		adds	r2, r2, #52
 3721 008a 5A60     		str	r2, [r3, #4]
2505:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 3722              		.loc 1 2505 0 discriminator 2
 3723 008c 7B6A     		ldr	r3, [r7, #36]
 3724 008e 5B01     		lsls	r3, r3, #5
 3725 0090 FA68     		ldr	r2, [r7, #12]
 3726 0092 1344     		add	r3, r3, r2
 3727 0094 7A69     		ldr	r2, [r7, #20]
 3728 0096 126C     		ldr	r2, [r2, #64]
 3729 0098 9A60     		str	r2, [r3, #8]
2506:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
 3730              		.loc 1 2506 0 discriminator 2
 3731 009a 7B6A     		ldr	r3, [r7, #36]
 3732 009c 5B01     		lsls	r3, r3, #5
 3733 009e FA68     		ldr	r2, [r7, #12]
 3734 00a0 1344     		add	r3, r3, r2
 3735 00a2 FA79     		ldrb	r2, [r7, #7]
 3736 00a4 1A73     		strb	r2, [r3, #12]
2507:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
 3737              		.loc 1 2507 0 discriminator 2
 3738 00a6 7B6A     		ldr	r3, [r7, #36]
 3739 00a8 5B01     		lsls	r3, r3, #5
 3740 00aa FA68     		ldr	r2, [r7, #12]
 3741 00ac 1344     		add	r3, r3, r2
 3742 00ae 7A69     		ldr	r2, [r7, #20]
 3743 00b0 D26A     		ldr	r2, [r2, #44]
 3744 00b2 1A61     		str	r2, [r3, #16]
2508:Source/tasks.c **** 
2509:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2510:Source/tasks.c **** 				{
2511:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 3745              		.loc 1 2511 0 discriminator 2
 3746 00b4 7B6A     		ldr	r3, [r7, #36]
 3747 00b6 5B01     		lsls	r3, r3, #5
 3748 00b8 FA68     		ldr	r2, [r7, #12]
 3749 00ba 1344     		add	r3, r3, r2
 3750 00bc 7A69     		ldr	r2, [r7, #20]
 3751 00be 926C     		ldr	r2, [r2, #72]
 3752 00c0 5A61     		str	r2, [r3, #20]
2512:Source/tasks.c **** 				}
2513:Source/tasks.c **** 				#else
2514:Source/tasks.c **** 				{
2515:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2516:Source/tasks.c **** 				}
2517:Source/tasks.c **** 				#endif
2518:Source/tasks.c **** 
2519:Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2520:Source/tasks.c **** 				{
2521:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2522:Source/tasks.c **** 				}
2523:Source/tasks.c **** 				#else
2524:Source/tasks.c **** 				{
2525:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 3753              		.loc 1 2525 0 discriminator 2
 3754 00c2 7B6A     		ldr	r3, [r7, #36]
 3755 00c4 5B01     		lsls	r3, r3, #5
 3756 00c6 FA68     		ldr	r2, [r7, #12]
 3757 00c8 1344     		add	r3, r3, r2
 3758 00ca 0022     		movs	r2, #0
 3759 00cc 9A61     		str	r2, [r3, #24]
2526:Source/tasks.c **** 				}
2527:Source/tasks.c **** 				#endif
2528:Source/tasks.c **** 
2529:Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
2530:Source/tasks.c **** 				{
2531:Source/tasks.c **** 					ppxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned cha
2532:Source/tasks.c **** 				}
2533:Source/tasks.c **** 				#else
2534:Source/tasks.c **** 				{
2535:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char
 3760              		.loc 1 2535 0 discriminator 2
 3761 00ce 7B6A     		ldr	r3, [r7, #36]
 3762 00d0 5B01     		lsls	r3, r3, #5
 3763 00d2 FA68     		ldr	r2, [r7, #12]
 3764 00d4 D418     		adds	r4, r2, r3
 3765 00d6 7B69     		ldr	r3, [r7, #20]
 3766 00d8 1B6B     		ldr	r3, [r3, #48]
 3767 00da 1846     		mov	r0, r3
 3768 00dc FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 3769 00e0 0346     		mov	r3, r0
 3770 00e2 A383     		strh	r3, [r4, #28]	@ movhi
2536:Source/tasks.c **** 				}
2537:Source/tasks.c **** 				#endif
2538:Source/tasks.c **** 
2539:Source/tasks.c **** 				uxTask++;
 3771              		.loc 1 2539 0 discriminator 2
 3772 00e4 7B6A     		ldr	r3, [r7, #36]
 3773 00e6 0133     		adds	r3, r3, #1
 3774 00e8 7B62     		str	r3, [r7, #36]
2540:Source/tasks.c **** 
2541:Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
 3775              		.loc 1 2541 0 discriminator 2
 3776 00ea 7A69     		ldr	r2, [r7, #20]
 3777 00ec FB69     		ldr	r3, [r7, #28]
 3778 00ee 9A42     		cmp	r2, r3
 3779 00f0 A9D1     		bne	.L271
 3780              	.L268:
2542:Source/tasks.c **** 		}
2543:Source/tasks.c **** 
2544:Source/tasks.c **** 		return uxTask;
 3781              		.loc 1 2544 0
 3782 00f2 7B6A     		ldr	r3, [r7, #36]
2545:Source/tasks.c **** 	}
 3783              		.loc 1 2545 0
 3784 00f4 1846     		mov	r0, r3
 3785 00f6 2C37     		adds	r7, r7, #44
 3786 00f8 BD46     		mov	sp, r7
 3787              		@ sp needed
 3788 00fa 90BD     		pop	{r4, r7, pc}
 3789              		.cfi_endproc
 3790              	.LFE144:
 3792              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 3793              		.align	2
 3794              		.thumb
 3795              		.thumb_func
 3797              	prvTaskCheckFreeStackSpace:
 3798              	.LFB145:
2546:Source/tasks.c **** 
2547:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2548:Source/tasks.c **** /*-----------------------------------------------------------*/
2549:Source/tasks.c **** 
2550:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2551:Source/tasks.c **** 
2552:Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2553:Source/tasks.c **** 	{
 3799              		.loc 1 2553 0
 3800              		.cfi_startproc
 3801              		@ args = 0, pretend = 0, frame = 16
 3802              		@ frame_needed = 1, uses_anonymous_args = 0
 3803              		@ link register save eliminated.
 3804 0000 80B4     		push	{r7}
 3805              	.LCFI101:
 3806              		.cfi_def_cfa_offset 4
 3807              		.cfi_offset 7, -4
 3808 0002 85B0     		sub	sp, sp, #20
 3809              	.LCFI102:
 3810              		.cfi_def_cfa_offset 24
 3811 0004 00AF     		add	r7, sp, #0
 3812              	.LCFI103:
 3813              		.cfi_def_cfa_register 7
 3814 0006 7860     		str	r0, [r7, #4]
2554:Source/tasks.c **** 	unsigned short usCount = 0U;
 3815              		.loc 1 2554 0
 3816 0008 0023     		movs	r3, #0
 3817 000a FB81     		strh	r3, [r7, #14]	@ movhi
2555:Source/tasks.c **** 
2556:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3818              		.loc 1 2556 0
 3819 000c 05E0     		b	.L274
 3820              	.L275:
2557:Source/tasks.c **** 		{
2558:Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3821              		.loc 1 2558 0
 3822 000e 7B68     		ldr	r3, [r7, #4]
 3823 0010 0133     		adds	r3, r3, #1
 3824 0012 7B60     		str	r3, [r7, #4]
2559:Source/tasks.c **** 			usCount++;
 3825              		.loc 1 2559 0
 3826 0014 FB89     		ldrh	r3, [r7, #14]
 3827 0016 0133     		adds	r3, r3, #1
 3828 0018 FB81     		strh	r3, [r7, #14]	@ movhi
 3829              	.L274:
2556:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3830              		.loc 1 2556 0 discriminator 1
 3831 001a 7B68     		ldr	r3, [r7, #4]
 3832 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3833 001e A52B     		cmp	r3, #165
 3834 0020 F5D0     		beq	.L275
2560:Source/tasks.c **** 		}
2561:Source/tasks.c **** 
2562:Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3835              		.loc 1 2562 0
 3836 0022 FB89     		ldrh	r3, [r7, #14]
 3837 0024 9B08     		lsrs	r3, r3, #2
 3838 0026 FB81     		strh	r3, [r7, #14]	@ movhi
2563:Source/tasks.c **** 
2564:Source/tasks.c **** 		return usCount;
 3839              		.loc 1 2564 0
 3840 0028 FB89     		ldrh	r3, [r7, #14]
2565:Source/tasks.c **** 	}
 3841              		.loc 1 2565 0
 3842 002a 1846     		mov	r0, r3
 3843 002c 1437     		adds	r7, r7, #20
 3844 002e BD46     		mov	sp, r7
 3845              		@ sp needed
 3846 0030 5DF8047B 		ldr	r7, [sp], #4
 3847 0034 7047     		bx	lr
 3848              		.cfi_endproc
 3849              	.LFE145:
 3851 0036 00BF     		.section	.text.prvDeleteTCB,"ax",%progbits
 3852              		.align	2
 3853              		.thumb
 3854              		.thumb_func
 3856              	prvDeleteTCB:
 3857              	.LFB146:
2566:Source/tasks.c **** 
2567:Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2568:Source/tasks.c **** /*-----------------------------------------------------------*/
2569:Source/tasks.c **** 
2570:Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2571:Source/tasks.c **** 
2572:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2573:Source/tasks.c **** 	{
2574:Source/tasks.c **** 	tskTCB *pxTCB;
2575:Source/tasks.c **** 	unsigned char *pcEndOfStack;
2576:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2577:Source/tasks.c **** 
2578:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2579:Source/tasks.c **** 
2580:Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2581:Source/tasks.c **** 		{
2582:Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2583:Source/tasks.c **** 		}
2584:Source/tasks.c **** 		#else
2585:Source/tasks.c **** 		{
2586:Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2587:Source/tasks.c **** 		}
2588:Source/tasks.c **** 		#endif
2589:Source/tasks.c **** 
2590:Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
2591:Source/tasks.c **** 
2592:Source/tasks.c **** 		return uxReturn;
2593:Source/tasks.c **** 	}
2594:Source/tasks.c **** 
2595:Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2596:Source/tasks.c **** /*-----------------------------------------------------------*/
2597:Source/tasks.c **** 
2598:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2599:Source/tasks.c **** 
2600:Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2601:Source/tasks.c **** 	{
 3858              		.loc 1 2601 0
 3859              		.cfi_startproc
 3860              		@ args = 0, pretend = 0, frame = 8
 3861              		@ frame_needed = 1, uses_anonymous_args = 0
 3862 0000 80B5     		push	{r7, lr}
 3863              	.LCFI104:
 3864              		.cfi_def_cfa_offset 8
 3865              		.cfi_offset 7, -8
 3866              		.cfi_offset 14, -4
 3867 0002 82B0     		sub	sp, sp, #8
 3868              	.LCFI105:
 3869              		.cfi_def_cfa_offset 16
 3870 0004 00AF     		add	r7, sp, #0
 3871              	.LCFI106:
 3872              		.cfi_def_cfa_register 7
 3873 0006 7860     		str	r0, [r7, #4]
2602:Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2603:Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2604:Source/tasks.c **** 		want to allocate and clean RAM statically. */
2605:Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2606:Source/tasks.c **** 
2607:Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2608:Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2609:Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3874              		.loc 1 2609 0
 3875 0008 7B68     		ldr	r3, [r7, #4]
 3876 000a 1B6B     		ldr	r3, [r3, #48]
 3877 000c 1846     		mov	r0, r3
 3878 000e FFF7FEFF 		bl	vPortFree
2610:Source/tasks.c **** 		vPortFree( pxTCB );
 3879              		.loc 1 2610 0
 3880 0012 7868     		ldr	r0, [r7, #4]
 3881 0014 FFF7FEFF 		bl	vPortFree
2611:Source/tasks.c **** 	}
 3882              		.loc 1 2611 0
 3883 0018 0837     		adds	r7, r7, #8
 3884 001a BD46     		mov	sp, r7
 3885              		@ sp needed
 3886 001c 80BD     		pop	{r7, pc}
 3887              		.cfi_endproc
 3888              	.LFE146:
 3890 001e 00BF     		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3891              		.align	2
 3892              		.global	xTaskGetCurrentTaskHandle
 3893              		.thumb
 3894              		.thumb_func
 3896              	xTaskGetCurrentTaskHandle:
 3897              	.LFB147:
2612:Source/tasks.c **** 
2613:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
2614:Source/tasks.c **** /*-----------------------------------------------------------*/
2615:Source/tasks.c **** 
2616:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2617:Source/tasks.c **** 
2618:Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2619:Source/tasks.c **** 	{
 3898              		.loc 1 2619 0
 3899              		.cfi_startproc
 3900              		@ args = 0, pretend = 0, frame = 8
 3901              		@ frame_needed = 1, uses_anonymous_args = 0
 3902              		@ link register save eliminated.
 3903 0000 80B4     		push	{r7}
 3904              	.LCFI107:
 3905              		.cfi_def_cfa_offset 4
 3906              		.cfi_offset 7, -4
 3907 0002 83B0     		sub	sp, sp, #12
 3908              	.LCFI108:
 3909              		.cfi_def_cfa_offset 16
 3910 0004 00AF     		add	r7, sp, #0
 3911              	.LCFI109:
 3912              		.cfi_def_cfa_register 7
2620:Source/tasks.c **** 	xTaskHandle xReturn;
2621:Source/tasks.c **** 
2622:Source/tasks.c **** 		/* A critical section is not required as this is not called from
2623:Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2624:Source/tasks.c **** 		individual execution thread. */
2625:Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3913              		.loc 1 2625 0
 3914 0006 054B     		ldr	r3, .L280
 3915 0008 1B68     		ldr	r3, [r3]
 3916 000a 7B60     		str	r3, [r7, #4]
2626:Source/tasks.c **** 
2627:Source/tasks.c **** 		return xReturn;
 3917              		.loc 1 2627 0
 3918 000c 7B68     		ldr	r3, [r7, #4]
2628:Source/tasks.c **** 	}
 3919              		.loc 1 2628 0
 3920 000e 1846     		mov	r0, r3
 3921 0010 0C37     		adds	r7, r7, #12
 3922 0012 BD46     		mov	sp, r7
 3923              		@ sp needed
 3924 0014 5DF8047B 		ldr	r7, [sp], #4
 3925 0018 7047     		bx	lr
 3926              	.L281:
 3927 001a 00BF     		.align	2
 3928              	.L280:
 3929 001c 00000000 		.word	pxCurrentTCB
 3930              		.cfi_endproc
 3931              	.LFE147:
 3933              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3934              		.align	2
 3935              		.global	xTaskGetSchedulerState
 3936              		.thumb
 3937              		.thumb_func
 3939              	xTaskGetSchedulerState:
 3940              	.LFB148:
2629:Source/tasks.c **** 
2630:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2631:Source/tasks.c **** /*-----------------------------------------------------------*/
2632:Source/tasks.c **** 
2633:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2634:Source/tasks.c **** 
2635:Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2636:Source/tasks.c **** 	{
 3941              		.loc 1 2636 0
 3942              		.cfi_startproc
 3943              		@ args = 0, pretend = 0, frame = 8
 3944              		@ frame_needed = 1, uses_anonymous_args = 0
 3945              		@ link register save eliminated.
 3946 0000 80B4     		push	{r7}
 3947              	.LCFI110:
 3948              		.cfi_def_cfa_offset 4
 3949              		.cfi_offset 7, -4
 3950 0002 83B0     		sub	sp, sp, #12
 3951              	.LCFI111:
 3952              		.cfi_def_cfa_offset 16
 3953 0004 00AF     		add	r7, sp, #0
 3954              	.LCFI112:
 3955              		.cfi_def_cfa_register 7
2637:Source/tasks.c **** 	portBASE_TYPE xReturn;
2638:Source/tasks.c **** 
2639:Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3956              		.loc 1 2639 0
 3957 0006 0B4B     		ldr	r3, .L287
 3958 0008 1B68     		ldr	r3, [r3]
 3959 000a 002B     		cmp	r3, #0
 3960 000c 02D1     		bne	.L283
2640:Source/tasks.c **** 		{
2641:Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3961              		.loc 1 2641 0
 3962 000e 0023     		movs	r3, #0
 3963 0010 7B60     		str	r3, [r7, #4]
 3964 0012 08E0     		b	.L284
 3965              	.L283:
2642:Source/tasks.c **** 		}
2643:Source/tasks.c **** 		else
2644:Source/tasks.c **** 		{
2645:Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3966              		.loc 1 2645 0
 3967 0014 084B     		ldr	r3, .L287+4
 3968 0016 1B68     		ldr	r3, [r3]
 3969 0018 002B     		cmp	r3, #0
 3970 001a 02D1     		bne	.L285
2646:Source/tasks.c **** 			{
2647:Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3971              		.loc 1 2647 0
 3972 001c 0123     		movs	r3, #1
 3973 001e 7B60     		str	r3, [r7, #4]
 3974 0020 01E0     		b	.L284
 3975              	.L285:
2648:Source/tasks.c **** 			}
2649:Source/tasks.c **** 			else
2650:Source/tasks.c **** 			{
2651:Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3976              		.loc 1 2651 0
 3977 0022 0223     		movs	r3, #2
 3978 0024 7B60     		str	r3, [r7, #4]
 3979              	.L284:
2652:Source/tasks.c **** 			}
2653:Source/tasks.c **** 		}
2654:Source/tasks.c **** 
2655:Source/tasks.c **** 		return xReturn;
 3980              		.loc 1 2655 0
 3981 0026 7B68     		ldr	r3, [r7, #4]
2656:Source/tasks.c **** 	}
 3982              		.loc 1 2656 0
 3983 0028 1846     		mov	r0, r3
 3984 002a 0C37     		adds	r7, r7, #12
 3985 002c BD46     		mov	sp, r7
 3986              		@ sp needed
 3987 002e 5DF8047B 		ldr	r7, [sp], #4
 3988 0032 7047     		bx	lr
 3989              	.L288:
 3990              		.align	2
 3991              	.L287:
 3992 0034 00000000 		.word	xSchedulerRunning
 3993 0038 00000000 		.word	uxSchedulerSuspended
 3994              		.cfi_endproc
 3995              	.LFE148:
 3997              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3998              		.align	2
 3999              		.global	vTaskPriorityInherit
 4000              		.thumb
 4001              		.thumb_func
 4003              	vTaskPriorityInherit:
 4004              	.LFB149:
2657:Source/tasks.c **** 
2658:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2659:Source/tasks.c **** /*-----------------------------------------------------------*/
2660:Source/tasks.c **** 
2661:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2662:Source/tasks.c **** 
2663:Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
2664:Source/tasks.c **** 	{
 4005              		.loc 1 2664 0
 4006              		.cfi_startproc
 4007              		@ args = 0, pretend = 0, frame = 16
 4008              		@ frame_needed = 1, uses_anonymous_args = 0
 4009 0000 80B5     		push	{r7, lr}
 4010              	.LCFI113:
 4011              		.cfi_def_cfa_offset 8
 4012              		.cfi_offset 7, -8
 4013              		.cfi_offset 14, -4
 4014 0002 84B0     		sub	sp, sp, #16
 4015              	.LCFI114:
 4016              		.cfi_def_cfa_offset 24
 4017 0004 00AF     		add	r7, sp, #0
 4018              	.LCFI115:
 4019              		.cfi_def_cfa_register 7
 4020 0006 7860     		str	r0, [r7, #4]
2665:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 4021              		.loc 1 2665 0
 4022 0008 7B68     		ldr	r3, [r7, #4]
 4023 000a FB60     		str	r3, [r7, #12]
2666:Source/tasks.c **** 
2667:Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2668:Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
2669:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4024              		.loc 1 2669 0
 4025 000c 7B68     		ldr	r3, [r7, #4]
 4026 000e 002B     		cmp	r3, #0
 4027 0010 46D0     		beq	.L289
2670:Source/tasks.c **** 		{
2671:Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4028              		.loc 1 2671 0
 4029 0012 FB68     		ldr	r3, [r7, #12]
 4030 0014 DA6A     		ldr	r2, [r3, #44]
 4031 0016 244B     		ldr	r3, .L295
 4032 0018 1B68     		ldr	r3, [r3]
 4033 001a DB6A     		ldr	r3, [r3, #44]
 4034 001c 9A42     		cmp	r2, r3
 4035 001e 3FD2     		bcs	.L289
2672:Source/tasks.c **** 			{
2673:Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2674:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( 
 4036              		.loc 1 2674 0
 4037 0020 214B     		ldr	r3, .L295
 4038 0022 1B68     		ldr	r3, [r3]
 4039 0024 DB6A     		ldr	r3, [r3, #44]
 4040 0026 C3F10502 		rsb	r2, r3, #5
 4041 002a FB68     		ldr	r3, [r7, #12]
 4042 002c 9A61     		str	r2, [r3, #24]
2675:Source/tasks.c **** 
2676:Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2677:Source/tasks.c **** 				be moved into a new list. */
2678:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 4043              		.loc 1 2678 0
 4044 002e FB68     		ldr	r3, [r7, #12]
 4045 0030 5969     		ldr	r1, [r3, #20]
 4046 0032 FB68     		ldr	r3, [r7, #12]
 4047 0034 DA6A     		ldr	r2, [r3, #44]
 4048 0036 1346     		mov	r3, r2
 4049 0038 9B00     		lsls	r3, r3, #2
 4050 003a 1344     		add	r3, r3, r2
 4051 003c 9B00     		lsls	r3, r3, #2
 4052 003e 1B4A     		ldr	r2, .L295+4
 4053 0040 1344     		add	r3, r3, r2
 4054 0042 9942     		cmp	r1, r3
 4055 0044 01D1     		bne	.L291
 4056              		.loc 1 2678 0 is_stmt 0 discriminator 1
 4057 0046 0123     		movs	r3, #1
 4058 0048 00E0     		b	.L292
 4059              	.L291:
 4060              		.loc 1 2678 0 discriminator 2
 4061 004a 0023     		movs	r3, #0
 4062              	.L292:
 4063              		.loc 1 2678 0 discriminator 3
 4064 004c 002B     		cmp	r3, #0
 4065 004e 22D0     		beq	.L293
2679:Source/tasks.c **** 				{
2680:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 4066              		.loc 1 2680 0 is_stmt 1
 4067 0050 FB68     		ldr	r3, [r7, #12]
 4068 0052 0433     		adds	r3, r3, #4
 4069 0054 1846     		mov	r0, r3
 4070 0056 FFF7FEFF 		bl	uxListRemove
2681:Source/tasks.c **** 					{
2682:Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2683:Source/tasks.c **** 					}
2684:Source/tasks.c **** 
2685:Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2686:Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4071              		.loc 1 2686 0
 4072 005a 134B     		ldr	r3, .L295
 4073 005c 1B68     		ldr	r3, [r3]
 4074 005e DA6A     		ldr	r2, [r3, #44]
 4075 0060 FB68     		ldr	r3, [r7, #12]
 4076 0062 DA62     		str	r2, [r3, #44]
2687:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4077              		.loc 1 2687 0
 4078 0064 FB68     		ldr	r3, [r7, #12]
 4079 0066 DA6A     		ldr	r2, [r3, #44]
 4080 0068 114B     		ldr	r3, .L295+8
 4081 006a 1B68     		ldr	r3, [r3]
 4082 006c 9A42     		cmp	r2, r3
 4083 006e 03D9     		bls	.L294
 4084              		.loc 1 2687 0 is_stmt 0 discriminator 1
 4085 0070 FB68     		ldr	r3, [r7, #12]
 4086 0072 DA6A     		ldr	r2, [r3, #44]
 4087 0074 0E4B     		ldr	r3, .L295+8
 4088 0076 1A60     		str	r2, [r3]
 4089              	.L294:
 4090              		.loc 1 2687 0 discriminator 2
 4091 0078 FB68     		ldr	r3, [r7, #12]
 4092 007a DA6A     		ldr	r2, [r3, #44]
 4093 007c 1346     		mov	r3, r2
 4094 007e 9B00     		lsls	r3, r3, #2
 4095 0080 1344     		add	r3, r3, r2
 4096 0082 9B00     		lsls	r3, r3, #2
 4097 0084 094A     		ldr	r2, .L295+4
 4098 0086 1A44     		add	r2, r2, r3
 4099 0088 FB68     		ldr	r3, [r7, #12]
 4100 008a 0433     		adds	r3, r3, #4
 4101 008c 1046     		mov	r0, r2
 4102 008e 1946     		mov	r1, r3
 4103 0090 FFF7FEFF 		bl	vListInsertEnd
 4104 0094 04E0     		b	.L289
 4105              	.L293:
2688:Source/tasks.c **** 				}
2689:Source/tasks.c **** 				else
2690:Source/tasks.c **** 				{
2691:Source/tasks.c **** 					/* Just inherit the priority. */
2692:Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4106              		.loc 1 2692 0 is_stmt 1
 4107 0096 044B     		ldr	r3, .L295
 4108 0098 1B68     		ldr	r3, [r3]
 4109 009a DA6A     		ldr	r2, [r3, #44]
 4110 009c FB68     		ldr	r3, [r7, #12]
 4111 009e DA62     		str	r2, [r3, #44]
 4112              	.L289:
2693:Source/tasks.c **** 				}
2694:Source/tasks.c **** 
2695:Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2696:Source/tasks.c **** 			}
2697:Source/tasks.c **** 		}
2698:Source/tasks.c **** 	}
 4113              		.loc 1 2698 0
 4114 00a0 1037     		adds	r7, r7, #16
 4115 00a2 BD46     		mov	sp, r7
 4116              		@ sp needed
 4117 00a4 80BD     		pop	{r7, pc}
 4118              	.L296:
 4119 00a6 00BF     		.align	2
 4120              	.L295:
 4121 00a8 00000000 		.word	pxCurrentTCB
 4122 00ac 00000000 		.word	pxReadyTasksLists
 4123 00b0 00000000 		.word	uxTopReadyPriority
 4124              		.cfi_endproc
 4125              	.LFE149:
 4127              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 4128              		.align	2
 4129              		.global	vTaskPriorityDisinherit
 4130              		.thumb
 4131              		.thumb_func
 4133              	vTaskPriorityDisinherit:
 4134              	.LFB150:
2699:Source/tasks.c **** 
2700:Source/tasks.c **** #endif /* configUSE_MUTEXES */
2701:Source/tasks.c **** /*-----------------------------------------------------------*/
2702:Source/tasks.c **** 
2703:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2704:Source/tasks.c **** 
2705:Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
2706:Source/tasks.c **** 	{
 4135              		.loc 1 2706 0
 4136              		.cfi_startproc
 4137              		@ args = 0, pretend = 0, frame = 16
 4138              		@ frame_needed = 1, uses_anonymous_args = 0
 4139 0000 80B5     		push	{r7, lr}
 4140              	.LCFI116:
 4141              		.cfi_def_cfa_offset 8
 4142              		.cfi_offset 7, -8
 4143              		.cfi_offset 14, -4
 4144 0002 84B0     		sub	sp, sp, #16
 4145              	.LCFI117:
 4146              		.cfi_def_cfa_offset 24
 4147 0004 00AF     		add	r7, sp, #0
 4148              	.LCFI118:
 4149              		.cfi_def_cfa_register 7
 4150 0006 7860     		str	r0, [r7, #4]
2707:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 4151              		.loc 1 2707 0
 4152 0008 7B68     		ldr	r3, [r7, #4]
 4153 000a FB60     		str	r3, [r7, #12]
2708:Source/tasks.c **** 
2709:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4154              		.loc 1 2709 0
 4155 000c 7B68     		ldr	r3, [r7, #4]
 4156 000e 002B     		cmp	r3, #0
 4157 0010 2CD0     		beq	.L297
2710:Source/tasks.c **** 		{
2711:Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4158              		.loc 1 2711 0
 4159 0012 FB68     		ldr	r3, [r7, #12]
 4160 0014 DA6A     		ldr	r2, [r3, #44]
 4161 0016 FB68     		ldr	r3, [r7, #12]
 4162 0018 9B6C     		ldr	r3, [r3, #72]
 4163 001a 9A42     		cmp	r2, r3
 4164 001c 26D0     		beq	.L297
2712:Source/tasks.c **** 			{
2713:Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2714:Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2715:Source/tasks.c **** 				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 4165              		.loc 1 2715 0
 4166 001e FB68     		ldr	r3, [r7, #12]
 4167 0020 0433     		adds	r3, r3, #4
 4168 0022 1846     		mov	r0, r3
 4169 0024 FFF7FEFF 		bl	uxListRemove
2716:Source/tasks.c **** 				{
2717:Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2718:Source/tasks.c **** 				}
2719:Source/tasks.c **** 
2720:Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2721:Source/tasks.c **** 				ready list. */
2722:Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2723:Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 4170              		.loc 1 2723 0
 4171 0028 FB68     		ldr	r3, [r7, #12]
 4172 002a 9A6C     		ldr	r2, [r3, #72]
 4173 002c FB68     		ldr	r3, [r7, #12]
 4174 002e DA62     		str	r2, [r3, #44]
2724:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( 
 4175              		.loc 1 2724 0
 4176 0030 FB68     		ldr	r3, [r7, #12]
 4177 0032 DB6A     		ldr	r3, [r3, #44]
 4178 0034 C3F10502 		rsb	r2, r3, #5
 4179 0038 FB68     		ldr	r3, [r7, #12]
 4180 003a 9A61     		str	r2, [r3, #24]
2725:Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4181              		.loc 1 2725 0
 4182 003c FB68     		ldr	r3, [r7, #12]
 4183 003e DA6A     		ldr	r2, [r3, #44]
 4184 0040 0C4B     		ldr	r3, .L300
 4185 0042 1B68     		ldr	r3, [r3]
 4186 0044 9A42     		cmp	r2, r3
 4187 0046 03D9     		bls	.L299
 4188              		.loc 1 2725 0 is_stmt 0 discriminator 1
 4189 0048 FB68     		ldr	r3, [r7, #12]
 4190 004a DA6A     		ldr	r2, [r3, #44]
 4191 004c 094B     		ldr	r3, .L300
 4192 004e 1A60     		str	r2, [r3]
 4193              	.L299:
 4194              		.loc 1 2725 0 discriminator 2
 4195 0050 FB68     		ldr	r3, [r7, #12]
 4196 0052 DA6A     		ldr	r2, [r3, #44]
 4197 0054 1346     		mov	r3, r2
 4198 0056 9B00     		lsls	r3, r3, #2
 4199 0058 1344     		add	r3, r3, r2
 4200 005a 9B00     		lsls	r3, r3, #2
 4201 005c 064A     		ldr	r2, .L300+4
 4202 005e 1A44     		add	r2, r2, r3
 4203 0060 FB68     		ldr	r3, [r7, #12]
 4204 0062 0433     		adds	r3, r3, #4
 4205 0064 1046     		mov	r0, r2
 4206 0066 1946     		mov	r1, r3
 4207 0068 FFF7FEFF 		bl	vListInsertEnd
 4208              	.L297:
2726:Source/tasks.c **** 			}
2727:Source/tasks.c **** 		}
2728:Source/tasks.c **** 	}
 4209              		.loc 1 2728 0 is_stmt 1
 4210 006c 1037     		adds	r7, r7, #16
 4211 006e BD46     		mov	sp, r7
 4212              		@ sp needed
 4213 0070 80BD     		pop	{r7, pc}
 4214              	.L301:
 4215 0072 00BF     		.align	2
 4216              	.L300:
 4217 0074 00000000 		.word	uxTopReadyPriority
 4218 0078 00000000 		.word	pxReadyTasksLists
 4219              		.cfi_endproc
 4220              	.LFE150:
 4222              		.section	.rodata.ucExpectedStackBytes.8469,"a",%progbits
 4223              		.align	2
 4226              	ucExpectedStackBytes.8469:
 4227 0000 A5       		.byte	-91
 4228 0001 A5       		.byte	-91
 4229 0002 A5       		.byte	-91
 4230 0003 A5       		.byte	-91
 4231 0004 A5       		.byte	-91
 4232 0005 A5       		.byte	-91
 4233 0006 A5       		.byte	-91
 4234 0007 A5       		.byte	-91
 4235 0008 A5       		.byte	-91
 4236 0009 A5       		.byte	-91
 4237 000a A5       		.byte	-91
 4238 000b A5       		.byte	-91
 4239 000c A5       		.byte	-91
 4240 000d A5       		.byte	-91
 4241 000e A5       		.byte	-91
 4242 000f A5       		.byte	-91
 4243 0010 A5       		.byte	-91
 4244 0011 A5       		.byte	-91
 4245 0012 A5       		.byte	-91
 4246 0013 A5       		.byte	-91
 4247              		.text
 4248              	.Letext0:
 4249              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/lib/gcc/arm-none-eabi/4.8.3/includ
 4250              		.file 3 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 4251              		.file 4 "Source/include/projdefs.h"
 4252              		.file 5 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 4253              		.file 6 "Source/include/list.h"
 4254              		.file 7 "Source/include/task.h"
 4255              		.file 8 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/cc3pOhF5.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/cc3pOhF5.s:21     .bss.pxCurrentTCB:00000000 $d
     /tmp/cc3pOhF5.s:27     .bss.pxReadyTasksLists:00000000 $d
     /tmp/cc3pOhF5.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/cc3pOhF5.s:33     .bss.xDelayedTaskList1:00000000 $d
     /tmp/cc3pOhF5.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/cc3pOhF5.s:39     .bss.xDelayedTaskList2:00000000 $d
     /tmp/cc3pOhF5.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/cc3pOhF5.s:45     .bss.pxDelayedTaskList:00000000 $d
     /tmp/cc3pOhF5.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/cc3pOhF5.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/cc3pOhF5.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/cc3pOhF5.s:57     .bss.xPendingReadyList:00000000 $d
     /tmp/cc3pOhF5.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/cc3pOhF5.s:63     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/cc3pOhF5.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/cc3pOhF5.s:69     .bss.uxTasksDeleted:00000000 $d
     /tmp/cc3pOhF5.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/cc3pOhF5.s:75     .bss.xSuspendedTaskList:00000000 $d
     /tmp/cc3pOhF5.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/cc3pOhF5.s:81     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/cc3pOhF5.s:84     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/cc3pOhF5.s:87     .bss.xTickCount:00000000 $d
     /tmp/cc3pOhF5.s:90     .bss.xTickCount:00000000 xTickCount
     /tmp/cc3pOhF5.s:93     .bss.uxTopReadyPriority:00000000 $d
     /tmp/cc3pOhF5.s:96     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/cc3pOhF5.s:99     .bss.xSchedulerRunning:00000000 $d
     /tmp/cc3pOhF5.s:102    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/cc3pOhF5.s:105    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/cc3pOhF5.s:108    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/cc3pOhF5.s:111    .bss.uxPendedTicks:00000000 $d
     /tmp/cc3pOhF5.s:114    .bss.uxPendedTicks:00000000 uxPendedTicks
     /tmp/cc3pOhF5.s:117    .bss.xYieldPending:00000000 $d
     /tmp/cc3pOhF5.s:120    .bss.xYieldPending:00000000 xYieldPending
     /tmp/cc3pOhF5.s:123    .bss.xNumOfOverflows:00000000 $d
     /tmp/cc3pOhF5.s:126    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/cc3pOhF5.s:129    .bss.uxTaskNumber:00000000 $d
     /tmp/cc3pOhF5.s:132    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/cc3pOhF5.s:135    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/cc3pOhF5.s:138    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/cc3pOhF5.s:141    .text.xTaskGenericCreate:00000000 $t
     /tmp/cc3pOhF5.s:146    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/cc3pOhF5.s:3535   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/cc3pOhF5.s:3159   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/cc3pOhF5.s:3271   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/cc3pOhF5.s:369    .text.xTaskGenericCreate:00000150 $d
     /tmp/cc3pOhF5.s:379    .text.vTaskDelete:00000000 $t
     /tmp/cc3pOhF5.s:384    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/cc3pOhF5.s:476    .text.vTaskDelete:00000078 $d
     /tmp/cc3pOhF5.s:485    .text.vTaskDelayUntil:00000000 $t
     /tmp/cc3pOhF5.s:490    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/cc3pOhF5.s:1547   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/cc3pOhF5.s:3454   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/cc3pOhF5.s:1585   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/cc3pOhF5.s:618    .text.vTaskDelayUntil:000000a8 $d
     /tmp/cc3pOhF5.s:624    .text.vTaskDelay:00000000 $t
     /tmp/cc3pOhF5.s:629    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/cc3pOhF5.s:690    .text.vTaskDelay:00000048 $d
     /tmp/cc3pOhF5.s:696    .text.uxTaskPriorityGet:00000000 $t
     /tmp/cc3pOhF5.s:701    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/cc3pOhF5.s:752    .text.uxTaskPriorityGet:00000030 $d
     /tmp/cc3pOhF5.s:757    .text.vTaskPrioritySet:00000000 $t
     /tmp/cc3pOhF5.s:762    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/cc3pOhF5.s:956    .text.vTaskPrioritySet:00000110 $d
     /tmp/cc3pOhF5.s:963    .text.vTaskSuspend:00000000 $t
     /tmp/cc3pOhF5.s:968    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/cc3pOhF5.s:2343   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/cc3pOhF5.s:1065   .text.vTaskSuspend:00000080 $d
     /tmp/cc3pOhF5.s:1073   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/cc3pOhF5.s:1078   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/cc3pOhF5.s:1163   .text.xTaskIsTaskSuspended:0000005c $d
     /tmp/cc3pOhF5.s:1169   .text.vTaskResume:00000000 $t
     /tmp/cc3pOhF5.s:1174   .text.vTaskResume:00000000 vTaskResume
     /tmp/cc3pOhF5.s:1276   .text.vTaskResume:00000090 $d
     /tmp/cc3pOhF5.s:1283   .text.xTaskResumeFromISR:00000000 $t
     /tmp/cc3pOhF5.s:1288   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/cc3pOhF5.s:1404   .text.xTaskResumeFromISR:000000a4 $d
     /tmp/cc3pOhF5.s:1413   .rodata:00000000 $d
     /tmp/cc3pOhF5.s:1417   .text.vTaskStartScheduler:00000000 $t
     /tmp/cc3pOhF5.s:1422   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/cc3pOhF5.s:1497   .text.vTaskStartScheduler:00000060 $d
     /tmp/cc3pOhF5.s:3112   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/cc3pOhF5.s:1505   .text.vTaskEndScheduler:00000000 $t
     /tmp/cc3pOhF5.s:1510   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/cc3pOhF5.s:1537   .text.vTaskEndScheduler:00000014 $d
     /tmp/cc3pOhF5.s:1542   .text.vTaskSuspendAll:00000000 $t
     /tmp/cc3pOhF5.s:1575   .text.vTaskSuspendAll:00000018 $d
     /tmp/cc3pOhF5.s:1580   .text.xTaskResumeAll:00000000 $t
     /tmp/cc3pOhF5.s:2055   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/cc3pOhF5.s:1751   .text.xTaskResumeAll:000000ec $d
     /tmp/cc3pOhF5.s:1763   .text.xTaskGetTickCount:00000000 $t
     /tmp/cc3pOhF5.s:1768   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/cc3pOhF5.s:1804   .text.xTaskGetTickCount:00000020 $d
     /tmp/cc3pOhF5.s:1809   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/cc3pOhF5.s:1814   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/cc3pOhF5.s:1854   .text.xTaskGetTickCountFromISR:00000028 $d
     /tmp/cc3pOhF5.s:1859   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/cc3pOhF5.s:1864   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/cc3pOhF5.s:1890   .text.uxTaskGetNumberOfTasks:00000014 $d
     /tmp/cc3pOhF5.s:1895   .text.uxTaskGetSystemState:00000000 $t
     /tmp/cc3pOhF5.s:1900   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
     /tmp/cc3pOhF5.s:3620   .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
     /tmp/cc3pOhF5.s:2040   .text.uxTaskGetSystemState:000000e0 $d
     /tmp/cc3pOhF5.s:2050   .text.xTaskIncrementTick:00000000 $t
     /tmp/cc3pOhF5.s:2323   .text.xTaskIncrementTick:00000180 $d
     /tmp/cc3pOhF5.s:2338   .text.vTaskSwitchContext:00000000 $t
     /tmp/cc3pOhF5.s:2496   .text.vTaskSwitchContext:000000dc $d
     /tmp/cc3pOhF5.s:4226   .rodata.ucExpectedStackBytes.8469:00000000 ucExpectedStackBytes.8469
     /tmp/cc3pOhF5.s:2506   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/cc3pOhF5.s:2511   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/cc3pOhF5.s:2583   .text.vTaskPlaceOnEventList:00000060 $d
     /tmp/cc3pOhF5.s:2590   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/cc3pOhF5.s:2595   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/cc3pOhF5.s:2653   .text.vTaskPlaceOnEventListRestricted:00000048 $d
     /tmp/cc3pOhF5.s:2659   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/cc3pOhF5.s:2664   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/cc3pOhF5.s:2779   .text.xTaskRemoveFromEventList:000000a0 $d
     /tmp/cc3pOhF5.s:2789   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/cc3pOhF5.s:2794   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/cc3pOhF5.s:2839   .text.vTaskSetTimeOutState:0000002c $d
     /tmp/cc3pOhF5.s:2845   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/cc3pOhF5.s:2850   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/cc3pOhF5.s:2967   .text.xTaskCheckForTimeOut:00000098 $d
     /tmp/cc3pOhF5.s:2973   .text.vTaskMissedYield:00000000 $t
     /tmp/cc3pOhF5.s:2978   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/cc3pOhF5.s:3004   .text.vTaskMissedYield:00000014 $d
     /tmp/cc3pOhF5.s:3009   .text.uxTaskGetTaskNumber:00000000 $t
     /tmp/cc3pOhF5.s:3014   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
     /tmp/cc3pOhF5.s:3062   .text.vTaskSetTaskNumber:00000000 $t
     /tmp/cc3pOhF5.s:3067   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
     /tmp/cc3pOhF5.s:3108   .text.prvIdleTask:00000000 $t
     /tmp/cc3pOhF5.s:3359   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/cc3pOhF5.s:3150   .text.prvIdleTask:00000020 $d
     /tmp/cc3pOhF5.s:3155   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/cc3pOhF5.s:3267   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/cc3pOhF5.s:3343   .text.prvInitialiseTaskLists:0000005c $d
     /tmp/cc3pOhF5.s:3355   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/cc3pOhF5.s:3856   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/cc3pOhF5.s:3443   .text.prvCheckTasksWaitingTermination:00000068 $d
     /tmp/cc3pOhF5.s:3450   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/cc3pOhF5.s:3522   .text.prvAddCurrentTaskToDelayedList:00000058 $d
     /tmp/cc3pOhF5.s:3531   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/cc3pOhF5.s:3616   .text.prvListTaskWithinSingleList:00000000 $t
     /tmp/cc3pOhF5.s:3797   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
     /tmp/cc3pOhF5.s:3793   .text.prvTaskCheckFreeStackSpace:00000000 $t
     /tmp/cc3pOhF5.s:3852   .text.prvDeleteTCB:00000000 $t
     /tmp/cc3pOhF5.s:3891   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/cc3pOhF5.s:3896   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/cc3pOhF5.s:3929   .text.xTaskGetCurrentTaskHandle:0000001c $d
     /tmp/cc3pOhF5.s:3934   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/cc3pOhF5.s:3939   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/cc3pOhF5.s:3992   .text.xTaskGetSchedulerState:00000034 $d
     /tmp/cc3pOhF5.s:3998   .text.vTaskPriorityInherit:00000000 $t
     /tmp/cc3pOhF5.s:4003   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/cc3pOhF5.s:4121   .text.vTaskPriorityInherit:000000a8 $d
     /tmp/cc3pOhF5.s:4128   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/cc3pOhF5.s:4133   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/cc3pOhF5.s:4217   .text.vTaskPriorityDisinherit:00000074 $d
     /tmp/cc3pOhF5.s:4223   .rodata.ucExpectedStackBytes.8469:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
uxListRemove
vPortValidateInterruptPriority
vPortClearInterruptMask
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vApplicationStackOverflowHook
memcmp
vListInsert
vApplicationIdleHook
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
