   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"dynamic.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xContinuousIncrementHandle,"aw",%nobits
  20              		.align	2
  23              	xContinuousIncrementHandle:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xLimitedIncrementHandle,"aw",%nobits
  26              		.align	2
  29              	xLimitedIncrementHandle:
  30 0000 00000000 		.space	4
  31              		.section	.bss.ulCounter,"aw",%nobits
  32              		.align	2
  35              	ulCounter:
  36 0000 00000000 		.space	4
  37              		.section	.bss.usCheckVariable,"aw",%nobits
  38              		.align	1
  41              	usCheckVariable:
  42 0000 0000     		.space	2
  43              		.section	.bss.xSuspendedQueueSendError,"aw",%nobits
  44              		.align	2
  47              	xSuspendedQueueSendError:
  48 0000 00000000 		.space	4
  49              		.section	.bss.xSuspendedQueueReceiveError,"aw",%nobits
  50              		.align	2
  53              	xSuspendedQueueReceiveError:
  54 0000 00000000 		.space	4
  55              		.comm	xSuspendedTestQueue,4,4
  56              		.section	.bss.ulExpectedValue,"aw",%nobits
  57              		.align	2
  60              	ulExpectedValue:
  61 0000 00000000 		.space	4
  62              		.section	.rodata
  63              		.align	2
  64              	.LC0:
  65 0000 53757370 		.ascii	"Suspended_Test_Queue\000"
  65      656E6465 
  65      645F5465 
  65      73745F51 
  65      75657565 
  66 0015 000000   		.align	2
  67              	.LC1:
  68 0018 434E545F 		.ascii	"CNT_INC\000"
  68      494E4300 
  69              		.align	2
  70              	.LC2:
  71 0020 4C494D5F 		.ascii	"LIM_INC\000"
  71      494E4300 
  72              		.align	2
  73              	.LC3:
  74 0028 435F4354 		.ascii	"C_CTRL\000"
  74      524C00
  75 002f 00       		.align	2
  76              	.LC4:
  77 0030 53555350 		.ascii	"SUSP_TX\000"
  77      5F545800 
  78              		.align	2
  79              	.LC5:
  80 0038 53555350 		.ascii	"SUSP_RX\000"
  80      5F525800 
  81              		.section	.text.vStartDynamicPriorityTasks,"ax",%progbits
  82              		.align	2
  83              		.global	vStartDynamicPriorityTasks
  84              		.thumb
  85              		.thumb_func
  87              	vStartDynamicPriorityTasks:
  88              	.LFB110:
  89              		.file 1 "App/Common/Minimal/dynamic.c"
   1:App/Common/Minimal/dynamic.c **** /*
   2:App/Common/Minimal/dynamic.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/dynamic.c ****     All rights reserved
   4:App/Common/Minimal/dynamic.c **** 
   5:App/Common/Minimal/dynamic.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/dynamic.c **** 
   7:App/Common/Minimal/dynamic.c ****     ***************************************************************************
   8:App/Common/Minimal/dynamic.c ****      *                                                                       *
   9:App/Common/Minimal/dynamic.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/dynamic.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/dynamic.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/dynamic.c ****      *                                                                       *
  13:App/Common/Minimal/dynamic.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/dynamic.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/dynamic.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/dynamic.c ****      *                                                                       *
  17:App/Common/Minimal/dynamic.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/dynamic.c ****      *                                                                       *
  19:App/Common/Minimal/dynamic.c ****     ***************************************************************************
  20:App/Common/Minimal/dynamic.c **** 
  21:App/Common/Minimal/dynamic.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/dynamic.c **** 
  23:App/Common/Minimal/dynamic.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/dynamic.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/dynamic.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/dynamic.c **** 
  27:App/Common/Minimal/dynamic.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/dynamic.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/dynamic.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/dynamic.c ****     >>! kernel.
  31:App/Common/Minimal/dynamic.c **** 
  32:App/Common/Minimal/dynamic.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/dynamic.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/dynamic.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/dynamic.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/dynamic.c **** 
  37:App/Common/Minimal/dynamic.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/dynamic.c **** 
  39:App/Common/Minimal/dynamic.c ****     ***************************************************************************
  40:App/Common/Minimal/dynamic.c ****      *                                                                       *
  41:App/Common/Minimal/dynamic.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/dynamic.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/dynamic.c ****      *                                                                       *
  44:App/Common/Minimal/dynamic.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/dynamic.c ****      *                                                                       *
  46:App/Common/Minimal/dynamic.c ****     ***************************************************************************
  47:App/Common/Minimal/dynamic.c **** 
  48:App/Common/Minimal/dynamic.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/dynamic.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/dynamic.c **** 
  51:App/Common/Minimal/dynamic.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/dynamic.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/dynamic.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/dynamic.c **** 
  55:App/Common/Minimal/dynamic.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/dynamic.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/dynamic.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/dynamic.c **** 
  59:App/Common/Minimal/dynamic.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/dynamic.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/dynamic.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/dynamic.c **** 
  63:App/Common/Minimal/dynamic.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/dynamic.c **** */
  65:App/Common/Minimal/dynamic.c **** 
  66:App/Common/Minimal/dynamic.c **** /*
  67:App/Common/Minimal/dynamic.c ****  * The first test creates three tasks - two counter tasks (one continuous count
  68:App/Common/Minimal/dynamic.c ****  * and one limited count) and one controller.  A "count" variable is shared
  69:App/Common/Minimal/dynamic.c ****  * between all three tasks.  The two counter tasks should never be in a "ready"
  70:App/Common/Minimal/dynamic.c ****  * state at the same time.  The controller task runs at the same priority as
  71:App/Common/Minimal/dynamic.c ****  * the continuous count task, and at a lower priority than the limited count
  72:App/Common/Minimal/dynamic.c ****  * task.
  73:App/Common/Minimal/dynamic.c ****  *
  74:App/Common/Minimal/dynamic.c ****  * One counter task loops indefinitely, incrementing the shared count variable
  75:App/Common/Minimal/dynamic.c ****  * on each iteration.  To ensure it has exclusive access to the variable it
  76:App/Common/Minimal/dynamic.c ****  * raises its priority above that of the controller task before each
  77:App/Common/Minimal/dynamic.c ****  * increment, lowering it again to its original priority before starting the
  78:App/Common/Minimal/dynamic.c ****  * next iteration.
  79:App/Common/Minimal/dynamic.c ****  *
  80:App/Common/Minimal/dynamic.c ****  * The other counter task increments the shared count variable on each
  81:App/Common/Minimal/dynamic.c ****  * iteration of its loop until the count has reached a limit of 0xff - at
  82:App/Common/Minimal/dynamic.c ****  * which point it suspends itself.  It will not start a new loop until the
  83:App/Common/Minimal/dynamic.c ****  * controller task has made it "ready" again by calling vTaskResume().
  84:App/Common/Minimal/dynamic.c ****  * This second counter task operates at a higher priority than controller
  85:App/Common/Minimal/dynamic.c ****  * task so does not need to worry about mutual exclusion of the counter
  86:App/Common/Minimal/dynamic.c ****  * variable.
  87:App/Common/Minimal/dynamic.c ****  *
  88:App/Common/Minimal/dynamic.c ****  * The controller task is in two sections.  The first section controls and
  89:App/Common/Minimal/dynamic.c ****  * monitors the continuous count task.  When this section is operational the
  90:App/Common/Minimal/dynamic.c ****  * limited count task is suspended.  Likewise, the second section controls
  91:App/Common/Minimal/dynamic.c ****  * and monitors the limited count task.  When this section is operational the
  92:App/Common/Minimal/dynamic.c ****  * continuous count task is suspended.
  93:App/Common/Minimal/dynamic.c ****  *
  94:App/Common/Minimal/dynamic.c ****  * In the first section the controller task first takes a copy of the shared
  95:App/Common/Minimal/dynamic.c ****  * count variable.  To ensure mutual exclusion on the count variable it
  96:App/Common/Minimal/dynamic.c ****  * suspends the continuous count task, resuming it again when the copy has been
  97:App/Common/Minimal/dynamic.c ****  * taken.  The controller task then sleeps for a fixed period - during which
  98:App/Common/Minimal/dynamic.c ****  * the continuous count task will execute and increment the shared variable.
  99:App/Common/Minimal/dynamic.c ****  * When the controller task wakes it checks that the continuous count task
 100:App/Common/Minimal/dynamic.c ****  * has executed by comparing the copy of the shared variable with its current
 101:App/Common/Minimal/dynamic.c ****  * value.  This time, to ensure mutual exclusion, the scheduler itself is
 102:App/Common/Minimal/dynamic.c ****  * suspended with a call to vTaskSuspendAll ().  This is for demonstration
 103:App/Common/Minimal/dynamic.c ****  * purposes only and is not a recommended technique due to its inefficiency.
 104:App/Common/Minimal/dynamic.c ****  *
 105:App/Common/Minimal/dynamic.c ****  * After a fixed number of iterations the controller task suspends the
 106:App/Common/Minimal/dynamic.c ****  * continuous count task, and moves on to its second section.
 107:App/Common/Minimal/dynamic.c ****  *
 108:App/Common/Minimal/dynamic.c ****  * At the start of the second section the shared variable is cleared to zero.
 109:App/Common/Minimal/dynamic.c ****  * The limited count task is then woken from its suspension by a call to
 110:App/Common/Minimal/dynamic.c ****  * vTaskResume ().  As this counter task operates at a higher priority than
 111:App/Common/Minimal/dynamic.c ****  * the controller task the controller task should not run again until the
 112:App/Common/Minimal/dynamic.c ****  * shared variable has been counted up to the limited value causing the counter
 113:App/Common/Minimal/dynamic.c ****  * task to suspend itself.  The next line after vTaskResume () is therefore
 114:App/Common/Minimal/dynamic.c ****  * a check on the shared variable to ensure everything is as expected.
 115:App/Common/Minimal/dynamic.c ****  *
 116:App/Common/Minimal/dynamic.c ****  *
 117:App/Common/Minimal/dynamic.c ****  * The second test consists of a couple of very simple tasks that post onto a
 118:App/Common/Minimal/dynamic.c ****  * queue while the scheduler is suspended.  This test was added to test parts
 119:App/Common/Minimal/dynamic.c ****  * of the scheduler not exercised by the first test.
 120:App/Common/Minimal/dynamic.c ****  *
 121:App/Common/Minimal/dynamic.c ****  */
 122:App/Common/Minimal/dynamic.c **** 
 123:App/Common/Minimal/dynamic.c **** #include <stdlib.h>
 124:App/Common/Minimal/dynamic.c **** 
 125:App/Common/Minimal/dynamic.c **** /* Scheduler include files. */
 126:App/Common/Minimal/dynamic.c **** #include "FreeRTOS.h"
 127:App/Common/Minimal/dynamic.c **** #include "task.h"
 128:App/Common/Minimal/dynamic.c **** #include "semphr.h"
 129:App/Common/Minimal/dynamic.c **** 
 130:App/Common/Minimal/dynamic.c **** /* Demo app include files. */
 131:App/Common/Minimal/dynamic.c **** #include "dynamic.h"
 132:App/Common/Minimal/dynamic.c **** 
 133:App/Common/Minimal/dynamic.c **** /* Function that implements the "limited count" task as described above. */
 134:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION_PROTO( vLimitedIncrementTask, pvParameters );
 135:App/Common/Minimal/dynamic.c **** 
 136:App/Common/Minimal/dynamic.c **** /* Function that implements the "continuous count" task as described above. */
 137:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION_PROTO( vContinuousIncrementTask, pvParameters );
 138:App/Common/Minimal/dynamic.c **** 
 139:App/Common/Minimal/dynamic.c **** /* Function that implements the controller task as described above. */
 140:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION_PROTO( vCounterControlTask, pvParameters );
 141:App/Common/Minimal/dynamic.c **** 
 142:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION_PROTO( vQueueReceiveWhenSuspendedTask, pvParameters );
 143:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION_PROTO( vQueueSendWhenSuspendedTask, pvParameters );
 144:App/Common/Minimal/dynamic.c **** 
 145:App/Common/Minimal/dynamic.c **** /* Demo task specific constants. */
 146:App/Common/Minimal/dynamic.c **** #define priSTACK_SIZE				( configMINIMAL_STACK_SIZE )
 147:App/Common/Minimal/dynamic.c **** #define priSLEEP_TIME				( ( portTickType ) 128 / portTICK_RATE_MS )
 148:App/Common/Minimal/dynamic.c **** #define priLOOPS					( 5 )
 149:App/Common/Minimal/dynamic.c **** #define priMAX_COUNT				( ( unsigned long ) 0xff )
 150:App/Common/Minimal/dynamic.c **** #define priNO_BLOCK					( ( portTickType ) 0 )
 151:App/Common/Minimal/dynamic.c **** #define priSUSPENDED_QUEUE_LENGTH	( 1 )
 152:App/Common/Minimal/dynamic.c **** 
 153:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 154:App/Common/Minimal/dynamic.c **** 
 155:App/Common/Minimal/dynamic.c **** /* Handles to the two counter tasks.  These could be passed in as parameters
 156:App/Common/Minimal/dynamic.c **** to the controller task to prevent them having to be file scope. */
 157:App/Common/Minimal/dynamic.c **** static xTaskHandle xContinuousIncrementHandle, xLimitedIncrementHandle;
 158:App/Common/Minimal/dynamic.c **** 
 159:App/Common/Minimal/dynamic.c **** /* The shared counter variable.  This is passed in as a parameter to the two
 160:App/Common/Minimal/dynamic.c **** counter variables for demonstration purposes. */
 161:App/Common/Minimal/dynamic.c **** static volatile unsigned long ulCounter;
 162:App/Common/Minimal/dynamic.c **** 
 163:App/Common/Minimal/dynamic.c **** /* Variables used to check that the tasks are still operating without error.
 164:App/Common/Minimal/dynamic.c **** Each complete iteration of the controller task increments this variable
 165:App/Common/Minimal/dynamic.c **** provided no errors have been found.  The variable maintaining the same value
 166:App/Common/Minimal/dynamic.c **** is therefore indication of an error. */
 167:App/Common/Minimal/dynamic.c **** static volatile unsigned short usCheckVariable = ( unsigned short ) 0;
 168:App/Common/Minimal/dynamic.c **** static volatile portBASE_TYPE xSuspendedQueueSendError = pdFALSE;
 169:App/Common/Minimal/dynamic.c **** static volatile portBASE_TYPE xSuspendedQueueReceiveError = pdFALSE;
 170:App/Common/Minimal/dynamic.c **** 
 171:App/Common/Minimal/dynamic.c **** /* Queue used by the second test. */
 172:App/Common/Minimal/dynamic.c **** xQueueHandle xSuspendedTestQueue;
 173:App/Common/Minimal/dynamic.c **** 
 174:App/Common/Minimal/dynamic.c **** /* The value the queue receive task expects to receive next.  This is file
 175:App/Common/Minimal/dynamic.c **** scope so xAreDynamicPriorityTasksStillRunning() can ensure it is still
 176:App/Common/Minimal/dynamic.c **** incrementing. */
 177:App/Common/Minimal/dynamic.c **** static unsigned long ulExpectedValue = ( unsigned long ) 0;
 178:App/Common/Minimal/dynamic.c **** 
 179:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 180:App/Common/Minimal/dynamic.c **** /*
 181:App/Common/Minimal/dynamic.c ****  * Start the three tasks as described at the top of the file.
 182:App/Common/Minimal/dynamic.c ****  * Note that the limited count task is given a higher priority.
 183:App/Common/Minimal/dynamic.c ****  */
 184:App/Common/Minimal/dynamic.c **** void vStartDynamicPriorityTasks( void )
 185:App/Common/Minimal/dynamic.c **** {
  90              		.loc 1 185 0
  91              		.cfi_startproc
  92              		@ args = 0, pretend = 0, frame = 0
  93              		@ frame_needed = 1, uses_anonymous_args = 0
  94 0000 80B5     		push	{r7, lr}
  95              	.LCFI0:
  96              		.cfi_def_cfa_offset 8
  97              		.cfi_offset 7, -8
  98              		.cfi_offset 14, -4
  99 0002 84B0     		sub	sp, sp, #16
 100              	.LCFI1:
 101              		.cfi_def_cfa_offset 24
 102 0004 04AF     		add	r7, sp, #16
 103              	.LCFI2:
 104              		.cfi_def_cfa 7, 8
 186:App/Common/Minimal/dynamic.c **** 	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
 105              		.loc 1 186 0
 106 0006 0120     		movs	r0, #1
 107 0008 0421     		movs	r1, #4
 108 000a 0022     		movs	r2, #0
 109 000c FFF7FEFF 		bl	xQueueGenericCreate
 110 0010 0246     		mov	r2, r0
 111 0012 284B     		ldr	r3, .L2
 112 0014 1A60     		str	r2, [r3]
 187:App/Common/Minimal/dynamic.c **** 
 188:App/Common/Minimal/dynamic.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 189:App/Common/Minimal/dynamic.c **** 	in use.  The queue registry is provided as a means for kernel aware
 190:App/Common/Minimal/dynamic.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 191:App/Common/Minimal/dynamic.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 192:App/Common/Minimal/dynamic.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 193:App/Common/Minimal/dynamic.c **** 	defined to be less than 1. */
 194:App/Common/Minimal/dynamic.c **** 	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );
 113              		.loc 1 194 0
 114 0016 274B     		ldr	r3, .L2
 115 0018 1B68     		ldr	r3, [r3]
 116 001a 1846     		mov	r0, r3
 117 001c 2649     		ldr	r1, .L2+4
 118 001e FFF7FEFF 		bl	vQueueAddToRegistry
 195:App/Common/Minimal/dynamic.c **** 
 196:App/Common/Minimal/dynamic.c **** 	xTaskCreate( vContinuousIncrementTask, ( signed char * ) "CNT_INC", priSTACK_SIZE, ( void * ) &ulC
 119              		.loc 1 196 0
 120 0022 0023     		movs	r3, #0
 121 0024 0093     		str	r3, [sp]
 122 0026 254B     		ldr	r3, .L2+8
 123 0028 0193     		str	r3, [sp, #4]
 124 002a 0023     		movs	r3, #0
 125 002c 0293     		str	r3, [sp, #8]
 126 002e 0023     		movs	r3, #0
 127 0030 0393     		str	r3, [sp, #12]
 128 0032 2348     		ldr	r0, .L2+12
 129 0034 2349     		ldr	r1, .L2+16
 130 0036 8222     		movs	r2, #130
 131 0038 234B     		ldr	r3, .L2+20
 132 003a FFF7FEFF 		bl	xTaskGenericCreate
 197:App/Common/Minimal/dynamic.c **** 	xTaskCreate( vLimitedIncrementTask, ( signed char * ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCoun
 133              		.loc 1 197 0
 134 003e 0123     		movs	r3, #1
 135 0040 0093     		str	r3, [sp]
 136 0042 224B     		ldr	r3, .L2+24
 137 0044 0193     		str	r3, [sp, #4]
 138 0046 0023     		movs	r3, #0
 139 0048 0293     		str	r3, [sp, #8]
 140 004a 0023     		movs	r3, #0
 141 004c 0393     		str	r3, [sp, #12]
 142 004e 2048     		ldr	r0, .L2+28
 143 0050 2049     		ldr	r1, .L2+32
 144 0052 8222     		movs	r2, #130
 145 0054 1C4B     		ldr	r3, .L2+20
 146 0056 FFF7FEFF 		bl	xTaskGenericCreate
 198:App/Common/Minimal/dynamic.c **** 	xTaskCreate( vCounterControlTask, ( signed char * ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORIT
 147              		.loc 1 198 0
 148 005a 0023     		movs	r3, #0
 149 005c 0093     		str	r3, [sp]
 150 005e 0023     		movs	r3, #0
 151 0060 0193     		str	r3, [sp, #4]
 152 0062 0023     		movs	r3, #0
 153 0064 0293     		str	r3, [sp, #8]
 154 0066 0023     		movs	r3, #0
 155 0068 0393     		str	r3, [sp, #12]
 156 006a 1B48     		ldr	r0, .L2+36
 157 006c 1B49     		ldr	r1, .L2+40
 158 006e 8222     		movs	r2, #130
 159 0070 0023     		movs	r3, #0
 160 0072 FFF7FEFF 		bl	xTaskGenericCreate
 199:App/Common/Minimal/dynamic.c **** 	xTaskCreate( vQueueSendWhenSuspendedTask, ( signed char * ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDL
 161              		.loc 1 199 0
 162 0076 0023     		movs	r3, #0
 163 0078 0093     		str	r3, [sp]
 164 007a 0023     		movs	r3, #0
 165 007c 0193     		str	r3, [sp, #4]
 166 007e 0023     		movs	r3, #0
 167 0080 0293     		str	r3, [sp, #8]
 168 0082 0023     		movs	r3, #0
 169 0084 0393     		str	r3, [sp, #12]
 170 0086 1648     		ldr	r0, .L2+44
 171 0088 1649     		ldr	r1, .L2+48
 172 008a 8222     		movs	r2, #130
 173 008c 0023     		movs	r3, #0
 174 008e FFF7FEFF 		bl	xTaskGenericCreate
 200:App/Common/Minimal/dynamic.c **** 	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( signed char * ) "SUSP_RX", priSTACK_SIZE, NULL, tsk
 175              		.loc 1 200 0
 176 0092 0023     		movs	r3, #0
 177 0094 0093     		str	r3, [sp]
 178 0096 0023     		movs	r3, #0
 179 0098 0193     		str	r3, [sp, #4]
 180 009a 0023     		movs	r3, #0
 181 009c 0293     		str	r3, [sp, #8]
 182 009e 0023     		movs	r3, #0
 183 00a0 0393     		str	r3, [sp, #12]
 184 00a2 1148     		ldr	r0, .L2+52
 185 00a4 1149     		ldr	r1, .L2+56
 186 00a6 8222     		movs	r2, #130
 187 00a8 0023     		movs	r3, #0
 188 00aa FFF7FEFF 		bl	xTaskGenericCreate
 201:App/Common/Minimal/dynamic.c **** }
 189              		.loc 1 201 0
 190 00ae BD46     		mov	sp, r7
 191              		@ sp needed
 192 00b0 80BD     		pop	{r7, pc}
 193              	.L3:
 194 00b2 00BF     		.align	2
 195              	.L2:
 196 00b4 00000000 		.word	xSuspendedTestQueue
 197 00b8 00000000 		.word	.LC0
 198 00bc 00000000 		.word	xContinuousIncrementHandle
 199 00c0 00000000 		.word	vContinuousIncrementTask
 200 00c4 18000000 		.word	.LC1
 201 00c8 00000000 		.word	ulCounter
 202 00cc 00000000 		.word	xLimitedIncrementHandle
 203 00d0 00000000 		.word	vLimitedIncrementTask
 204 00d4 20000000 		.word	.LC2
 205 00d8 00000000 		.word	vCounterControlTask
 206 00dc 28000000 		.word	.LC3
 207 00e0 00000000 		.word	vQueueSendWhenSuspendedTask
 208 00e4 30000000 		.word	.LC4
 209 00e8 00000000 		.word	vQueueReceiveWhenSuspendedTask
 210 00ec 38000000 		.word	.LC5
 211              		.cfi_endproc
 212              	.LFE110:
 214              		.section	.text.vLimitedIncrementTask,"ax",%progbits
 215              		.align	2
 216              		.thumb
 217              		.thumb_func
 219              	vLimitedIncrementTask:
 220              	.LFB111:
 202:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 203:App/Common/Minimal/dynamic.c **** 
 204:App/Common/Minimal/dynamic.c **** /*
 205:App/Common/Minimal/dynamic.c ****  * Just loops around incrementing the shared variable until the limit has been
 206:App/Common/Minimal/dynamic.c ****  * reached.  Once the limit has been reached it suspends itself.
 207:App/Common/Minimal/dynamic.c ****  */
 208:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
 209:App/Common/Minimal/dynamic.c **** {
 221              		.loc 1 209 0
 222              		.cfi_startproc
 223              		@ args = 0, pretend = 0, frame = 16
 224              		@ frame_needed = 1, uses_anonymous_args = 0
 225 0000 80B5     		push	{r7, lr}
 226              	.LCFI3:
 227              		.cfi_def_cfa_offset 8
 228              		.cfi_offset 7, -8
 229              		.cfi_offset 14, -4
 230 0002 84B0     		sub	sp, sp, #16
 231              	.LCFI4:
 232              		.cfi_def_cfa_offset 24
 233 0004 00AF     		add	r7, sp, #0
 234              	.LCFI5:
 235              		.cfi_def_cfa_register 7
 236 0006 7860     		str	r0, [r7, #4]
 210:App/Common/Minimal/dynamic.c **** unsigned long *pulCounter;
 211:App/Common/Minimal/dynamic.c **** 
 212:App/Common/Minimal/dynamic.c **** 	/* Take a pointer to the shared variable from the parameters passed into
 213:App/Common/Minimal/dynamic.c **** 	the task. */
 214:App/Common/Minimal/dynamic.c **** 	pulCounter = ( unsigned long * ) pvParameters;
 237              		.loc 1 214 0
 238 0008 7B68     		ldr	r3, [r7, #4]
 239 000a FB60     		str	r3, [r7, #12]
 215:App/Common/Minimal/dynamic.c **** 
 216:App/Common/Minimal/dynamic.c **** 	/* This will run before the control task, so the first thing it does is
 217:App/Common/Minimal/dynamic.c **** 	suspend - the control task will resume it when ready. */
 218:App/Common/Minimal/dynamic.c **** 	vTaskSuspend( NULL );
 240              		.loc 1 218 0
 241 000c 0020     		movs	r0, #0
 242 000e FFF7FEFF 		bl	vTaskSuspend
 243              	.L6:
 219:App/Common/Minimal/dynamic.c **** 
 220:App/Common/Minimal/dynamic.c **** 	for( ;; )
 221:App/Common/Minimal/dynamic.c **** 	{
 222:App/Common/Minimal/dynamic.c **** 		/* Just count up to a value then suspend. */
 223:App/Common/Minimal/dynamic.c **** 		( *pulCounter )++;
 244              		.loc 1 223 0
 245 0012 FB68     		ldr	r3, [r7, #12]
 246 0014 1B68     		ldr	r3, [r3]
 247 0016 5A1C     		adds	r2, r3, #1
 248 0018 FB68     		ldr	r3, [r7, #12]
 249 001a 1A60     		str	r2, [r3]
 224:App/Common/Minimal/dynamic.c **** 
 225:App/Common/Minimal/dynamic.c **** 		if( *pulCounter >= priMAX_COUNT )
 250              		.loc 1 225 0
 251 001c FB68     		ldr	r3, [r7, #12]
 252 001e 1B68     		ldr	r3, [r3]
 253 0020 FE2B     		cmp	r3, #254
 254 0022 03D9     		bls	.L5
 226:App/Common/Minimal/dynamic.c **** 		{
 227:App/Common/Minimal/dynamic.c **** 			vTaskSuspend( NULL );
 255              		.loc 1 227 0
 256 0024 0020     		movs	r0, #0
 257 0026 FFF7FEFF 		bl	vTaskSuspend
 228:App/Common/Minimal/dynamic.c **** 		}
 229:App/Common/Minimal/dynamic.c **** 	}
 258              		.loc 1 229 0
 259 002a F2E7     		b	.L6
 260              	.L5:
 261 002c F1E7     		b	.L6
 262              		.cfi_endproc
 263              	.LFE111:
 265 002e 00BF     		.section	.text.vContinuousIncrementTask,"ax",%progbits
 266              		.align	2
 267              		.thumb
 268              		.thumb_func
 270              	vContinuousIncrementTask:
 271              	.LFB112:
 230:App/Common/Minimal/dynamic.c **** }
 231:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 232:App/Common/Minimal/dynamic.c **** 
 233:App/Common/Minimal/dynamic.c **** /*
 234:App/Common/Minimal/dynamic.c ****  * Just keep counting the shared variable up.  The control task will suspend
 235:App/Common/Minimal/dynamic.c ****  * this task when it wants.
 236:App/Common/Minimal/dynamic.c ****  */
 237:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
 238:App/Common/Minimal/dynamic.c **** {
 272              		.loc 1 238 0
 273              		.cfi_startproc
 274              		@ args = 0, pretend = 0, frame = 16
 275              		@ frame_needed = 1, uses_anonymous_args = 0
 276 0000 80B5     		push	{r7, lr}
 277              	.LCFI6:
 278              		.cfi_def_cfa_offset 8
 279              		.cfi_offset 7, -8
 280              		.cfi_offset 14, -4
 281 0002 84B0     		sub	sp, sp, #16
 282              	.LCFI7:
 283              		.cfi_def_cfa_offset 24
 284 0004 00AF     		add	r7, sp, #0
 285              	.LCFI8:
 286              		.cfi_def_cfa_register 7
 287 0006 7860     		str	r0, [r7, #4]
 239:App/Common/Minimal/dynamic.c **** volatile unsigned long *pulCounter;
 240:App/Common/Minimal/dynamic.c **** unsigned portBASE_TYPE uxOurPriority;
 241:App/Common/Minimal/dynamic.c **** 
 242:App/Common/Minimal/dynamic.c **** 	/* Take a pointer to the shared variable from the parameters passed into
 243:App/Common/Minimal/dynamic.c **** 	the task. */
 244:App/Common/Minimal/dynamic.c **** 	pulCounter = ( unsigned long * ) pvParameters;
 288              		.loc 1 244 0
 289 0008 7B68     		ldr	r3, [r7, #4]
 290 000a FB60     		str	r3, [r7, #12]
 245:App/Common/Minimal/dynamic.c **** 
 246:App/Common/Minimal/dynamic.c **** 	/* Query our priority so we can raise it when exclusive access to the
 247:App/Common/Minimal/dynamic.c **** 	shared variable is required. */
 248:App/Common/Minimal/dynamic.c **** 	uxOurPriority = uxTaskPriorityGet( NULL );
 291              		.loc 1 248 0
 292 000c 0020     		movs	r0, #0
 293 000e FFF7FEFF 		bl	uxTaskPriorityGet
 294 0012 B860     		str	r0, [r7, #8]
 295              	.L12:
 249:App/Common/Minimal/dynamic.c **** 
 250:App/Common/Minimal/dynamic.c **** 	for( ;; )
 251:App/Common/Minimal/dynamic.c **** 	{
 252:App/Common/Minimal/dynamic.c **** 		/* Raise the priority above the controller task to ensure a context
 253:App/Common/Minimal/dynamic.c **** 		switch does not occur while the variable is being accessed. */
 254:App/Common/Minimal/dynamic.c **** 		vTaskPrioritySet( NULL, uxOurPriority + 1 );
 296              		.loc 1 254 0
 297 0014 BB68     		ldr	r3, [r7, #8]
 298 0016 0133     		adds	r3, r3, #1
 299 0018 0020     		movs	r0, #0
 300 001a 1946     		mov	r1, r3
 301 001c FFF7FEFF 		bl	vTaskPrioritySet
 255:App/Common/Minimal/dynamic.c **** 		{
 256:App/Common/Minimal/dynamic.c **** 			configASSERT( ( uxTaskPriorityGet( NULL ) == ( uxOurPriority + 1 ) ) );
 302              		.loc 1 256 0
 303 0020 0020     		movs	r0, #0
 304 0022 FFF7FEFF 		bl	uxTaskPriorityGet
 305 0026 0246     		mov	r2, r0
 306 0028 BB68     		ldr	r3, [r7, #8]
 307 002a 0133     		adds	r3, r3, #1
 308 002c 9A42     		cmp	r2, r3
 309 002e 02D0     		beq	.L8
 310              		.loc 1 256 0 is_stmt 0 discriminator 1
 311 0030 FFF7FEFF 		bl	ulPortSetInterruptMask
 312              	.L9:
 313 0034 FEE7     		b	.L9
 314              	.L8:
 257:App/Common/Minimal/dynamic.c **** 			( *pulCounter )++;
 315              		.loc 1 257 0 is_stmt 1
 316 0036 FB68     		ldr	r3, [r7, #12]
 317 0038 1B68     		ldr	r3, [r3]
 318 003a 5A1C     		adds	r2, r3, #1
 319 003c FB68     		ldr	r3, [r7, #12]
 320 003e 1A60     		str	r2, [r3]
 258:App/Common/Minimal/dynamic.c **** 		}
 259:App/Common/Minimal/dynamic.c **** 		vTaskPrioritySet( NULL, uxOurPriority );
 321              		.loc 1 259 0
 322 0040 0020     		movs	r0, #0
 323 0042 B968     		ldr	r1, [r7, #8]
 324 0044 FFF7FEFF 		bl	vTaskPrioritySet
 260:App/Common/Minimal/dynamic.c **** 		configASSERT( ( uxTaskPriorityGet( NULL ) == uxOurPriority ) );
 325              		.loc 1 260 0
 326 0048 0020     		movs	r0, #0
 327 004a FFF7FEFF 		bl	uxTaskPriorityGet
 328 004e 0246     		mov	r2, r0
 329 0050 BB68     		ldr	r3, [r7, #8]
 330 0052 9A42     		cmp	r2, r3
 331 0054 02D0     		beq	.L10
 332              		.loc 1 260 0 is_stmt 0 discriminator 1
 333 0056 FFF7FEFF 		bl	ulPortSetInterruptMask
 334              	.L11:
 335 005a FEE7     		b	.L11
 336              	.L10:
 261:App/Common/Minimal/dynamic.c **** 	}
 337              		.loc 1 261 0 is_stmt 1
 338 005c DAE7     		b	.L12
 339              		.cfi_endproc
 340              	.LFE112:
 342 005e 00BF     		.section	.text.vCounterControlTask,"ax",%progbits
 343              		.align	2
 344              		.thumb
 345              		.thumb_func
 347              	vCounterControlTask:
 348              	.LFB113:
 262:App/Common/Minimal/dynamic.c **** }
 263:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 264:App/Common/Minimal/dynamic.c **** 
 265:App/Common/Minimal/dynamic.c **** /*
 266:App/Common/Minimal/dynamic.c ****  * Controller task as described above.
 267:App/Common/Minimal/dynamic.c ****  */
 268:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION( vCounterControlTask, pvParameters )
 269:App/Common/Minimal/dynamic.c **** {
 349              		.loc 1 269 0
 350              		.cfi_startproc
 351              		@ args = 0, pretend = 0, frame = 16
 352              		@ frame_needed = 1, uses_anonymous_args = 0
 353 0000 80B5     		push	{r7, lr}
 354              	.LCFI9:
 355              		.cfi_def_cfa_offset 8
 356              		.cfi_offset 7, -8
 357              		.cfi_offset 14, -4
 358 0002 84B0     		sub	sp, sp, #16
 359              	.LCFI10:
 360              		.cfi_def_cfa_offset 24
 361 0004 00AF     		add	r7, sp, #0
 362              	.LCFI11:
 363              		.cfi_def_cfa_register 7
 364 0006 7860     		str	r0, [r7, #4]
 270:App/Common/Minimal/dynamic.c **** unsigned long ulLastCounter;
 271:App/Common/Minimal/dynamic.c **** short sLoops;
 272:App/Common/Minimal/dynamic.c **** short sError = pdFALSE;
 365              		.loc 1 272 0
 366 0008 0023     		movs	r3, #0
 367 000a BB81     		strh	r3, [r7, #12]	@ movhi
 368              	.L19:
 273:App/Common/Minimal/dynamic.c **** 
 274:App/Common/Minimal/dynamic.c **** 	/* Just to stop warning messages. */
 275:App/Common/Minimal/dynamic.c **** 	( void ) pvParameters;
 276:App/Common/Minimal/dynamic.c **** 
 277:App/Common/Minimal/dynamic.c **** 	for( ;; )
 278:App/Common/Minimal/dynamic.c **** 	{
 279:App/Common/Minimal/dynamic.c **** 		/* Start with the counter at zero. */
 280:App/Common/Minimal/dynamic.c **** 		ulCounter = ( unsigned long ) 0;
 369              		.loc 1 280 0
 370 000c 274B     		ldr	r3, .L20
 371 000e 0022     		movs	r2, #0
 372 0010 1A60     		str	r2, [r3]
 281:App/Common/Minimal/dynamic.c **** 
 282:App/Common/Minimal/dynamic.c **** 		/* First section : */
 283:App/Common/Minimal/dynamic.c **** 
 284:App/Common/Minimal/dynamic.c **** 		/* Check the continuous count task is running. */
 285:App/Common/Minimal/dynamic.c **** 		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 373              		.loc 1 285 0
 374 0012 0023     		movs	r3, #0
 375 0014 FB81     		strh	r3, [r7, #14]	@ movhi
 376 0016 1DE0     		b	.L14
 377              	.L16:
 286:App/Common/Minimal/dynamic.c **** 		{
 287:App/Common/Minimal/dynamic.c **** 			/* Suspend the continuous count task so we can take a mirror of the
 288:App/Common/Minimal/dynamic.c **** 			shared variable without risk of corruption.  This is not really
 289:App/Common/Minimal/dynamic.c **** 			needed as the other task raises its priority above this task's
 290:App/Common/Minimal/dynamic.c **** 			priority. */
 291:App/Common/Minimal/dynamic.c **** 			vTaskSuspend( xContinuousIncrementHandle );
 378              		.loc 1 291 0
 379 0018 254B     		ldr	r3, .L20+4
 380 001a 1B68     		ldr	r3, [r3]
 381 001c 1846     		mov	r0, r3
 382 001e FFF7FEFF 		bl	vTaskSuspend
 292:App/Common/Minimal/dynamic.c **** 			{
 293:App/Common/Minimal/dynamic.c **** 				#if( INCLUDE_eTaskGetState == 1 )
 294:App/Common/Minimal/dynamic.c **** 				{
 295:App/Common/Minimal/dynamic.c **** 					configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eSuspended );
 296:App/Common/Minimal/dynamic.c **** 				}
 297:App/Common/Minimal/dynamic.c **** 				#endif /* INCLUDE_eTaskGetState */
 298:App/Common/Minimal/dynamic.c **** 
 299:App/Common/Minimal/dynamic.c **** 				ulLastCounter = ulCounter;
 383              		.loc 1 299 0
 384 0022 224B     		ldr	r3, .L20
 385 0024 1B68     		ldr	r3, [r3]
 386 0026 BB60     		str	r3, [r7, #8]
 300:App/Common/Minimal/dynamic.c **** 			}
 301:App/Common/Minimal/dynamic.c **** 			vTaskResume( xContinuousIncrementHandle );
 387              		.loc 1 301 0
 388 0028 214B     		ldr	r3, .L20+4
 389 002a 1B68     		ldr	r3, [r3]
 390 002c 1846     		mov	r0, r3
 391 002e FFF7FEFF 		bl	vTaskResume
 302:App/Common/Minimal/dynamic.c **** 
 303:App/Common/Minimal/dynamic.c **** 			#if( INCLUDE_eTaskGetState == 1 )
 304:App/Common/Minimal/dynamic.c **** 			{
 305:App/Common/Minimal/dynamic.c **** 				configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eReady );
 306:App/Common/Minimal/dynamic.c **** 			}
 307:App/Common/Minimal/dynamic.c **** 			#endif /* INCLUDE_eTaskGetState */
 308:App/Common/Minimal/dynamic.c **** 
 309:App/Common/Minimal/dynamic.c **** 			/* Now delay to ensure the other task has processor time. */
 310:App/Common/Minimal/dynamic.c **** 			vTaskDelay( priSLEEP_TIME );
 392              		.loc 1 310 0
 393 0032 8020     		movs	r0, #128
 394 0034 FFF7FEFF 		bl	vTaskDelay
 311:App/Common/Minimal/dynamic.c **** 
 312:App/Common/Minimal/dynamic.c **** 			/* Check the shared variable again.  This time to ensure mutual
 313:App/Common/Minimal/dynamic.c **** 			exclusion the whole scheduler will be locked.  This is just for
 314:App/Common/Minimal/dynamic.c **** 			demo purposes! */
 315:App/Common/Minimal/dynamic.c **** 			vTaskSuspendAll();
 395              		.loc 1 315 0
 396 0038 FFF7FEFF 		bl	vTaskSuspendAll
 316:App/Common/Minimal/dynamic.c **** 			{
 317:App/Common/Minimal/dynamic.c **** 				if( ulLastCounter == ulCounter )
 397              		.loc 1 317 0
 398 003c 1B4B     		ldr	r3, .L20
 399 003e 1B68     		ldr	r3, [r3]
 400 0040 BA68     		ldr	r2, [r7, #8]
 401 0042 9A42     		cmp	r2, r3
 402 0044 01D1     		bne	.L15
 318:App/Common/Minimal/dynamic.c **** 				{
 319:App/Common/Minimal/dynamic.c **** 					/* The shared variable has not changed.  There is a problem
 320:App/Common/Minimal/dynamic.c **** 					with the continuous count task so flag an error. */
 321:App/Common/Minimal/dynamic.c **** 					sError = pdTRUE;
 403              		.loc 1 321 0
 404 0046 0123     		movs	r3, #1
 405 0048 BB81     		strh	r3, [r7, #12]	@ movhi
 406              	.L15:
 322:App/Common/Minimal/dynamic.c **** 				}
 323:App/Common/Minimal/dynamic.c **** 			}
 324:App/Common/Minimal/dynamic.c **** 			xTaskResumeAll();
 407              		.loc 1 324 0
 408 004a FFF7FEFF 		bl	xTaskResumeAll
 285:App/Common/Minimal/dynamic.c **** 		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 409              		.loc 1 285 0
 410 004e FB89     		ldrh	r3, [r7, #14]
 411 0050 0133     		adds	r3, r3, #1
 412 0052 FB81     		strh	r3, [r7, #14]	@ movhi
 413              	.L14:
 285:App/Common/Minimal/dynamic.c **** 		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 414              		.loc 1 285 0 is_stmt 0 discriminator 1
 415 0054 B7F90E30 		ldrsh	r3, [r7, #14]
 416 0058 042B     		cmp	r3, #4
 417 005a DDDD     		ble	.L16
 325:App/Common/Minimal/dynamic.c **** 		}
 326:App/Common/Minimal/dynamic.c **** 
 327:App/Common/Minimal/dynamic.c **** 		/* Second section: */
 328:App/Common/Minimal/dynamic.c **** 
 329:App/Common/Minimal/dynamic.c **** 		/* Suspend the continuous counter task so it stops accessing the shared
 330:App/Common/Minimal/dynamic.c **** 		variable. */
 331:App/Common/Minimal/dynamic.c **** 		vTaskSuspend( xContinuousIncrementHandle );
 418              		.loc 1 331 0 is_stmt 1
 419 005c 144B     		ldr	r3, .L20+4
 420 005e 1B68     		ldr	r3, [r3]
 421 0060 1846     		mov	r0, r3
 422 0062 FFF7FEFF 		bl	vTaskSuspend
 332:App/Common/Minimal/dynamic.c **** 
 333:App/Common/Minimal/dynamic.c **** 		/* Reset the variable. */
 334:App/Common/Minimal/dynamic.c **** 		ulCounter = ( unsigned long ) 0;
 423              		.loc 1 334 0
 424 0066 114B     		ldr	r3, .L20
 425 0068 0022     		movs	r2, #0
 426 006a 1A60     		str	r2, [r3]
 335:App/Common/Minimal/dynamic.c **** 
 336:App/Common/Minimal/dynamic.c **** 		#if( INCLUDE_eTaskGetState == 1 )
 337:App/Common/Minimal/dynamic.c **** 		{
 338:App/Common/Minimal/dynamic.c **** 			configASSERT( eTaskGetState( xLimitedIncrementHandle ) == eSuspended );
 339:App/Common/Minimal/dynamic.c **** 		}
 340:App/Common/Minimal/dynamic.c **** 		#endif /* INCLUDE_eTaskGetState */
 341:App/Common/Minimal/dynamic.c **** 
 342:App/Common/Minimal/dynamic.c **** 		/* Resume the limited count task which has a higher priority than us.
 343:App/Common/Minimal/dynamic.c **** 		We should therefore not return from this call until the limited count
 344:App/Common/Minimal/dynamic.c **** 		task has suspended itself with a known value in the counter variable. */
 345:App/Common/Minimal/dynamic.c **** 		vTaskResume( xLimitedIncrementHandle );
 427              		.loc 1 345 0
 428 006c 114B     		ldr	r3, .L20+8
 429 006e 1B68     		ldr	r3, [r3]
 430 0070 1846     		mov	r0, r3
 431 0072 FFF7FEFF 		bl	vTaskResume
 346:App/Common/Minimal/dynamic.c **** 
 347:App/Common/Minimal/dynamic.c **** 		/* This task should not run again until xLimitedIncrementHandle has
 348:App/Common/Minimal/dynamic.c **** 		suspended itself. */
 349:App/Common/Minimal/dynamic.c **** 		#if( INCLUDE_eTaskGetState == 1 )
 350:App/Common/Minimal/dynamic.c **** 		{
 351:App/Common/Minimal/dynamic.c **** 			configASSERT( eTaskGetState( xLimitedIncrementHandle ) == eSuspended );
 352:App/Common/Minimal/dynamic.c **** 		}
 353:App/Common/Minimal/dynamic.c **** 		#endif /* INCLUDE_eTaskGetState */
 354:App/Common/Minimal/dynamic.c **** 
 355:App/Common/Minimal/dynamic.c **** 		/* Does the counter variable have the expected value? */
 356:App/Common/Minimal/dynamic.c **** 		if( ulCounter != priMAX_COUNT )
 432              		.loc 1 356 0
 433 0076 0D4B     		ldr	r3, .L20
 434 0078 1B68     		ldr	r3, [r3]
 435 007a FF2B     		cmp	r3, #255
 436 007c 01D0     		beq	.L17
 357:App/Common/Minimal/dynamic.c **** 		{
 358:App/Common/Minimal/dynamic.c **** 			sError = pdTRUE;
 437              		.loc 1 358 0
 438 007e 0123     		movs	r3, #1
 439 0080 BB81     		strh	r3, [r7, #12]	@ movhi
 440              	.L17:
 359:App/Common/Minimal/dynamic.c **** 		}
 360:App/Common/Minimal/dynamic.c **** 
 361:App/Common/Minimal/dynamic.c **** 		if( sError == pdFALSE )
 441              		.loc 1 361 0
 442 0082 B7F90C30 		ldrsh	r3, [r7, #12]
 443 0086 002B     		cmp	r3, #0
 444 0088 0AD1     		bne	.L18
 362:App/Common/Minimal/dynamic.c **** 		{
 363:App/Common/Minimal/dynamic.c **** 			/* If no errors have occurred then increment the check variable. */
 364:App/Common/Minimal/dynamic.c **** 			portENTER_CRITICAL();
 445              		.loc 1 364 0
 446 008a FFF7FEFF 		bl	vPortEnterCritical
 365:App/Common/Minimal/dynamic.c **** 				usCheckVariable++;
 447              		.loc 1 365 0
 448 008e 0A4B     		ldr	r3, .L20+12
 449 0090 1B88     		ldrh	r3, [r3]	@ movhi
 450 0092 9BB2     		uxth	r3, r3
 451 0094 0133     		adds	r3, r3, #1
 452 0096 9AB2     		uxth	r2, r3
 453 0098 074B     		ldr	r3, .L20+12
 454 009a 1A80     		strh	r2, [r3]	@ movhi
 366:App/Common/Minimal/dynamic.c **** 			portEXIT_CRITICAL();
 455              		.loc 1 366 0
 456 009c FFF7FEFF 		bl	vPortExitCritical
 457              	.L18:
 367:App/Common/Minimal/dynamic.c **** 		}
 368:App/Common/Minimal/dynamic.c **** 
 369:App/Common/Minimal/dynamic.c **** 		/* Resume the continuous count task and do it all again. */
 370:App/Common/Minimal/dynamic.c **** 		vTaskResume( xContinuousIncrementHandle );
 458              		.loc 1 370 0
 459 00a0 034B     		ldr	r3, .L20+4
 460 00a2 1B68     		ldr	r3, [r3]
 461 00a4 1846     		mov	r0, r3
 462 00a6 FFF7FEFF 		bl	vTaskResume
 371:App/Common/Minimal/dynamic.c **** 	}
 463              		.loc 1 371 0
 464 00aa AFE7     		b	.L19
 465              	.L21:
 466              		.align	2
 467              	.L20:
 468 00ac 00000000 		.word	ulCounter
 469 00b0 00000000 		.word	xContinuousIncrementHandle
 470 00b4 00000000 		.word	xLimitedIncrementHandle
 471 00b8 00000000 		.word	usCheckVariable
 472              		.cfi_endproc
 473              	.LFE113:
 475              		.section	.text.vQueueSendWhenSuspendedTask,"ax",%progbits
 476              		.align	2
 477              		.thumb
 478              		.thumb_func
 480              	vQueueSendWhenSuspendedTask:
 481              	.LFB114:
 372:App/Common/Minimal/dynamic.c **** }
 373:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 374:App/Common/Minimal/dynamic.c **** 
 375:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
 376:App/Common/Minimal/dynamic.c **** {
 482              		.loc 1 376 0
 483              		.cfi_startproc
 484              		@ args = 0, pretend = 0, frame = 8
 485              		@ frame_needed = 1, uses_anonymous_args = 0
 486 0000 80B5     		push	{r7, lr}
 487              	.LCFI12:
 488              		.cfi_def_cfa_offset 8
 489              		.cfi_offset 7, -8
 490              		.cfi_offset 14, -4
 491 0002 82B0     		sub	sp, sp, #8
 492              	.LCFI13:
 493              		.cfi_def_cfa_offset 16
 494 0004 00AF     		add	r7, sp, #0
 495              	.LCFI14:
 496              		.cfi_def_cfa_register 7
 497 0006 7860     		str	r0, [r7, #4]
 498              	.L24:
 377:App/Common/Minimal/dynamic.c **** static unsigned long ulValueToSend = ( unsigned long ) 0;
 378:App/Common/Minimal/dynamic.c **** 
 379:App/Common/Minimal/dynamic.c **** 	/* Just to stop warning messages. */
 380:App/Common/Minimal/dynamic.c **** 	( void ) pvParameters;
 381:App/Common/Minimal/dynamic.c **** 
 382:App/Common/Minimal/dynamic.c **** 	for( ;; )
 383:App/Common/Minimal/dynamic.c **** 	{
 384:App/Common/Minimal/dynamic.c **** 		vTaskSuspendAll();
 499              		.loc 1 384 0
 500 0008 FFF7FEFF 		bl	vTaskSuspendAll
 385:App/Common/Minimal/dynamic.c **** 		{
 386:App/Common/Minimal/dynamic.c **** 			/* We must not block while the scheduler is suspended! */
 387:App/Common/Minimal/dynamic.c **** 			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
 501              		.loc 1 387 0
 502 000c 0C4B     		ldr	r3, .L25
 503 000e 1B68     		ldr	r3, [r3]
 504 0010 1846     		mov	r0, r3
 505 0012 0C49     		ldr	r1, .L25+4
 506 0014 0022     		movs	r2, #0
 507 0016 0023     		movs	r3, #0
 508 0018 FFF7FEFF 		bl	xQueueGenericSend
 509 001c 0346     		mov	r3, r0
 510 001e 012B     		cmp	r3, #1
 511 0020 02D0     		beq	.L23
 388:App/Common/Minimal/dynamic.c **** 			{
 389:App/Common/Minimal/dynamic.c **** 				xSuspendedQueueSendError = pdTRUE;
 512              		.loc 1 389 0
 513 0022 094B     		ldr	r3, .L25+8
 514 0024 0122     		movs	r2, #1
 515 0026 1A60     		str	r2, [r3]
 516              	.L23:
 390:App/Common/Minimal/dynamic.c **** 			}
 391:App/Common/Minimal/dynamic.c **** 		}
 392:App/Common/Minimal/dynamic.c **** 		xTaskResumeAll();
 517              		.loc 1 392 0
 518 0028 FFF7FEFF 		bl	xTaskResumeAll
 393:App/Common/Minimal/dynamic.c **** 
 394:App/Common/Minimal/dynamic.c **** 		vTaskDelay( priSLEEP_TIME );
 519              		.loc 1 394 0
 520 002c 8020     		movs	r0, #128
 521 002e FFF7FEFF 		bl	vTaskDelay
 395:App/Common/Minimal/dynamic.c **** 
 396:App/Common/Minimal/dynamic.c **** 		++ulValueToSend;
 522              		.loc 1 396 0
 523 0032 044B     		ldr	r3, .L25+4
 524 0034 1B68     		ldr	r3, [r3]
 525 0036 5A1C     		adds	r2, r3, #1
 526 0038 024B     		ldr	r3, .L25+4
 527 003a 1A60     		str	r2, [r3]
 397:App/Common/Minimal/dynamic.c **** 	}
 528              		.loc 1 397 0
 529 003c E4E7     		b	.L24
 530              	.L26:
 531 003e 00BF     		.align	2
 532              	.L25:
 533 0040 00000000 		.word	xSuspendedTestQueue
 534 0044 00000000 		.word	ulValueToSend.8240
 535 0048 00000000 		.word	xSuspendedQueueSendError
 536              		.cfi_endproc
 537              	.LFE114:
 539              		.section	.text.vQueueReceiveWhenSuspendedTask,"ax",%progbits
 540              		.align	2
 541              		.thumb
 542              		.thumb_func
 544              	vQueueReceiveWhenSuspendedTask:
 545              	.LFB115:
 398:App/Common/Minimal/dynamic.c **** }
 399:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 400:App/Common/Minimal/dynamic.c **** 
 401:App/Common/Minimal/dynamic.c **** static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
 402:App/Common/Minimal/dynamic.c **** {
 546              		.loc 1 402 0
 547              		.cfi_startproc
 548              		@ args = 0, pretend = 0, frame = 16
 549              		@ frame_needed = 1, uses_anonymous_args = 0
 550 0000 80B5     		push	{r7, lr}
 551              	.LCFI15:
 552              		.cfi_def_cfa_offset 8
 553              		.cfi_offset 7, -8
 554              		.cfi_offset 14, -4
 555 0002 84B0     		sub	sp, sp, #16
 556              	.LCFI16:
 557              		.cfi_def_cfa_offset 24
 558 0004 00AF     		add	r7, sp, #0
 559              	.LCFI17:
 560              		.cfi_def_cfa_register 7
 561 0006 7860     		str	r0, [r7, #4]
 562              	.L29:
 403:App/Common/Minimal/dynamic.c **** unsigned long ulReceivedValue;
 404:App/Common/Minimal/dynamic.c **** portBASE_TYPE xGotValue;
 405:App/Common/Minimal/dynamic.c **** 
 406:App/Common/Minimal/dynamic.c **** 	/* Just to stop warning messages. */
 407:App/Common/Minimal/dynamic.c **** 	( void ) pvParameters;
 408:App/Common/Minimal/dynamic.c **** 
 409:App/Common/Minimal/dynamic.c **** 	for( ;; )
 410:App/Common/Minimal/dynamic.c **** 	{
 411:App/Common/Minimal/dynamic.c **** 		do
 412:App/Common/Minimal/dynamic.c **** 		{
 413:App/Common/Minimal/dynamic.c **** 			/* Suspending the scheduler here is fairly pointless and
 414:App/Common/Minimal/dynamic.c **** 			undesirable for a normal application.  It is done here purely
 415:App/Common/Minimal/dynamic.c **** 			to test the scheduler.  The inner xTaskResumeAll() should
 416:App/Common/Minimal/dynamic.c **** 			never return pdTRUE as the scheduler is still locked by the
 417:App/Common/Minimal/dynamic.c **** 			outer call. */
 418:App/Common/Minimal/dynamic.c **** 			vTaskSuspendAll();
 563              		.loc 1 418 0
 564 0008 FFF7FEFF 		bl	vTaskSuspendAll
 419:App/Common/Minimal/dynamic.c **** 			{
 420:App/Common/Minimal/dynamic.c **** 				vTaskSuspendAll();
 565              		.loc 1 420 0
 566 000c FFF7FEFF 		bl	vTaskSuspendAll
 421:App/Common/Minimal/dynamic.c **** 				{
 422:App/Common/Minimal/dynamic.c **** 					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
 567              		.loc 1 422 0
 568 0010 154B     		ldr	r3, .L32
 569 0012 1A68     		ldr	r2, [r3]
 570 0014 07F10803 		add	r3, r7, #8
 571 0018 1046     		mov	r0, r2
 572 001a 1946     		mov	r1, r3
 573 001c 0022     		movs	r2, #0
 574 001e 0023     		movs	r3, #0
 575 0020 FFF7FEFF 		bl	xQueueGenericReceive
 576 0024 F860     		str	r0, [r7, #12]
 423:App/Common/Minimal/dynamic.c **** 				}
 424:App/Common/Minimal/dynamic.c **** 				if( xTaskResumeAll() != pdFALSE )
 577              		.loc 1 424 0
 578 0026 FFF7FEFF 		bl	xTaskResumeAll
 579 002a 0346     		mov	r3, r0
 580 002c 002B     		cmp	r3, #0
 581 002e 02D0     		beq	.L28
 425:App/Common/Minimal/dynamic.c **** 				{
 426:App/Common/Minimal/dynamic.c **** 					xSuspendedQueueReceiveError = pdTRUE;
 582              		.loc 1 426 0
 583 0030 0E4B     		ldr	r3, .L32+4
 584 0032 0122     		movs	r2, #1
 585 0034 1A60     		str	r2, [r3]
 586              	.L28:
 427:App/Common/Minimal/dynamic.c **** 				}
 428:App/Common/Minimal/dynamic.c **** 			}
 429:App/Common/Minimal/dynamic.c **** 			xTaskResumeAll();
 587              		.loc 1 429 0
 588 0036 FFF7FEFF 		bl	xTaskResumeAll
 430:App/Common/Minimal/dynamic.c **** 
 431:App/Common/Minimal/dynamic.c **** 			#if configUSE_PREEMPTION == 0
 432:App/Common/Minimal/dynamic.c **** 			{
 433:App/Common/Minimal/dynamic.c **** 				taskYIELD();
 434:App/Common/Minimal/dynamic.c **** 			}
 435:App/Common/Minimal/dynamic.c **** 			#endif
 436:App/Common/Minimal/dynamic.c **** 
 437:App/Common/Minimal/dynamic.c **** 		} while( xGotValue == pdFALSE );
 589              		.loc 1 437 0
 590 003a FB68     		ldr	r3, [r7, #12]
 591 003c 002B     		cmp	r3, #0
 592 003e E3D0     		beq	.L29
 438:App/Common/Minimal/dynamic.c **** 
 439:App/Common/Minimal/dynamic.c **** 		if( ulReceivedValue != ulExpectedValue )
 593              		.loc 1 439 0
 594 0040 BA68     		ldr	r2, [r7, #8]
 595 0042 0B4B     		ldr	r3, .L32+8
 596 0044 1B68     		ldr	r3, [r3]
 597 0046 9A42     		cmp	r2, r3
 598 0048 02D0     		beq	.L30
 440:App/Common/Minimal/dynamic.c **** 		{
 441:App/Common/Minimal/dynamic.c **** 			xSuspendedQueueReceiveError = pdTRUE;
 599              		.loc 1 441 0
 600 004a 084B     		ldr	r3, .L32+4
 601 004c 0122     		movs	r2, #1
 602 004e 1A60     		str	r2, [r3]
 603              	.L30:
 442:App/Common/Minimal/dynamic.c **** 		}
 443:App/Common/Minimal/dynamic.c **** 
 444:App/Common/Minimal/dynamic.c **** 		if( xSuspendedQueueReceiveError != pdTRUE )
 604              		.loc 1 444 0
 605 0050 064B     		ldr	r3, .L32+4
 606 0052 1B68     		ldr	r3, [r3]
 607 0054 012B     		cmp	r3, #1
 608 0056 05D0     		beq	.L31
 445:App/Common/Minimal/dynamic.c **** 		{
 446:App/Common/Minimal/dynamic.c **** 			/* Only increment the variable if an error has not occurred.  This
 447:App/Common/Minimal/dynamic.c **** 			allows xAreDynamicPriorityTasksStillRunning() to check for stalled
 448:App/Common/Minimal/dynamic.c **** 			tasks as well as explicit errors. */
 449:App/Common/Minimal/dynamic.c **** 			++ulExpectedValue;
 609              		.loc 1 449 0
 610 0058 054B     		ldr	r3, .L32+8
 611 005a 1B68     		ldr	r3, [r3]
 612 005c 5A1C     		adds	r2, r3, #1
 613 005e 044B     		ldr	r3, .L32+8
 614 0060 1A60     		str	r2, [r3]
 450:App/Common/Minimal/dynamic.c **** 		}
 451:App/Common/Minimal/dynamic.c **** 	}
 615              		.loc 1 451 0
 616 0062 D1E7     		b	.L29
 617              	.L31:
 618 0064 D0E7     		b	.L29
 619              	.L33:
 620 0066 00BF     		.align	2
 621              	.L32:
 622 0068 00000000 		.word	xSuspendedTestQueue
 623 006c 00000000 		.word	xSuspendedQueueReceiveError
 624 0070 00000000 		.word	ulExpectedValue
 625              		.cfi_endproc
 626              	.LFE115:
 628              		.section	.text.xAreDynamicPriorityTasksStillRunning,"ax",%progbits
 629              		.align	2
 630              		.global	xAreDynamicPriorityTasksStillRunning
 631              		.thumb
 632              		.thumb_func
 634              	xAreDynamicPriorityTasksStillRunning:
 635              	.LFB116:
 452:App/Common/Minimal/dynamic.c **** }
 453:App/Common/Minimal/dynamic.c **** /*-----------------------------------------------------------*/
 454:App/Common/Minimal/dynamic.c **** 
 455:App/Common/Minimal/dynamic.c **** /* Called to check that all the created tasks are still running without error. */
 456:App/Common/Minimal/dynamic.c **** portBASE_TYPE xAreDynamicPriorityTasksStillRunning( void )
 457:App/Common/Minimal/dynamic.c **** {
 636              		.loc 1 457 0
 637              		.cfi_startproc
 638              		@ args = 0, pretend = 0, frame = 8
 639              		@ frame_needed = 1, uses_anonymous_args = 0
 640              		@ link register save eliminated.
 641 0000 80B4     		push	{r7}
 642              	.LCFI18:
 643              		.cfi_def_cfa_offset 4
 644              		.cfi_offset 7, -4
 645 0002 83B0     		sub	sp, sp, #12
 646              	.LCFI19:
 647              		.cfi_def_cfa_offset 16
 648 0004 00AF     		add	r7, sp, #0
 649              	.LCFI20:
 650              		.cfi_def_cfa_register 7
 458:App/Common/Minimal/dynamic.c **** /* Keep a history of the check variables so we know if it has been incremented
 459:App/Common/Minimal/dynamic.c **** since the last call. */
 460:App/Common/Minimal/dynamic.c **** static unsigned short usLastTaskCheck = ( unsigned short ) 0;
 461:App/Common/Minimal/dynamic.c **** static unsigned long ulLastExpectedValue = ( unsigned long ) 0U;
 462:App/Common/Minimal/dynamic.c **** portBASE_TYPE xReturn = pdTRUE;
 651              		.loc 1 462 0
 652 0006 0123     		movs	r3, #1
 653 0008 7B60     		str	r3, [r7, #4]
 463:App/Common/Minimal/dynamic.c **** 
 464:App/Common/Minimal/dynamic.c **** 	/* Check the tasks are still running by ensuring the check variable
 465:App/Common/Minimal/dynamic.c **** 	is still incrementing. */
 466:App/Common/Minimal/dynamic.c **** 
 467:App/Common/Minimal/dynamic.c **** 	if( usCheckVariable == usLastTaskCheck )
 654              		.loc 1 467 0
 655 000a 164B     		ldr	r3, .L40
 656 000c 1B88     		ldrh	r3, [r3]	@ movhi
 657 000e 9AB2     		uxth	r2, r3
 658 0010 154B     		ldr	r3, .L40+4
 659 0012 1B88     		ldrh	r3, [r3]
 660 0014 9A42     		cmp	r2, r3
 661 0016 01D1     		bne	.L35
 468:App/Common/Minimal/dynamic.c **** 	{
 469:App/Common/Minimal/dynamic.c **** 		/* The check has not incremented so an error exists. */
 470:App/Common/Minimal/dynamic.c **** 		xReturn = pdFALSE;
 662              		.loc 1 470 0
 663 0018 0023     		movs	r3, #0
 664 001a 7B60     		str	r3, [r7, #4]
 665              	.L35:
 471:App/Common/Minimal/dynamic.c **** 	}
 472:App/Common/Minimal/dynamic.c **** 
 473:App/Common/Minimal/dynamic.c **** 	if( ulExpectedValue == ulLastExpectedValue )
 666              		.loc 1 473 0
 667 001c 134B     		ldr	r3, .L40+8
 668 001e 1A68     		ldr	r2, [r3]
 669 0020 134B     		ldr	r3, .L40+12
 670 0022 1B68     		ldr	r3, [r3]
 671 0024 9A42     		cmp	r2, r3
 672 0026 01D1     		bne	.L36
 474:App/Common/Minimal/dynamic.c **** 	{
 475:App/Common/Minimal/dynamic.c **** 		/* The value being received by the queue receive task has not
 476:App/Common/Minimal/dynamic.c **** 		incremented so an error exists. */
 477:App/Common/Minimal/dynamic.c **** 		xReturn = pdFALSE;
 673              		.loc 1 477 0
 674 0028 0023     		movs	r3, #0
 675 002a 7B60     		str	r3, [r7, #4]
 676              	.L36:
 478:App/Common/Minimal/dynamic.c **** 	}
 479:App/Common/Minimal/dynamic.c **** 
 480:App/Common/Minimal/dynamic.c **** 	if( xSuspendedQueueSendError == pdTRUE )
 677              		.loc 1 480 0
 678 002c 114B     		ldr	r3, .L40+16
 679 002e 1B68     		ldr	r3, [r3]
 680 0030 012B     		cmp	r3, #1
 681 0032 01D1     		bne	.L37
 481:App/Common/Minimal/dynamic.c **** 	{
 482:App/Common/Minimal/dynamic.c **** 		xReturn = pdFALSE;
 682              		.loc 1 482 0
 683 0034 0023     		movs	r3, #0
 684 0036 7B60     		str	r3, [r7, #4]
 685              	.L37:
 483:App/Common/Minimal/dynamic.c **** 	}
 484:App/Common/Minimal/dynamic.c **** 
 485:App/Common/Minimal/dynamic.c **** 	if( xSuspendedQueueReceiveError == pdTRUE )
 686              		.loc 1 485 0
 687 0038 0F4B     		ldr	r3, .L40+20
 688 003a 1B68     		ldr	r3, [r3]
 689 003c 012B     		cmp	r3, #1
 690 003e 01D1     		bne	.L38
 486:App/Common/Minimal/dynamic.c **** 	{
 487:App/Common/Minimal/dynamic.c **** 		xReturn = pdFALSE;
 691              		.loc 1 487 0
 692 0040 0023     		movs	r3, #0
 693 0042 7B60     		str	r3, [r7, #4]
 694              	.L38:
 488:App/Common/Minimal/dynamic.c **** 	}
 489:App/Common/Minimal/dynamic.c **** 
 490:App/Common/Minimal/dynamic.c **** 	usLastTaskCheck = usCheckVariable;
 695              		.loc 1 490 0
 696 0044 074B     		ldr	r3, .L40
 697 0046 1B88     		ldrh	r3, [r3]	@ movhi
 698 0048 9AB2     		uxth	r2, r3
 699 004a 074B     		ldr	r3, .L40+4
 700 004c 1A80     		strh	r2, [r3]	@ movhi
 491:App/Common/Minimal/dynamic.c **** 	ulLastExpectedValue = ulExpectedValue;
 701              		.loc 1 491 0
 702 004e 074B     		ldr	r3, .L40+8
 703 0050 1A68     		ldr	r2, [r3]
 704 0052 074B     		ldr	r3, .L40+12
 705 0054 1A60     		str	r2, [r3]
 492:App/Common/Minimal/dynamic.c **** 
 493:App/Common/Minimal/dynamic.c **** 	return xReturn;
 706              		.loc 1 493 0
 707 0056 7B68     		ldr	r3, [r7, #4]
 494:App/Common/Minimal/dynamic.c **** }
 708              		.loc 1 494 0
 709 0058 1846     		mov	r0, r3
 710 005a 0C37     		adds	r7, r7, #12
 711 005c BD46     		mov	sp, r7
 712              		@ sp needed
 713 005e 5DF8047B 		ldr	r7, [sp], #4
 714 0062 7047     		bx	lr
 715              	.L41:
 716              		.align	2
 717              	.L40:
 718 0064 00000000 		.word	usCheckVariable
 719 0068 00000000 		.word	usLastTaskCheck.8253
 720 006c 00000000 		.word	ulExpectedValue
 721 0070 00000000 		.word	ulLastExpectedValue.8254
 722 0074 00000000 		.word	xSuspendedQueueSendError
 723 0078 00000000 		.word	xSuspendedQueueReceiveError
 724              		.cfi_endproc
 725              	.LFE116:
 727              		.section	.bss.ulValueToSend.8240,"aw",%nobits
 728              		.align	2
 731              	ulValueToSend.8240:
 732 0000 00000000 		.space	4
 733              		.section	.bss.usLastTaskCheck.8253,"aw",%nobits
 734              		.align	1
 737              	usLastTaskCheck.8253:
 738 0000 0000     		.space	2
 739              		.section	.bss.ulLastExpectedValue.8254,"aw",%nobits
 740              		.align	2
 743              	ulLastExpectedValue.8254:
 744 0000 00000000 		.space	4
 745              		.text
 746              	.Letext0:
 747              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 748              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 749              		.file 4 "Source/include/task.h"
 750              		.file 5 "Source/include/queue.h"
 751              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 dynamic.c
     /tmp/ccpJIvhO.s:20     .bss.xContinuousIncrementHandle:00000000 $d
     /tmp/ccpJIvhO.s:23     .bss.xContinuousIncrementHandle:00000000 xContinuousIncrementHandle
     /tmp/ccpJIvhO.s:26     .bss.xLimitedIncrementHandle:00000000 $d
     /tmp/ccpJIvhO.s:29     .bss.xLimitedIncrementHandle:00000000 xLimitedIncrementHandle
     /tmp/ccpJIvhO.s:32     .bss.ulCounter:00000000 $d
     /tmp/ccpJIvhO.s:35     .bss.ulCounter:00000000 ulCounter
     /tmp/ccpJIvhO.s:38     .bss.usCheckVariable:00000000 $d
     /tmp/ccpJIvhO.s:41     .bss.usCheckVariable:00000000 usCheckVariable
     /tmp/ccpJIvhO.s:44     .bss.xSuspendedQueueSendError:00000000 $d
     /tmp/ccpJIvhO.s:47     .bss.xSuspendedQueueSendError:00000000 xSuspendedQueueSendError
     /tmp/ccpJIvhO.s:50     .bss.xSuspendedQueueReceiveError:00000000 $d
     /tmp/ccpJIvhO.s:53     .bss.xSuspendedQueueReceiveError:00000000 xSuspendedQueueReceiveError
                            *COM*:00000004 xSuspendedTestQueue
     /tmp/ccpJIvhO.s:57     .bss.ulExpectedValue:00000000 $d
     /tmp/ccpJIvhO.s:60     .bss.ulExpectedValue:00000000 ulExpectedValue
     /tmp/ccpJIvhO.s:63     .rodata:00000000 $d
     /tmp/ccpJIvhO.s:82     .text.vStartDynamicPriorityTasks:00000000 $t
     /tmp/ccpJIvhO.s:87     .text.vStartDynamicPriorityTasks:00000000 vStartDynamicPriorityTasks
     /tmp/ccpJIvhO.s:196    .text.vStartDynamicPriorityTasks:000000b4 $d
     /tmp/ccpJIvhO.s:270    .text.vContinuousIncrementTask:00000000 vContinuousIncrementTask
     /tmp/ccpJIvhO.s:219    .text.vLimitedIncrementTask:00000000 vLimitedIncrementTask
     /tmp/ccpJIvhO.s:347    .text.vCounterControlTask:00000000 vCounterControlTask
     /tmp/ccpJIvhO.s:480    .text.vQueueSendWhenSuspendedTask:00000000 vQueueSendWhenSuspendedTask
     /tmp/ccpJIvhO.s:544    .text.vQueueReceiveWhenSuspendedTask:00000000 vQueueReceiveWhenSuspendedTask
     /tmp/ccpJIvhO.s:215    .text.vLimitedIncrementTask:00000000 $t
     /tmp/ccpJIvhO.s:266    .text.vContinuousIncrementTask:00000000 $t
     /tmp/ccpJIvhO.s:343    .text.vCounterControlTask:00000000 $t
     /tmp/ccpJIvhO.s:468    .text.vCounterControlTask:000000ac $d
     /tmp/ccpJIvhO.s:476    .text.vQueueSendWhenSuspendedTask:00000000 $t
     /tmp/ccpJIvhO.s:533    .text.vQueueSendWhenSuspendedTask:00000040 $d
     /tmp/ccpJIvhO.s:731    .bss.ulValueToSend.8240:00000000 ulValueToSend.8240
     /tmp/ccpJIvhO.s:540    .text.vQueueReceiveWhenSuspendedTask:00000000 $t
     /tmp/ccpJIvhO.s:622    .text.vQueueReceiveWhenSuspendedTask:00000068 $d
     /tmp/ccpJIvhO.s:629    .text.xAreDynamicPriorityTasksStillRunning:00000000 $t
     /tmp/ccpJIvhO.s:634    .text.xAreDynamicPriorityTasksStillRunning:00000000 xAreDynamicPriorityTasksStillRunning
     /tmp/ccpJIvhO.s:718    .text.xAreDynamicPriorityTasksStillRunning:00000064 $d
     /tmp/ccpJIvhO.s:737    .bss.usLastTaskCheck.8253:00000000 usLastTaskCheck.8253
     /tmp/ccpJIvhO.s:743    .bss.ulLastExpectedValue.8254:00000000 ulLastExpectedValue.8254
     /tmp/ccpJIvhO.s:728    .bss.ulValueToSend.8240:00000000 $d
     /tmp/ccpJIvhO.s:734    .bss.usLastTaskCheck.8253:00000000 $d
     /tmp/ccpJIvhO.s:740    .bss.ulLastExpectedValue.8254:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericCreate
vQueueAddToRegistry
xTaskGenericCreate
vTaskSuspend
uxTaskPriorityGet
vTaskPrioritySet
ulPortSetInterruptMask
vTaskResume
vTaskDelay
vTaskSuspendAll
xTaskResumeAll
vPortEnterCritical
vPortExitCritical
xQueueGenericSend
xQueueGenericReceive
