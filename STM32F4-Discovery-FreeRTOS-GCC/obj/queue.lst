   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	xQueueRegistry,64,4
  20              		.section	.text.xQueueGenericReset,"ax",%progbits
  21              		.align	2
  22              		.global	xQueueGenericReset
  23              		.thumb
  24              		.thumb_func
  26              	xQueueGenericReset:
  27              	.LFB110:
  28              		.file 1 "Source/queue.c"
   1:Source/queue.c **** /*
   2:Source/queue.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/queue.c ****     All rights reserved
   4:Source/queue.c **** 
   5:Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/queue.c **** 
   7:Source/queue.c ****     ***************************************************************************
   8:Source/queue.c ****      *                                                                       *
   9:Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/queue.c ****      *    platform software that has become a de facto standard.             *
  12:Source/queue.c ****      *                                                                       *
  13:Source/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/queue.c ****      *                                                                       *
  17:Source/queue.c ****      *    Thank you!                                                         *
  18:Source/queue.c ****      *                                                                       *
  19:Source/queue.c ****     ***************************************************************************
  20:Source/queue.c **** 
  21:Source/queue.c ****     This file is part of the FreeRTOS distribution.
  22:Source/queue.c **** 
  23:Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/queue.c **** 
  27:Source/queue.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/queue.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/queue.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/queue.c ****     >>! kernel.
  31:Source/queue.c **** 
  32:Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/queue.c ****     link: http://www.freertos.org/a00114.html
  36:Source/queue.c **** 
  37:Source/queue.c ****     1 tab == 4 spaces!
  38:Source/queue.c **** 
  39:Source/queue.c ****     ***************************************************************************
  40:Source/queue.c ****      *                                                                       *
  41:Source/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/queue.c ****      *    not run, what could be wrong?"                                     *
  43:Source/queue.c ****      *                                                                       *
  44:Source/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/queue.c ****      *                                                                       *
  46:Source/queue.c ****     ***************************************************************************
  47:Source/queue.c **** 
  48:Source/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/queue.c **** 
  51:Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/queue.c **** 
  55:Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/queue.c **** 
  59:Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/queue.c ****     mission critical applications that require provable dependability.
  62:Source/queue.c **** 
  63:Source/queue.c ****     1 tab == 4 spaces!
  64:Source/queue.c **** */
  65:Source/queue.c **** 
  66:Source/queue.c **** #include <stdlib.h>
  67:Source/queue.c **** #include <string.h>
  68:Source/queue.c **** 
  69:Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:Source/queue.c **** task.h is included from an application file. */
  72:Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:Source/queue.c **** 
  74:Source/queue.c **** #include "FreeRTOS.h"
  75:Source/queue.c **** #include "task.h"
  76:Source/queue.c **** #include "queue.h"
  77:Source/queue.c **** 
  78:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:Source/queue.c **** 	#include "croutine.h"
  80:Source/queue.c **** #endif
  81:Source/queue.c **** 
  82:Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:Source/queue.c **** header files above, but not in this file, in order to generate the correct
  85:Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:Source/queue.c **** 
  88:Source/queue.c **** 
  89:Source/queue.c **** /* Constants used with the cRxLock and xTxLock structure members. */
  90:Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  91:Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  92:Source/queue.c **** 
  93:Source/queue.c **** /* When the xQUEUE structure is used to represent a base queue its pcHead and
  94:Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:Source/queue.c **** xQUEUE structure is used to represent a mutex pcHead and pcTail pointers are
  96:Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:Source/queue.c **** against the coding standard (although an exception to the standard has been
 102:Source/queue.c **** permitted where the dual use also significantly changes the type of the
 103:Source/queue.c **** structure member). */
 104:Source/queue.c **** #define pxMutexHolder					pcTail
 105:Source/queue.c **** #define uxQueueType						pcHead
 106:Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 107:Source/queue.c **** 
 108:Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:Source/queue.c **** zero. */
 110:Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
 111:Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
 112:Source/queue.c **** 
 113:Source/queue.c **** 
 114:Source/queue.c **** /*
 115:Source/queue.c ****  * Definition of the queue used by the scheduler.
 116:Source/queue.c ****  * Items are queued by copy, not reference.
 117:Source/queue.c ****  */
 118:Source/queue.c **** typedef struct QueueDefinition
 119:Source/queue.c **** {
 120:Source/queue.c **** 	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
 121:Source/queue.c **** 	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more b
 122:Source/queue.c **** 
 123:Source/queue.c **** 	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
 124:Source/queue.c **** 
 125:Source/queue.c **** 	union									/* Use of a union is an exception to the coding standard to ensure two mutually excl
 126:Source/queue.c **** 	{
 127:Source/queue.c **** 		signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from when the
 128:Source/queue.c **** 		unsigned portBASE_TYPE uxRecursiveCallCount;/*< Maintains a count of the numebr of times a recurs
 129:Source/queue.c **** 	} u;
 130:Source/queue.c **** 
 131:Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 132:Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 133:Source/queue.c **** 
 134:Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 135:Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 136:Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 137:Source/queue.c **** 
 138:Source/queue.c **** 	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (rem
 139:Source/queue.c **** 	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (ad
 140:Source/queue.c **** 
 141:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 142:Source/queue.c **** 		unsigned char ucQueueNumber;
 143:Source/queue.c **** 		unsigned char ucQueueType;
 144:Source/queue.c **** 	#endif
 145:Source/queue.c **** 
 146:Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 147:Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 148:Source/queue.c **** 	#endif
 149:Source/queue.c **** 
 150:Source/queue.c **** } xQUEUE;
 151:Source/queue.c **** /*-----------------------------------------------------------*/
 152:Source/queue.c **** 
 153:Source/queue.c **** /*
 154:Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 155:Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 156:Source/queue.c ****  */
 157:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 158:Source/queue.c **** 
 159:Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 160:Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 161:Source/queue.c **** 	more user friendly. */
 162:Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 163:Source/queue.c **** 	{
 164:Source/queue.c **** 		signed char *pcQueueName;
 165:Source/queue.c **** 		xQueueHandle xHandle;
 166:Source/queue.c **** 	} xQueueRegistryItem;
 167:Source/queue.c **** 
 168:Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 169:Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 170:Source/queue.c **** 	array position being vacant. */
 171:Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 172:Source/queue.c **** 
 173:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 174:Source/queue.c **** 
 175:Source/queue.c **** /*
 176:Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 177:Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 178:Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 179:Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 180:Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 181:Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 182:Source/queue.c ****  */
 183:Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 184:Source/queue.c **** 
 185:Source/queue.c **** /*
 186:Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 187:Source/queue.c ****  *
 188:Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 189:Source/queue.c ****  */
 190:Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 191:Source/queue.c **** 
 192:Source/queue.c **** /*
 193:Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 194:Source/queue.c ****  *
 195:Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 196:Source/queue.c ****  */
 197:Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 198:Source/queue.c **** 
 199:Source/queue.c **** /*
 200:Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 201:Source/queue.c ****  * back of the queue.
 202:Source/queue.c ****  */
 203:Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 204:Source/queue.c **** 
 205:Source/queue.c **** /*
 206:Source/queue.c ****  * Copies an item out of a queue.
 207:Source/queue.c ****  */
 208:Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer ) PRIVILEGED_
 209:Source/queue.c **** 
 210:Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 211:Source/queue.c **** 	/*
 212:Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 213:Source/queue.c **** 	 * the queue set that the queue contains data.
 214:Source/queue.c **** 	 */
 215:Source/queue.c **** 	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopy
 216:Source/queue.c **** #endif
 217:Source/queue.c **** 
 218:Source/queue.c **** /*-----------------------------------------------------------*/
 219:Source/queue.c **** 
 220:Source/queue.c **** /*
 221:Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 222:Source/queue.c ****  * accessing the queue event lists.
 223:Source/queue.c ****  */
 224:Source/queue.c **** #define prvLockQueue( pxQueue )								\
 225:Source/queue.c **** 	taskENTER_CRITICAL();									\
 226:Source/queue.c **** 	{														\
 227:Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 228:Source/queue.c **** 		{													\
 229:Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 230:Source/queue.c **** 		}													\
 231:Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 232:Source/queue.c **** 		{													\
 233:Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 234:Source/queue.c **** 		}													\
 235:Source/queue.c **** 	}														\
 236:Source/queue.c **** 	taskEXIT_CRITICAL()
 237:Source/queue.c **** /*-----------------------------------------------------------*/
 238:Source/queue.c **** 
 239:Source/queue.c **** portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
 240:Source/queue.c **** {
  29              		.loc 1 240 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 84B0     		sub	sp, sp, #16
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 24
  41 0004 00AF     		add	r7, sp, #0
  42              	.LCFI2:
  43              		.cfi_def_cfa_register 7
  44 0006 7860     		str	r0, [r7, #4]
  45 0008 3960     		str	r1, [r7]
 241:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  46              		.loc 1 241 0
  47 000a 7B68     		ldr	r3, [r7, #4]
  48 000c FB60     		str	r3, [r7, #12]
 242:Source/queue.c **** 
 243:Source/queue.c **** 	configASSERT( pxQueue );
  49              		.loc 1 243 0
  50 000e FB68     		ldr	r3, [r7, #12]
  51 0010 002B     		cmp	r3, #0
  52 0012 02D1     		bne	.L2
  53              		.loc 1 243 0 is_stmt 0 discriminator 1
  54 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
  55              	.L3:
  56 0018 FEE7     		b	.L3
  57              	.L2:
 244:Source/queue.c **** 
 245:Source/queue.c **** 	taskENTER_CRITICAL();
  58              		.loc 1 245 0 is_stmt 1
  59 001a FFF7FEFF 		bl	vPortEnterCritical
 246:Source/queue.c **** 	{
 247:Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  60              		.loc 1 247 0
  61 001e FB68     		ldr	r3, [r7, #12]
  62 0020 1A68     		ldr	r2, [r3]
  63 0022 FB68     		ldr	r3, [r7, #12]
  64 0024 DB6B     		ldr	r3, [r3, #60]
  65 0026 F968     		ldr	r1, [r7, #12]
  66 0028 096C     		ldr	r1, [r1, #64]
  67 002a 01FB03F3 		mul	r3, r1, r3
  68 002e 1A44     		add	r2, r2, r3
  69 0030 FB68     		ldr	r3, [r7, #12]
  70 0032 5A60     		str	r2, [r3, #4]
 248:Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  71              		.loc 1 248 0
  72 0034 FB68     		ldr	r3, [r7, #12]
  73 0036 0022     		movs	r2, #0
  74 0038 9A63     		str	r2, [r3, #56]
 249:Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  75              		.loc 1 249 0
  76 003a FB68     		ldr	r3, [r7, #12]
  77 003c 1A68     		ldr	r2, [r3]
  78 003e FB68     		ldr	r3, [r7, #12]
  79 0040 9A60     		str	r2, [r3, #8]
 250:Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U )
  80              		.loc 1 250 0
  81 0042 FB68     		ldr	r3, [r7, #12]
  82 0044 1A68     		ldr	r2, [r3]
  83 0046 FB68     		ldr	r3, [r7, #12]
  84 0048 DB6B     		ldr	r3, [r3, #60]
  85 004a 013B     		subs	r3, r3, #1
  86 004c F968     		ldr	r1, [r7, #12]
  87 004e 096C     		ldr	r1, [r1, #64]
  88 0050 01FB03F3 		mul	r3, r1, r3
  89 0054 1A44     		add	r2, r2, r3
  90 0056 FB68     		ldr	r3, [r7, #12]
  91 0058 DA60     		str	r2, [r3, #12]
 251:Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
  92              		.loc 1 251 0
  93 005a FB68     		ldr	r3, [r7, #12]
  94 005c 4FF0FF32 		mov	r2, #-1
  95 0060 5A64     		str	r2, [r3, #68]
 252:Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
  96              		.loc 1 252 0
  97 0062 FB68     		ldr	r3, [r7, #12]
  98 0064 4FF0FF32 		mov	r2, #-1
  99 0068 9A64     		str	r2, [r3, #72]
 253:Source/queue.c **** 
 254:Source/queue.c **** 		if( xNewQueue == pdFALSE )
 100              		.loc 1 254 0
 101 006a 3B68     		ldr	r3, [r7]
 102 006c 002B     		cmp	r3, #0
 103 006e 0ED1     		bne	.L4
 255:Source/queue.c **** 		{
 256:Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 257:Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 258:Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to	write to
 259:Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 260:Source/queue.c **** 			it will be possible to write to it. */
 261:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 104              		.loc 1 261 0
 105 0070 FB68     		ldr	r3, [r7, #12]
 106 0072 1B69     		ldr	r3, [r3, #16]
 107 0074 002B     		cmp	r3, #0
 108 0076 14D0     		beq	.L6
 262:Source/queue.c **** 			{
 263:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 109              		.loc 1 263 0
 110 0078 FB68     		ldr	r3, [r7, #12]
 111 007a 1033     		adds	r3, r3, #16
 112 007c 1846     		mov	r0, r3
 113 007e FFF7FEFF 		bl	xTaskRemoveFromEventList
 114 0082 0346     		mov	r3, r0
 115 0084 012B     		cmp	r3, #1
 116 0086 0CD1     		bne	.L6
 264:Source/queue.c **** 				{
 265:Source/queue.c **** 					portYIELD_WITHIN_API();
 117              		.loc 1 265 0
 118 0088 FFF7FEFF 		bl	vPortYield
 119 008c 09E0     		b	.L6
 120              	.L4:
 266:Source/queue.c **** 				}
 267:Source/queue.c **** 			}
 268:Source/queue.c **** 		}
 269:Source/queue.c **** 		else
 270:Source/queue.c **** 		{
 271:Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 272:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 121              		.loc 1 272 0
 122 008e FB68     		ldr	r3, [r7, #12]
 123 0090 1033     		adds	r3, r3, #16
 124 0092 1846     		mov	r0, r3
 125 0094 FFF7FEFF 		bl	vListInitialise
 273:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 126              		.loc 1 273 0
 127 0098 FB68     		ldr	r3, [r7, #12]
 128 009a 2433     		adds	r3, r3, #36
 129 009c 1846     		mov	r0, r3
 130 009e FFF7FEFF 		bl	vListInitialise
 131              	.L6:
 274:Source/queue.c **** 		}
 275:Source/queue.c **** 	}
 276:Source/queue.c **** 	taskEXIT_CRITICAL();
 132              		.loc 1 276 0
 133 00a2 FFF7FEFF 		bl	vPortExitCritical
 277:Source/queue.c **** 
 278:Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 279:Source/queue.c **** 	versions. */
 280:Source/queue.c **** 	return pdPASS;
 134              		.loc 1 280 0
 135 00a6 0123     		movs	r3, #1
 281:Source/queue.c **** }
 136              		.loc 1 281 0
 137 00a8 1846     		mov	r0, r3
 138 00aa 1037     		adds	r7, r7, #16
 139 00ac BD46     		mov	sp, r7
 140              		@ sp needed
 141 00ae 80BD     		pop	{r7, pc}
 142              		.cfi_endproc
 143              	.LFE110:
 145              		.section	.text.xQueueGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xQueueGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xQueueGenericCreate:
 152              	.LFB111:
 282:Source/queue.c **** /*-----------------------------------------------------------*/
 283:Source/queue.c **** 
 284:Source/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 285:Source/queue.c **** {
 153              		.loc 1 285 0
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 32
 156              		@ frame_needed = 1, uses_anonymous_args = 0
 157 0000 80B5     		push	{r7, lr}
 158              	.LCFI3:
 159              		.cfi_def_cfa_offset 8
 160              		.cfi_offset 7, -8
 161              		.cfi_offset 14, -4
 162 0002 88B0     		sub	sp, sp, #32
 163              	.LCFI4:
 164              		.cfi_def_cfa_offset 40
 165 0004 00AF     		add	r7, sp, #0
 166              	.LCFI5:
 167              		.cfi_def_cfa_register 7
 168 0006 F860     		str	r0, [r7, #12]
 169 0008 B960     		str	r1, [r7, #8]
 170 000a 1346     		mov	r3, r2
 171 000c FB71     		strb	r3, [r7, #7]
 286:Source/queue.c **** xQUEUE *pxNewQueue;
 287:Source/queue.c **** size_t xQueueSizeInBytes;
 288:Source/queue.c **** xQueueHandle xReturn = NULL;
 172              		.loc 1 288 0
 173 000e 0023     		movs	r3, #0
 174 0010 FB61     		str	r3, [r7, #28]
 289:Source/queue.c **** 
 290:Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 291:Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 292:Source/queue.c **** 	( void ) ucQueueType;
 293:Source/queue.c **** 
 294:Source/queue.c **** 	/* Allocate the new queue structure. */
 295:Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 175              		.loc 1 295 0
 176 0012 FB68     		ldr	r3, [r7, #12]
 177 0014 002B     		cmp	r3, #0
 178 0016 2AD0     		beq	.L9
 296:Source/queue.c **** 	{
 297:Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 179              		.loc 1 297 0
 180 0018 5020     		movs	r0, #80
 181 001a FFF7FEFF 		bl	pvPortMalloc
 182 001e B861     		str	r0, [r7, #24]
 298:Source/queue.c **** 		if( pxNewQueue != NULL )
 183              		.loc 1 298 0
 184 0020 BB69     		ldr	r3, [r7, #24]
 185 0022 002B     		cmp	r3, #0
 186 0024 23D0     		beq	.L9
 299:Source/queue.c **** 		{
 300:Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 301:Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 302:Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 187              		.loc 1 302 0
 188 0026 FB68     		ldr	r3, [r7, #12]
 189 0028 BA68     		ldr	r2, [r7, #8]
 190 002a 02FB03F3 		mul	r3, r2, r3
 191 002e 0133     		adds	r3, r3, #1
 192 0030 7B61     		str	r3, [r7, #20]
 303:Source/queue.c **** 
 304:Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 193              		.loc 1 304 0
 194 0032 7869     		ldr	r0, [r7, #20]
 195 0034 FFF7FEFF 		bl	pvPortMalloc
 196 0038 0246     		mov	r2, r0
 197 003a BB69     		ldr	r3, [r7, #24]
 198 003c 1A60     		str	r2, [r3]
 305:Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 199              		.loc 1 305 0
 200 003e BB69     		ldr	r3, [r7, #24]
 201 0040 1B68     		ldr	r3, [r3]
 202 0042 002B     		cmp	r3, #0
 203 0044 10D0     		beq	.L10
 306:Source/queue.c **** 			{
 307:Source/queue.c **** 				/* Initialise the queue members as described above where the
 308:Source/queue.c **** 				queue type is defined. */
 309:Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 204              		.loc 1 309 0
 205 0046 BB69     		ldr	r3, [r7, #24]
 206 0048 FA68     		ldr	r2, [r7, #12]
 207 004a DA63     		str	r2, [r3, #60]
 310:Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 208              		.loc 1 310 0
 209 004c BB69     		ldr	r3, [r7, #24]
 210 004e BA68     		ldr	r2, [r7, #8]
 211 0050 1A64     		str	r2, [r3, #64]
 311:Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 212              		.loc 1 311 0
 213 0052 B869     		ldr	r0, [r7, #24]
 214 0054 0121     		movs	r1, #1
 215 0056 FFF7FEFF 		bl	xQueueGenericReset
 312:Source/queue.c **** 
 313:Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 314:Source/queue.c **** 				{
 315:Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 216              		.loc 1 315 0
 217 005a BB69     		ldr	r3, [r7, #24]
 218 005c FA79     		ldrb	r2, [r7, #7]
 219 005e 83F84D20 		strb	r2, [r3, #77]
 316:Source/queue.c **** 				}
 317:Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 318:Source/queue.c **** 
 319:Source/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 320:Source/queue.c **** 				{
 321:Source/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 322:Source/queue.c **** 				}
 323:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 324:Source/queue.c **** 
 325:Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 326:Source/queue.c **** 				xReturn = pxNewQueue;
 220              		.loc 1 326 0
 221 0062 BB69     		ldr	r3, [r7, #24]
 222 0064 FB61     		str	r3, [r7, #28]
 223 0066 02E0     		b	.L9
 224              	.L10:
 327:Source/queue.c **** 			}
 328:Source/queue.c **** 			else
 329:Source/queue.c **** 			{
 330:Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 331:Source/queue.c **** 				vPortFree( pxNewQueue );
 225              		.loc 1 331 0
 226 0068 B869     		ldr	r0, [r7, #24]
 227 006a FFF7FEFF 		bl	vPortFree
 228              	.L9:
 332:Source/queue.c **** 			}
 333:Source/queue.c **** 		}
 334:Source/queue.c **** 	}
 335:Source/queue.c **** 
 336:Source/queue.c **** 	configASSERT( xReturn );
 229              		.loc 1 336 0
 230 006e FB69     		ldr	r3, [r7, #28]
 231 0070 002B     		cmp	r3, #0
 232 0072 02D1     		bne	.L11
 233              		.loc 1 336 0 is_stmt 0 discriminator 1
 234 0074 FFF7FEFF 		bl	ulPortSetInterruptMask
 235              	.L12:
 236 0078 FEE7     		b	.L12
 237              	.L11:
 337:Source/queue.c **** 
 338:Source/queue.c **** 	return xReturn;
 238              		.loc 1 338 0 is_stmt 1
 239 007a FB69     		ldr	r3, [r7, #28]
 339:Source/queue.c **** }
 240              		.loc 1 339 0
 241 007c 1846     		mov	r0, r3
 242 007e 2037     		adds	r7, r7, #32
 243 0080 BD46     		mov	sp, r7
 244              		@ sp needed
 245 0082 80BD     		pop	{r7, pc}
 246              		.cfi_endproc
 247              	.LFE111:
 249              		.section	.text.xQueueCreateMutex,"ax",%progbits
 250              		.align	2
 251              		.global	xQueueCreateMutex
 252              		.thumb
 253              		.thumb_func
 255              	xQueueCreateMutex:
 256              	.LFB112:
 340:Source/queue.c **** /*-----------------------------------------------------------*/
 341:Source/queue.c **** 
 342:Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 343:Source/queue.c **** 
 344:Source/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 345:Source/queue.c **** 	{
 257              		.loc 1 345 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 16
 260              		@ frame_needed = 1, uses_anonymous_args = 0
 261 0000 80B5     		push	{r7, lr}
 262              	.LCFI6:
 263              		.cfi_def_cfa_offset 8
 264              		.cfi_offset 7, -8
 265              		.cfi_offset 14, -4
 266 0002 84B0     		sub	sp, sp, #16
 267              	.LCFI7:
 268              		.cfi_def_cfa_offset 24
 269 0004 00AF     		add	r7, sp, #0
 270              	.LCFI8:
 271              		.cfi_def_cfa_register 7
 272 0006 0346     		mov	r3, r0
 273 0008 FB71     		strb	r3, [r7, #7]
 346:Source/queue.c **** 	xQUEUE *pxNewQueue;
 347:Source/queue.c **** 
 348:Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 349:Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 350:Source/queue.c **** 		( void ) ucQueueType;
 351:Source/queue.c **** 
 352:Source/queue.c **** 		/* Allocate the new queue structure. */
 353:Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 274              		.loc 1 353 0
 275 000a 5020     		movs	r0, #80
 276 000c FFF7FEFF 		bl	pvPortMalloc
 277 0010 F860     		str	r0, [r7, #12]
 354:Source/queue.c **** 		if( pxNewQueue != NULL )
 278              		.loc 1 354 0
 279 0012 FB68     		ldr	r3, [r7, #12]
 280 0014 002B     		cmp	r3, #0
 281 0016 30D0     		beq	.L15
 355:Source/queue.c **** 		{
 356:Source/queue.c **** 			/* Information required for priority inheritance. */
 357:Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 282              		.loc 1 357 0
 283 0018 FB68     		ldr	r3, [r7, #12]
 284 001a 0022     		movs	r2, #0
 285 001c 5A60     		str	r2, [r3, #4]
 358:Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 286              		.loc 1 358 0
 287 001e FB68     		ldr	r3, [r7, #12]
 288 0020 0022     		movs	r2, #0
 289 0022 1A60     		str	r2, [r3]
 359:Source/queue.c **** 
 360:Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 361:Source/queue.c **** 			of the queue. */
 362:Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 290              		.loc 1 362 0
 291 0024 FB68     		ldr	r3, [r7, #12]
 292 0026 0022     		movs	r2, #0
 293 0028 9A60     		str	r2, [r3, #8]
 363:Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 294              		.loc 1 363 0
 295 002a FB68     		ldr	r3, [r7, #12]
 296 002c 0022     		movs	r2, #0
 297 002e DA60     		str	r2, [r3, #12]
 364:Source/queue.c **** 
 365:Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 366:Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 367:Source/queue.c **** 			of the mutex. */
 368:Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 298              		.loc 1 368 0
 299 0030 FB68     		ldr	r3, [r7, #12]
 300 0032 0022     		movs	r2, #0
 301 0034 9A63     		str	r2, [r3, #56]
 369:Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 302              		.loc 1 369 0
 303 0036 FB68     		ldr	r3, [r7, #12]
 304 0038 0122     		movs	r2, #1
 305 003a DA63     		str	r2, [r3, #60]
 370:Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 306              		.loc 1 370 0
 307 003c FB68     		ldr	r3, [r7, #12]
 308 003e 0022     		movs	r2, #0
 309 0040 1A64     		str	r2, [r3, #64]
 371:Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 310              		.loc 1 371 0
 311 0042 FB68     		ldr	r3, [r7, #12]
 312 0044 4FF0FF32 		mov	r2, #-1
 313 0048 5A64     		str	r2, [r3, #68]
 372:Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 314              		.loc 1 372 0
 315 004a FB68     		ldr	r3, [r7, #12]
 316 004c 4FF0FF32 		mov	r2, #-1
 317 0050 9A64     		str	r2, [r3, #72]
 373:Source/queue.c **** 
 374:Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 375:Source/queue.c **** 			{
 376:Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 318              		.loc 1 376 0
 319 0052 FB68     		ldr	r3, [r7, #12]
 320 0054 FA79     		ldrb	r2, [r7, #7]
 321 0056 83F84D20 		strb	r2, [r3, #77]
 377:Source/queue.c **** 			}
 378:Source/queue.c **** 			#endif
 379:Source/queue.c **** 
 380:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 381:Source/queue.c **** 			{
 382:Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 383:Source/queue.c **** 			}
 384:Source/queue.c **** 			#endif
 385:Source/queue.c **** 
 386:Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 387:Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 322              		.loc 1 387 0
 323 005a FB68     		ldr	r3, [r7, #12]
 324 005c 1033     		adds	r3, r3, #16
 325 005e 1846     		mov	r0, r3
 326 0060 FFF7FEFF 		bl	vListInitialise
 388:Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 327              		.loc 1 388 0
 328 0064 FB68     		ldr	r3, [r7, #12]
 329 0066 2433     		adds	r3, r3, #36
 330 0068 1846     		mov	r0, r3
 331 006a FFF7FEFF 		bl	vListInitialise
 389:Source/queue.c **** 
 390:Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 391:Source/queue.c **** 
 392:Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 393:Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 332              		.loc 1 393 0
 333 006e F868     		ldr	r0, [r7, #12]
 334 0070 0021     		movs	r1, #0
 335 0072 0022     		movs	r2, #0
 336 0074 0023     		movs	r3, #0
 337 0076 FFF7FEFF 		bl	xQueueGenericSend
 338              	.L15:
 394:Source/queue.c **** 		}
 395:Source/queue.c **** 		else
 396:Source/queue.c **** 		{
 397:Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 398:Source/queue.c **** 		}
 399:Source/queue.c **** 
 400:Source/queue.c **** 		configASSERT( pxNewQueue );
 339              		.loc 1 400 0
 340 007a FB68     		ldr	r3, [r7, #12]
 341 007c 002B     		cmp	r3, #0
 342 007e 02D1     		bne	.L16
 343              		.loc 1 400 0 is_stmt 0 discriminator 1
 344 0080 FFF7FEFF 		bl	ulPortSetInterruptMask
 345              	.L17:
 346 0084 FEE7     		b	.L17
 347              	.L16:
 401:Source/queue.c **** 		return pxNewQueue;
 348              		.loc 1 401 0 is_stmt 1
 349 0086 FB68     		ldr	r3, [r7, #12]
 402:Source/queue.c **** 	}
 350              		.loc 1 402 0
 351 0088 1846     		mov	r0, r3
 352 008a 1037     		adds	r7, r7, #16
 353 008c BD46     		mov	sp, r7
 354              		@ sp needed
 355 008e 80BD     		pop	{r7, pc}
 356              		.cfi_endproc
 357              	.LFE112:
 359              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 360              		.align	2
 361              		.global	xQueueGiveMutexRecursive
 362              		.thumb
 363              		.thumb_func
 365              	xQueueGiveMutexRecursive:
 366              	.LFB113:
 403:Source/queue.c **** 
 404:Source/queue.c **** #endif /* configUSE_MUTEXES */
 405:Source/queue.c **** /*-----------------------------------------------------------*/
 406:Source/queue.c **** 
 407:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 408:Source/queue.c **** 
 409:Source/queue.c **** 	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
 410:Source/queue.c **** 	{
 411:Source/queue.c **** 	void *pxReturn;
 412:Source/queue.c **** 
 413:Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 414:Source/queue.c **** 		be called directly.  Note:  This is is a good way of determining if the
 415:Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 416:Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 417:Source/queue.c **** 		following critical section exiting and the function returning. */
 418:Source/queue.c **** 		taskENTER_CRITICAL();
 419:Source/queue.c **** 		{
 420:Source/queue.c **** 			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 421:Source/queue.c **** 			{
 422:Source/queue.c **** 				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
 423:Source/queue.c **** 			}
 424:Source/queue.c **** 			else
 425:Source/queue.c **** 			{
 426:Source/queue.c **** 				pxReturn = NULL;
 427:Source/queue.c **** 			}
 428:Source/queue.c **** 		}
 429:Source/queue.c **** 		taskEXIT_CRITICAL();
 430:Source/queue.c **** 
 431:Source/queue.c **** 		return pxReturn;
 432:Source/queue.c **** 	}
 433:Source/queue.c **** 
 434:Source/queue.c **** #endif
 435:Source/queue.c **** /*-----------------------------------------------------------*/
 436:Source/queue.c **** 
 437:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 438:Source/queue.c **** 
 439:Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
 440:Source/queue.c **** 	{
 367              		.loc 1 440 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 16
 370              		@ frame_needed = 1, uses_anonymous_args = 0
 371 0000 90B5     		push	{r4, r7, lr}
 372              	.LCFI9:
 373              		.cfi_def_cfa_offset 12
 374              		.cfi_offset 4, -12
 375              		.cfi_offset 7, -8
 376              		.cfi_offset 14, -4
 377 0002 85B0     		sub	sp, sp, #20
 378              	.LCFI10:
 379              		.cfi_def_cfa_offset 32
 380 0004 00AF     		add	r7, sp, #0
 381              	.LCFI11:
 382              		.cfi_def_cfa_register 7
 383 0006 7860     		str	r0, [r7, #4]
 441:Source/queue.c **** 	portBASE_TYPE xReturn;
 442:Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 384              		.loc 1 442 0
 385 0008 7B68     		ldr	r3, [r7, #4]
 386 000a BB60     		str	r3, [r7, #8]
 443:Source/queue.c **** 
 444:Source/queue.c **** 		configASSERT( pxMutex );
 387              		.loc 1 444 0
 388 000c BB68     		ldr	r3, [r7, #8]
 389 000e 002B     		cmp	r3, #0
 390 0010 02D1     		bne	.L20
 391              		.loc 1 444 0 is_stmt 0 discriminator 1
 392 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 393              	.L21:
 394 0016 FEE7     		b	.L21
 395              	.L20:
 445:Source/queue.c **** 
 446:Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 447:Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 448:Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 449:Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 450:Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 451:Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 452:Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 396              		.loc 1 452 0 is_stmt 1
 397 0018 BB68     		ldr	r3, [r7, #8]
 398 001a 5C68     		ldr	r4, [r3, #4]
 399 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 400 0020 0346     		mov	r3, r0
 401 0022 9C42     		cmp	r4, r3
 402 0024 11D1     		bne	.L22
 453:Source/queue.c **** 		{
 454:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 455:Source/queue.c **** 
 456:Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 457:Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 458:Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 459:Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 460:Source/queue.c **** 			uxRecursiveCallCount member. */
 461:Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 403              		.loc 1 461 0
 404 0026 BB68     		ldr	r3, [r7, #8]
 405 0028 DB68     		ldr	r3, [r3, #12]
 406 002a 5A1E     		subs	r2, r3, #1
 407 002c BB68     		ldr	r3, [r7, #8]
 408 002e DA60     		str	r2, [r3, #12]
 462:Source/queue.c **** 
 463:Source/queue.c **** 			/* Have we unwound the call count? */
 464:Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
 409              		.loc 1 464 0
 410 0030 BB68     		ldr	r3, [r7, #8]
 411 0032 DB68     		ldr	r3, [r3, #12]
 412 0034 002B     		cmp	r3, #0
 413 0036 05D1     		bne	.L23
 465:Source/queue.c **** 			{
 466:Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 467:Source/queue.c **** 				task that might be waiting to access the mutex. */
 468:Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 414              		.loc 1 468 0
 415 0038 B868     		ldr	r0, [r7, #8]
 416 003a 0021     		movs	r1, #0
 417 003c 0022     		movs	r2, #0
 418 003e 0023     		movs	r3, #0
 419 0040 FFF7FEFF 		bl	xQueueGenericSend
 420              	.L23:
 469:Source/queue.c **** 			}
 470:Source/queue.c **** 
 471:Source/queue.c **** 			xReturn = pdPASS;
 421              		.loc 1 471 0
 422 0044 0123     		movs	r3, #1
 423 0046 FB60     		str	r3, [r7, #12]
 424 0048 01E0     		b	.L24
 425              	.L22:
 472:Source/queue.c **** 		}
 473:Source/queue.c **** 		else
 474:Source/queue.c **** 		{
 475:Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 476:Source/queue.c **** 			xReturn = pdFAIL;
 426              		.loc 1 476 0
 427 004a 0023     		movs	r3, #0
 428 004c FB60     		str	r3, [r7, #12]
 429              	.L24:
 477:Source/queue.c **** 
 478:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 479:Source/queue.c **** 		}
 480:Source/queue.c **** 
 481:Source/queue.c **** 		return xReturn;
 430              		.loc 1 481 0
 431 004e FB68     		ldr	r3, [r7, #12]
 482:Source/queue.c **** 	}
 432              		.loc 1 482 0
 433 0050 1846     		mov	r0, r3
 434 0052 1437     		adds	r7, r7, #20
 435 0054 BD46     		mov	sp, r7
 436              		@ sp needed
 437 0056 90BD     		pop	{r4, r7, pc}
 438              		.cfi_endproc
 439              	.LFE113:
 441              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 442              		.align	2
 443              		.global	xQueueTakeMutexRecursive
 444              		.thumb
 445              		.thumb_func
 447              	xQueueTakeMutexRecursive:
 448              	.LFB114:
 483:Source/queue.c **** 
 484:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 485:Source/queue.c **** /*-----------------------------------------------------------*/
 486:Source/queue.c **** 
 487:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 488:Source/queue.c **** 
 489:Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
 490:Source/queue.c **** 	{
 449              		.loc 1 490 0
 450              		.cfi_startproc
 451              		@ args = 0, pretend = 0, frame = 16
 452              		@ frame_needed = 1, uses_anonymous_args = 0
 453 0000 90B5     		push	{r4, r7, lr}
 454              	.LCFI12:
 455              		.cfi_def_cfa_offset 12
 456              		.cfi_offset 4, -12
 457              		.cfi_offset 7, -8
 458              		.cfi_offset 14, -4
 459 0002 85B0     		sub	sp, sp, #20
 460              	.LCFI13:
 461              		.cfi_def_cfa_offset 32
 462 0004 00AF     		add	r7, sp, #0
 463              	.LCFI14:
 464              		.cfi_def_cfa_register 7
 465 0006 7860     		str	r0, [r7, #4]
 466 0008 3960     		str	r1, [r7]
 491:Source/queue.c **** 	portBASE_TYPE xReturn;
 492:Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 467              		.loc 1 492 0
 468 000a 7B68     		ldr	r3, [r7, #4]
 469 000c BB60     		str	r3, [r7, #8]
 493:Source/queue.c **** 
 494:Source/queue.c **** 		configASSERT( pxMutex );
 470              		.loc 1 494 0
 471 000e BB68     		ldr	r3, [r7, #8]
 472 0010 002B     		cmp	r3, #0
 473 0012 02D1     		bne	.L27
 474              		.loc 1 494 0 is_stmt 0 discriminator 1
 475 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 476              	.L28:
 477 0018 FEE7     		b	.L28
 478              	.L27:
 495:Source/queue.c **** 
 496:Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 497:Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 498:Source/queue.c **** 
 499:Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 500:Source/queue.c **** 
 501:Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 479              		.loc 1 501 0 is_stmt 1
 480 001a BB68     		ldr	r3, [r7, #8]
 481 001c 5C68     		ldr	r4, [r3, #4]
 482 001e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 483 0022 0346     		mov	r3, r0
 484 0024 9C42     		cmp	r4, r3
 485 0026 07D1     		bne	.L29
 502:Source/queue.c **** 		{
 503:Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 486              		.loc 1 503 0
 487 0028 BB68     		ldr	r3, [r7, #8]
 488 002a DB68     		ldr	r3, [r3, #12]
 489 002c 5A1C     		adds	r2, r3, #1
 490 002e BB68     		ldr	r3, [r7, #8]
 491 0030 DA60     		str	r2, [r3, #12]
 504:Source/queue.c **** 			xReturn = pdPASS;
 492              		.loc 1 504 0
 493 0032 0123     		movs	r3, #1
 494 0034 FB60     		str	r3, [r7, #12]
 495 0036 0EE0     		b	.L30
 496              	.L29:
 505:Source/queue.c **** 		}
 506:Source/queue.c **** 		else
 507:Source/queue.c **** 		{
 508:Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 497              		.loc 1 508 0
 498 0038 B868     		ldr	r0, [r7, #8]
 499 003a 0021     		movs	r1, #0
 500 003c 3A68     		ldr	r2, [r7]
 501 003e 0023     		movs	r3, #0
 502 0040 FFF7FEFF 		bl	xQueueGenericReceive
 503 0044 F860     		str	r0, [r7, #12]
 509:Source/queue.c **** 
 510:Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 511:Source/queue.c **** 			we may have blocked to reach here. */
 512:Source/queue.c **** 			if( xReturn == pdPASS )
 504              		.loc 1 512 0
 505 0046 FB68     		ldr	r3, [r7, #12]
 506 0048 012B     		cmp	r3, #1
 507 004a 04D1     		bne	.L30
 513:Source/queue.c **** 			{
 514:Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 508              		.loc 1 514 0
 509 004c BB68     		ldr	r3, [r7, #8]
 510 004e DB68     		ldr	r3, [r3, #12]
 511 0050 5A1C     		adds	r2, r3, #1
 512 0052 BB68     		ldr	r3, [r7, #8]
 513 0054 DA60     		str	r2, [r3, #12]
 514              	.L30:
 515:Source/queue.c **** 			}
 516:Source/queue.c **** 			else
 517:Source/queue.c **** 			{
 518:Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 519:Source/queue.c **** 			}
 520:Source/queue.c **** 		}
 521:Source/queue.c **** 
 522:Source/queue.c **** 		return xReturn;
 515              		.loc 1 522 0
 516 0056 FB68     		ldr	r3, [r7, #12]
 523:Source/queue.c **** 	}
 517              		.loc 1 523 0
 518 0058 1846     		mov	r0, r3
 519 005a 1437     		adds	r7, r7, #20
 520 005c BD46     		mov	sp, r7
 521              		@ sp needed
 522 005e 90BD     		pop	{r4, r7, pc}
 523              		.cfi_endproc
 524              	.LFE114:
 526              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 527              		.align	2
 528              		.global	xQueueCreateCountingSemaphore
 529              		.thumb
 530              		.thumb_func
 532              	xQueueCreateCountingSemaphore:
 533              	.LFB115:
 524:Source/queue.c **** 
 525:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 526:Source/queue.c **** /*-----------------------------------------------------------*/
 527:Source/queue.c **** 
 528:Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 529:Source/queue.c **** 
 530:Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 531:Source/queue.c **** 	{
 534              		.loc 1 531 0
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 16
 537              		@ frame_needed = 1, uses_anonymous_args = 0
 538 0000 80B5     		push	{r7, lr}
 539              	.LCFI15:
 540              		.cfi_def_cfa_offset 8
 541              		.cfi_offset 7, -8
 542              		.cfi_offset 14, -4
 543 0002 84B0     		sub	sp, sp, #16
 544              	.LCFI16:
 545              		.cfi_def_cfa_offset 24
 546 0004 00AF     		add	r7, sp, #0
 547              	.LCFI17:
 548              		.cfi_def_cfa_register 7
 549 0006 7860     		str	r0, [r7, #4]
 550 0008 3960     		str	r1, [r7]
 532:Source/queue.c **** 	xQueueHandle xHandle;
 533:Source/queue.c **** 
 534:Source/queue.c **** 		xHandle = xQueueGenericCreate( uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_CO
 551              		.loc 1 534 0
 552 000a 7868     		ldr	r0, [r7, #4]
 553 000c 0021     		movs	r1, #0
 554 000e 0222     		movs	r2, #2
 555 0010 FFF7FEFF 		bl	xQueueGenericCreate
 556 0014 F860     		str	r0, [r7, #12]
 535:Source/queue.c **** 
 536:Source/queue.c **** 		if( xHandle != NULL )
 557              		.loc 1 536 0
 558 0016 FB68     		ldr	r3, [r7, #12]
 559 0018 002B     		cmp	r3, #0
 560 001a 02D0     		beq	.L33
 537:Source/queue.c **** 		{
 538:Source/queue.c **** 			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 561              		.loc 1 538 0
 562 001c FB68     		ldr	r3, [r7, #12]
 563 001e 3A68     		ldr	r2, [r7]
 564 0020 9A63     		str	r2, [r3, #56]
 565              	.L33:
 539:Source/queue.c **** 
 540:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 541:Source/queue.c **** 		}
 542:Source/queue.c **** 		else
 543:Source/queue.c **** 		{
 544:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 545:Source/queue.c **** 		}
 546:Source/queue.c **** 
 547:Source/queue.c **** 		configASSERT( xHandle );
 566              		.loc 1 547 0
 567 0022 FB68     		ldr	r3, [r7, #12]
 568 0024 002B     		cmp	r3, #0
 569 0026 02D1     		bne	.L34
 570              		.loc 1 547 0 is_stmt 0 discriminator 1
 571 0028 FFF7FEFF 		bl	ulPortSetInterruptMask
 572              	.L35:
 573 002c FEE7     		b	.L35
 574              	.L34:
 548:Source/queue.c **** 		return xHandle;
 575              		.loc 1 548 0 is_stmt 1
 576 002e FB68     		ldr	r3, [r7, #12]
 549:Source/queue.c **** 	}
 577              		.loc 1 549 0
 578 0030 1846     		mov	r0, r3
 579 0032 1037     		adds	r7, r7, #16
 580 0034 BD46     		mov	sp, r7
 581              		@ sp needed
 582 0036 80BD     		pop	{r7, pc}
 583              		.cfi_endproc
 584              	.LFE115:
 586              		.section	.text.xQueueGenericSend,"ax",%progbits
 587              		.align	2
 588              		.global	xQueueGenericSend
 589              		.thumb
 590              		.thumb_func
 592              	xQueueGenericSend:
 593              	.LFB116:
 550:Source/queue.c **** 
 551:Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 552:Source/queue.c **** /*-----------------------------------------------------------*/
 553:Source/queue.c **** 
 554:Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 555:Source/queue.c **** {
 594              		.loc 1 555 0
 595              		.cfi_startproc
 596              		@ args = 0, pretend = 0, frame = 32
 597              		@ frame_needed = 1, uses_anonymous_args = 0
 598 0000 80B5     		push	{r7, lr}
 599              	.LCFI18:
 600              		.cfi_def_cfa_offset 8
 601              		.cfi_offset 7, -8
 602              		.cfi_offset 14, -4
 603 0002 88B0     		sub	sp, sp, #32
 604              	.LCFI19:
 605              		.cfi_def_cfa_offset 40
 606 0004 00AF     		add	r7, sp, #0
 607              	.LCFI20:
 608              		.cfi_def_cfa_register 7
 609 0006 F860     		str	r0, [r7, #12]
 610 0008 B960     		str	r1, [r7, #8]
 611 000a 7A60     		str	r2, [r7, #4]
 612 000c 3B60     		str	r3, [r7]
 556:Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 613              		.loc 1 556 0
 614 000e 0023     		movs	r3, #0
 615 0010 FB61     		str	r3, [r7, #28]
 557:Source/queue.c **** xTimeOutType xTimeOut;
 558:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 616              		.loc 1 558 0
 617 0012 FB68     		ldr	r3, [r7, #12]
 618 0014 BB61     		str	r3, [r7, #24]
 559:Source/queue.c **** 
 560:Source/queue.c **** 	configASSERT( pxQueue );
 619              		.loc 1 560 0
 620 0016 BB69     		ldr	r3, [r7, #24]
 621 0018 002B     		cmp	r3, #0
 622 001a 02D1     		bne	.L38
 623              		.loc 1 560 0 is_stmt 0 discriminator 1
 624 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 625              	.L39:
 626 0020 FEE7     		b	.L39
 627              	.L38:
 561:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 628              		.loc 1 561 0 is_stmt 1
 629 0022 BB68     		ldr	r3, [r7, #8]
 630 0024 002B     		cmp	r3, #0
 631 0026 03D1     		bne	.L40
 632              		.loc 1 561 0 is_stmt 0 discriminator 2
 633 0028 BB69     		ldr	r3, [r7, #24]
 634 002a 1B6C     		ldr	r3, [r3, #64]
 635 002c 002B     		cmp	r3, #0
 636 002e 01D1     		bne	.L41
 637              	.L40:
 638              		.loc 1 561 0 discriminator 1
 639 0030 0123     		movs	r3, #1
 640 0032 00E0     		b	.L42
 641              	.L41:
 642              		.loc 1 561 0 discriminator 3
 643 0034 0023     		movs	r3, #0
 644              	.L42:
 645              		.loc 1 561 0 discriminator 4
 646 0036 002B     		cmp	r3, #0
 647 0038 02D1     		bne	.L43
 648              		.loc 1 561 0 discriminator 1
 649 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 650              	.L44:
 651 003e FEE7     		b	.L44
 652              	.L43:
 562:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 653              		.loc 1 562 0 is_stmt 1
 654 0040 3B68     		ldr	r3, [r7]
 655 0042 022B     		cmp	r3, #2
 656 0044 03D1     		bne	.L45
 657              		.loc 1 562 0 is_stmt 0 discriminator 2
 658 0046 BB69     		ldr	r3, [r7, #24]
 659 0048 DB6B     		ldr	r3, [r3, #60]
 660 004a 012B     		cmp	r3, #1
 661 004c 01D1     		bne	.L46
 662              	.L45:
 663              		.loc 1 562 0 discriminator 1
 664 004e 0123     		movs	r3, #1
 665 0050 00E0     		b	.L47
 666              	.L46:
 667              		.loc 1 562 0 discriminator 3
 668 0052 0023     		movs	r3, #0
 669              	.L47:
 670              		.loc 1 562 0 discriminator 4
 671 0054 002B     		cmp	r3, #0
 672 0056 02D1     		bne	.L48
 673              		.loc 1 562 0 discriminator 1
 674 0058 FFF7FEFF 		bl	ulPortSetInterruptMask
 675              	.L49:
 676 005c FEE7     		b	.L49
 677              	.L48:
 563:Source/queue.c **** 
 564:Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 565:Source/queue.c **** 	statements within the function itself.  This is done in the interest
 566:Source/queue.c **** 	of execution time efficiency. */
 567:Source/queue.c **** 	for( ;; )
 568:Source/queue.c **** 	{
 569:Source/queue.c **** 		taskENTER_CRITICAL();
 678              		.loc 1 569 0 is_stmt 1
 679 005e FFF7FEFF 		bl	vPortEnterCritical
 570:Source/queue.c **** 		{
 571:Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 572:Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 573:Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 574:Source/queue.c **** 			not matter if the queue is full. */
 575:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 680              		.loc 1 575 0
 681 0062 BB69     		ldr	r3, [r7, #24]
 682 0064 9A6B     		ldr	r2, [r3, #56]
 683 0066 BB69     		ldr	r3, [r7, #24]
 684 0068 DB6B     		ldr	r3, [r3, #60]
 685 006a 9A42     		cmp	r2, r3
 686 006c 02D3     		bcc	.L50
 687              		.loc 1 575 0 is_stmt 0 discriminator 1
 688 006e 3B68     		ldr	r3, [r7]
 689 0070 022B     		cmp	r3, #2
 690 0072 16D1     		bne	.L51
 691              	.L50:
 576:Source/queue.c **** 			{
 577:Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 578:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 692              		.loc 1 578 0 is_stmt 1
 693 0074 B869     		ldr	r0, [r7, #24]
 694 0076 B968     		ldr	r1, [r7, #8]
 695 0078 3A68     		ldr	r2, [r7]
 696 007a FFF7FEFF 		bl	prvCopyDataToQueue
 579:Source/queue.c **** 
 580:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 581:Source/queue.c **** 				{
 582:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 583:Source/queue.c **** 					{
 584:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 585:Source/queue.c **** 						{
 586:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 587:Source/queue.c **** 							to the queue set caused a higher priority task to
 588:Source/queue.c **** 							unblock. A context switch is required. */
 589:Source/queue.c **** 							portYIELD_WITHIN_API();
 590:Source/queue.c **** 						}
 591:Source/queue.c **** 					}
 592:Source/queue.c **** 					else
 593:Source/queue.c **** 					{
 594:Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 595:Source/queue.c **** 						queue then unblock it now. */
 596:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 597:Source/queue.c **** 						{
 598:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 599:Source/queue.c **** 							{
 600:Source/queue.c **** 								/* The unblocked task has a priority higher than
 601:Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 602:Source/queue.c **** 								do this from within the critical section - the
 603:Source/queue.c **** 								kernel takes care of that. */
 604:Source/queue.c **** 								portYIELD_WITHIN_API();
 605:Source/queue.c **** 							}
 606:Source/queue.c **** 						}
 607:Source/queue.c **** 					}
 608:Source/queue.c **** 				}
 609:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 610:Source/queue.c **** 				{
 611:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 612:Source/queue.c **** 					queue then unblock it now. */
 613:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 697              		.loc 1 613 0
 698 007e BB69     		ldr	r3, [r7, #24]
 699 0080 5B6A     		ldr	r3, [r3, #36]
 700 0082 002B     		cmp	r3, #0
 701 0084 09D0     		beq	.L52
 614:Source/queue.c **** 					{
 615:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 702              		.loc 1 615 0
 703 0086 BB69     		ldr	r3, [r7, #24]
 704 0088 2433     		adds	r3, r3, #36
 705 008a 1846     		mov	r0, r3
 706 008c FFF7FEFF 		bl	xTaskRemoveFromEventList
 707 0090 0346     		mov	r3, r0
 708 0092 012B     		cmp	r3, #1
 709 0094 01D1     		bne	.L52
 616:Source/queue.c **** 						{
 617:Source/queue.c **** 							/* The unblocked task has a priority higher than
 618:Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 619:Source/queue.c **** 							this from within the critical section - the kernel
 620:Source/queue.c **** 							takes care of that. */
 621:Source/queue.c **** 							portYIELD_WITHIN_API();
 710              		.loc 1 621 0
 711 0096 FFF7FEFF 		bl	vPortYield
 712              	.L52:
 622:Source/queue.c **** 						}
 623:Source/queue.c **** 					}
 624:Source/queue.c **** 				}
 625:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 626:Source/queue.c **** 
 627:Source/queue.c **** 				taskEXIT_CRITICAL();
 713              		.loc 1 627 0
 714 009a FFF7FEFF 		bl	vPortExitCritical
 628:Source/queue.c **** 
 629:Source/queue.c **** 				/* Return to the original privilege level before exiting the
 630:Source/queue.c **** 				function. */
 631:Source/queue.c **** 				return pdPASS;
 715              		.loc 1 631 0
 716 009e 0123     		movs	r3, #1
 717 00a0 59E0     		b	.L63
 718              	.L51:
 632:Source/queue.c **** 			}
 633:Source/queue.c **** 			else
 634:Source/queue.c **** 			{
 635:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 719              		.loc 1 635 0
 720 00a2 7B68     		ldr	r3, [r7, #4]
 721 00a4 002B     		cmp	r3, #0
 722 00a6 03D1     		bne	.L54
 636:Source/queue.c **** 				{
 637:Source/queue.c **** 					/* The queue was full and no block time is specified (or
 638:Source/queue.c **** 					the block time has expired) so leave now. */
 639:Source/queue.c **** 					taskEXIT_CRITICAL();
 723              		.loc 1 639 0
 724 00a8 FFF7FEFF 		bl	vPortExitCritical
 640:Source/queue.c **** 
 641:Source/queue.c **** 					/* Return to the original privilege level before exiting
 642:Source/queue.c **** 					the function. */
 643:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 644:Source/queue.c **** 					return errQUEUE_FULL;
 725              		.loc 1 644 0
 726 00ac 0023     		movs	r3, #0
 727 00ae 52E0     		b	.L63
 728              	.L54:
 645:Source/queue.c **** 				}
 646:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 729              		.loc 1 646 0
 730 00b0 FB69     		ldr	r3, [r7, #28]
 731 00b2 002B     		cmp	r3, #0
 732 00b4 06D1     		bne	.L55
 647:Source/queue.c **** 				{
 648:Source/queue.c **** 					/* The queue was full and a block time was specified so
 649:Source/queue.c **** 					configure the timeout structure. */
 650:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 733              		.loc 1 650 0
 734 00b6 07F11003 		add	r3, r7, #16
 735 00ba 1846     		mov	r0, r3
 736 00bc FFF7FEFF 		bl	vTaskSetTimeOutState
 651:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 737              		.loc 1 651 0
 738 00c0 0123     		movs	r3, #1
 739 00c2 FB61     		str	r3, [r7, #28]
 740              	.L55:
 652:Source/queue.c **** 				}
 653:Source/queue.c **** 				else
 654:Source/queue.c **** 				{
 655:Source/queue.c **** 					/* Entry time was already set. */
 656:Source/queue.c **** 				}
 657:Source/queue.c **** 			}
 658:Source/queue.c **** 		}
 659:Source/queue.c **** 		taskEXIT_CRITICAL();
 741              		.loc 1 659 0
 742 00c4 FFF7FEFF 		bl	vPortExitCritical
 660:Source/queue.c **** 
 661:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 662:Source/queue.c **** 		now the critical section has been exited. */
 663:Source/queue.c **** 
 664:Source/queue.c **** 		vTaskSuspendAll();
 743              		.loc 1 664 0
 744 00c8 FFF7FEFF 		bl	vTaskSuspendAll
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 745              		.loc 1 665 0
 746 00cc FFF7FEFF 		bl	vPortEnterCritical
 747 00d0 BB69     		ldr	r3, [r7, #24]
 748 00d2 5B6C     		ldr	r3, [r3, #68]
 749 00d4 B3F1FF3F 		cmp	r3, #-1
 750 00d8 02D1     		bne	.L56
 751              		.loc 1 665 0 is_stmt 0 discriminator 1
 752 00da BB69     		ldr	r3, [r7, #24]
 753 00dc 0022     		movs	r2, #0
 754 00de 5A64     		str	r2, [r3, #68]
 755              	.L56:
 756              		.loc 1 665 0 discriminator 2
 757 00e0 BB69     		ldr	r3, [r7, #24]
 758 00e2 9B6C     		ldr	r3, [r3, #72]
 759 00e4 B3F1FF3F 		cmp	r3, #-1
 760 00e8 02D1     		bne	.L57
 761              		.loc 1 665 0 discriminator 1
 762 00ea BB69     		ldr	r3, [r7, #24]
 763 00ec 0022     		movs	r2, #0
 764 00ee 9A64     		str	r2, [r3, #72]
 765              	.L57:
 766              		.loc 1 665 0 discriminator 2
 767 00f0 FFF7FEFF 		bl	vPortExitCritical
 666:Source/queue.c **** 
 667:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 668:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 768              		.loc 1 668 0 is_stmt 1 discriminator 2
 769 00f4 07F11002 		add	r2, r7, #16
 770 00f8 3B1D     		adds	r3, r7, #4
 771 00fa 1046     		mov	r0, r2
 772 00fc 1946     		mov	r1, r3
 773 00fe FFF7FEFF 		bl	xTaskCheckForTimeOut
 774 0102 0346     		mov	r3, r0
 775 0104 002B     		cmp	r3, #0
 776 0106 1ED1     		bne	.L58
 669:Source/queue.c **** 		{
 670:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 777              		.loc 1 670 0
 778 0108 B869     		ldr	r0, [r7, #24]
 779 010a FFF7FEFF 		bl	prvIsQueueFull
 780 010e 0346     		mov	r3, r0
 781 0110 002B     		cmp	r3, #0
 782 0112 12D0     		beq	.L59
 671:Source/queue.c **** 			{
 672:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 673:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 783              		.loc 1 673 0
 784 0114 BB69     		ldr	r3, [r7, #24]
 785 0116 03F11002 		add	r2, r3, #16
 786 011a 7B68     		ldr	r3, [r7, #4]
 787 011c 1046     		mov	r0, r2
 788 011e 1946     		mov	r1, r3
 789 0120 FFF7FEFF 		bl	vTaskPlaceOnEventList
 674:Source/queue.c **** 
 675:Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 676:Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 677:Source/queue.c **** 				remove this task from the event	list again - but as the
 678:Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 679:Source/queue.c **** 				ready last instead of the actual ready list. */
 680:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 790              		.loc 1 680 0
 791 0124 B869     		ldr	r0, [r7, #24]
 792 0126 FFF7FEFF 		bl	prvUnlockQueue
 681:Source/queue.c **** 
 682:Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 683:Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 684:Source/queue.c **** 				task is already in a ready list before it yields - in which
 685:Source/queue.c **** 				case the yield will not cause a context switch unless there
 686:Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 687:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 793              		.loc 1 687 0
 794 012a FFF7FEFF 		bl	xTaskResumeAll
 795 012e 0346     		mov	r3, r0
 796 0130 002B     		cmp	r3, #0
 797 0132 0FD1     		bne	.L62
 688:Source/queue.c **** 				{
 689:Source/queue.c **** 					portYIELD_WITHIN_API();
 798              		.loc 1 689 0
 799 0134 FFF7FEFF 		bl	vPortYield
 800 0138 0CE0     		b	.L62
 801              	.L59:
 690:Source/queue.c **** 				}
 691:Source/queue.c **** 			}
 692:Source/queue.c **** 			else
 693:Source/queue.c **** 			{
 694:Source/queue.c **** 				/* Try again. */
 695:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 802              		.loc 1 695 0
 803 013a B869     		ldr	r0, [r7, #24]
 804 013c FFF7FEFF 		bl	prvUnlockQueue
 696:Source/queue.c **** 				( void ) xTaskResumeAll();
 805              		.loc 1 696 0
 806 0140 FFF7FEFF 		bl	xTaskResumeAll
 697:Source/queue.c **** 			}
 698:Source/queue.c **** 		}
 699:Source/queue.c **** 		else
 700:Source/queue.c **** 		{
 701:Source/queue.c **** 			/* The timeout has expired. */
 702:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 703:Source/queue.c **** 			( void ) xTaskResumeAll();
 704:Source/queue.c **** 
 705:Source/queue.c **** 			/* Return to the original privilege level before exiting the
 706:Source/queue.c **** 			function. */
 707:Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 708:Source/queue.c **** 			return errQUEUE_FULL;
 709:Source/queue.c **** 		}
 710:Source/queue.c **** 	}
 807              		.loc 1 710 0
 808 0144 8BE7     		b	.L48
 809              	.L58:
 702:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 810              		.loc 1 702 0
 811 0146 B869     		ldr	r0, [r7, #24]
 812 0148 FFF7FEFF 		bl	prvUnlockQueue
 703:Source/queue.c **** 			( void ) xTaskResumeAll();
 813              		.loc 1 703 0
 814 014c FFF7FEFF 		bl	xTaskResumeAll
 708:Source/queue.c **** 			return errQUEUE_FULL;
 815              		.loc 1 708 0
 816 0150 0023     		movs	r3, #0
 817 0152 00E0     		b	.L63
 818              	.L62:
 819              		.loc 1 710 0
 820 0154 83E7     		b	.L48
 821              	.L63:
 711:Source/queue.c **** }
 822              		.loc 1 711 0
 823 0156 1846     		mov	r0, r3
 824 0158 2037     		adds	r7, r7, #32
 825 015a BD46     		mov	sp, r7
 826              		@ sp needed
 827 015c 80BD     		pop	{r7, pc}
 828              		.cfi_endproc
 829              	.LFE116:
 831 015e 00BF     		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 832              		.align	2
 833              		.global	xQueueGenericSendFromISR
 834              		.thumb
 835              		.thumb_func
 837              	xQueueGenericSendFromISR:
 838              	.LFB117:
 712:Source/queue.c **** /*-----------------------------------------------------------*/
 713:Source/queue.c **** 
 714:Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 715:Source/queue.c **** 
 716:Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, 
 717:Source/queue.c **** 	{
 718:Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 719:Source/queue.c **** 	xTimeOutType xTimeOut;
 720:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 721:Source/queue.c **** 
 722:Source/queue.c **** 		configASSERT( pxQueue );
 723:Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 724:Source/queue.c **** 
 725:Source/queue.c **** 		for( ;; )
 726:Source/queue.c **** 		{
 727:Source/queue.c **** 			taskENTER_CRITICAL();
 728:Source/queue.c **** 			{
 729:Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 730:Source/queue.c **** 				the highest priority task wanting to access the queue. */
 731:Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 732:Source/queue.c **** 				{
 733:Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 734:Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 735:Source/queue.c **** 
 736:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 737:Source/queue.c **** 					queue then unblock it now. */
 738:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 739:Source/queue.c **** 					{
 740:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 741:Source/queue.c **** 						{
 742:Source/queue.c **** 							/* The unblocked task has a priority higher than
 743:Source/queue.c **** 							our own so yield immediately. */
 744:Source/queue.c **** 							portYIELD_WITHIN_API();
 745:Source/queue.c **** 						}
 746:Source/queue.c **** 					}
 747:Source/queue.c **** 
 748:Source/queue.c **** 					taskEXIT_CRITICAL();
 749:Source/queue.c **** 					return pdPASS;
 750:Source/queue.c **** 				}
 751:Source/queue.c **** 				else
 752:Source/queue.c **** 				{
 753:Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 754:Source/queue.c **** 					{
 755:Source/queue.c **** 						taskEXIT_CRITICAL();
 756:Source/queue.c **** 						return errQUEUE_FULL;
 757:Source/queue.c **** 					}
 758:Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 759:Source/queue.c **** 					{
 760:Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 761:Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 762:Source/queue.c **** 					}
 763:Source/queue.c **** 				}
 764:Source/queue.c **** 			}
 765:Source/queue.c **** 			taskEXIT_CRITICAL();
 766:Source/queue.c **** 
 767:Source/queue.c **** 			taskENTER_CRITICAL();
 768:Source/queue.c **** 			{
 769:Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 770:Source/queue.c **** 				{
 771:Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 772:Source/queue.c **** 					{
 773:Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 774:Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 775:Source/queue.c **** 						portYIELD_WITHIN_API();
 776:Source/queue.c **** 					}
 777:Source/queue.c **** 				}
 778:Source/queue.c **** 				else
 779:Source/queue.c **** 				{
 780:Source/queue.c **** 					taskEXIT_CRITICAL();
 781:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 782:Source/queue.c **** 					return errQUEUE_FULL;
 783:Source/queue.c **** 				}
 784:Source/queue.c **** 			}
 785:Source/queue.c **** 			taskEXIT_CRITICAL();
 786:Source/queue.c **** 		}
 787:Source/queue.c **** 	}
 788:Source/queue.c **** 
 789:Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 790:Source/queue.c **** /*-----------------------------------------------------------*/
 791:Source/queue.c **** 
 792:Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 793:Source/queue.c **** 
 794:Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTick
 795:Source/queue.c **** 	{
 796:Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 797:Source/queue.c **** 	xTimeOutType xTimeOut;
 798:Source/queue.c **** 	signed char *pcOriginalReadPosition;
 799:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 800:Source/queue.c **** 
 801:Source/queue.c **** 		configASSERT( pxQueue );
 802:Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 803:Source/queue.c **** 
 804:Source/queue.c **** 		for( ;; )
 805:Source/queue.c **** 		{
 806:Source/queue.c **** 			taskENTER_CRITICAL();
 807:Source/queue.c **** 			{
 808:Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 809:Source/queue.c **** 				{
 810:Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 811:Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 812:Source/queue.c **** 
 813:Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 814:Source/queue.c **** 
 815:Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 816:Source/queue.c **** 					{
 817:Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 818:Source/queue.c **** 
 819:Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 820:Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 821:Source/queue.c **** 
 822:Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 823:Source/queue.c **** 						{
 824:Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 825:Source/queue.c **** 							{
 826:Source/queue.c **** 								/* Record the information required to implement
 827:Source/queue.c **** 								priority inheritance should it become necessary. */
 828:Source/queue.c **** 								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
 829:Source/queue.c **** 							}
 830:Source/queue.c **** 						}
 831:Source/queue.c **** 						#endif
 832:Source/queue.c **** 
 833:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 834:Source/queue.c **** 						{
 835:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 836:Source/queue.c **** 							{
 837:Source/queue.c **** 								portYIELD_WITHIN_API();
 838:Source/queue.c **** 							}
 839:Source/queue.c **** 						}
 840:Source/queue.c **** 					}
 841:Source/queue.c **** 					else
 842:Source/queue.c **** 					{
 843:Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 844:Source/queue.c **** 
 845:Source/queue.c **** 						/* We are not removing the data, so reset our read
 846:Source/queue.c **** 						pointer. */
 847:Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 848:Source/queue.c **** 
 849:Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 850:Source/queue.c **** 						any other tasks waiting for the data. */
 851:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 852:Source/queue.c **** 						{
 853:Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 854:Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 855:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 856:Source/queue.c **** 							{
 857:Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 858:Source/queue.c **** 								portYIELD_WITHIN_API();
 859:Source/queue.c **** 							}
 860:Source/queue.c **** 						}
 861:Source/queue.c **** 
 862:Source/queue.c **** 					}
 863:Source/queue.c **** 
 864:Source/queue.c **** 					taskEXIT_CRITICAL();
 865:Source/queue.c **** 					return pdPASS;
 866:Source/queue.c **** 				}
 867:Source/queue.c **** 				else
 868:Source/queue.c **** 				{
 869:Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 870:Source/queue.c **** 					{
 871:Source/queue.c **** 						taskEXIT_CRITICAL();
 872:Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 873:Source/queue.c **** 						return errQUEUE_EMPTY;
 874:Source/queue.c **** 					}
 875:Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 876:Source/queue.c **** 					{
 877:Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 878:Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 879:Source/queue.c **** 					}
 880:Source/queue.c **** 				}
 881:Source/queue.c **** 			}
 882:Source/queue.c **** 			taskEXIT_CRITICAL();
 883:Source/queue.c **** 
 884:Source/queue.c **** 			taskENTER_CRITICAL();
 885:Source/queue.c **** 			{
 886:Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 887:Source/queue.c **** 				{
 888:Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 889:Source/queue.c **** 					{
 890:Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 891:Source/queue.c **** 
 892:Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 893:Source/queue.c **** 						{
 894:Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 895:Source/queue.c **** 							{
 896:Source/queue.c **** 								portENTER_CRITICAL();
 897:Source/queue.c **** 								{
 898:Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 899:Source/queue.c **** 								}
 900:Source/queue.c **** 								portEXIT_CRITICAL();
 901:Source/queue.c **** 							}
 902:Source/queue.c **** 						}
 903:Source/queue.c **** 						#endif
 904:Source/queue.c **** 
 905:Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 906:Source/queue.c **** 						portYIELD_WITHIN_API();
 907:Source/queue.c **** 					}
 908:Source/queue.c **** 				}
 909:Source/queue.c **** 				else
 910:Source/queue.c **** 				{
 911:Source/queue.c **** 					taskEXIT_CRITICAL();
 912:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 913:Source/queue.c **** 					return errQUEUE_EMPTY;
 914:Source/queue.c **** 				}
 915:Source/queue.c **** 			}
 916:Source/queue.c **** 			taskEXIT_CRITICAL();
 917:Source/queue.c **** 		}
 918:Source/queue.c **** 	}
 919:Source/queue.c **** 
 920:Source/queue.c **** 
 921:Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 922:Source/queue.c **** /*-----------------------------------------------------------*/
 923:Source/queue.c **** 
 924:Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueu
 925:Source/queue.c **** {
 839              		.loc 1 925 0
 840              		.cfi_startproc
 841              		@ args = 0, pretend = 0, frame = 32
 842              		@ frame_needed = 1, uses_anonymous_args = 0
 843 0000 80B5     		push	{r7, lr}
 844              	.LCFI21:
 845              		.cfi_def_cfa_offset 8
 846              		.cfi_offset 7, -8
 847              		.cfi_offset 14, -4
 848 0002 88B0     		sub	sp, sp, #32
 849              	.LCFI22:
 850              		.cfi_def_cfa_offset 40
 851 0004 00AF     		add	r7, sp, #0
 852              	.LCFI23:
 853              		.cfi_def_cfa_register 7
 854 0006 F860     		str	r0, [r7, #12]
 855 0008 B960     		str	r1, [r7, #8]
 856 000a 7A60     		str	r2, [r7, #4]
 857 000c 3B60     		str	r3, [r7]
 926:Source/queue.c **** signed portBASE_TYPE xReturn;
 927:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 928:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 858              		.loc 1 928 0
 859 000e FB68     		ldr	r3, [r7, #12]
 860 0010 BB61     		str	r3, [r7, #24]
 929:Source/queue.c **** 
 930:Source/queue.c **** 	configASSERT( pxQueue );
 861              		.loc 1 930 0
 862 0012 BB69     		ldr	r3, [r7, #24]
 863 0014 002B     		cmp	r3, #0
 864 0016 02D1     		bne	.L65
 865              		.loc 1 930 0 is_stmt 0 discriminator 1
 866 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 867              	.L66:
 868 001c FEE7     		b	.L66
 869              	.L65:
 931:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 870              		.loc 1 931 0 is_stmt 1
 871 001e BB68     		ldr	r3, [r7, #8]
 872 0020 002B     		cmp	r3, #0
 873 0022 03D1     		bne	.L67
 874              		.loc 1 931 0 is_stmt 0 discriminator 2
 875 0024 BB69     		ldr	r3, [r7, #24]
 876 0026 1B6C     		ldr	r3, [r3, #64]
 877 0028 002B     		cmp	r3, #0
 878 002a 01D1     		bne	.L68
 879              	.L67:
 880              		.loc 1 931 0 discriminator 1
 881 002c 0123     		movs	r3, #1
 882 002e 00E0     		b	.L69
 883              	.L68:
 884              		.loc 1 931 0 discriminator 3
 885 0030 0023     		movs	r3, #0
 886              	.L69:
 887              		.loc 1 931 0 discriminator 4
 888 0032 002B     		cmp	r3, #0
 889 0034 02D1     		bne	.L70
 890              		.loc 1 931 0 discriminator 1
 891 0036 FFF7FEFF 		bl	ulPortSetInterruptMask
 892              	.L71:
 893 003a FEE7     		b	.L71
 894              	.L70:
 932:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 895              		.loc 1 932 0 is_stmt 1
 896 003c 3B68     		ldr	r3, [r7]
 897 003e 022B     		cmp	r3, #2
 898 0040 03D1     		bne	.L72
 899              		.loc 1 932 0 is_stmt 0 discriminator 2
 900 0042 BB69     		ldr	r3, [r7, #24]
 901 0044 DB6B     		ldr	r3, [r3, #60]
 902 0046 012B     		cmp	r3, #1
 903 0048 01D1     		bne	.L73
 904              	.L72:
 905              		.loc 1 932 0 discriminator 1
 906 004a 0123     		movs	r3, #1
 907 004c 00E0     		b	.L74
 908              	.L73:
 909              		.loc 1 932 0 discriminator 3
 910 004e 0023     		movs	r3, #0
 911              	.L74:
 912              		.loc 1 932 0 discriminator 4
 913 0050 002B     		cmp	r3, #0
 914 0052 02D1     		bne	.L75
 915              		.loc 1 932 0 discriminator 1
 916 0054 FFF7FEFF 		bl	ulPortSetInterruptMask
 917              	.L76:
 918 0058 FEE7     		b	.L76
 919              	.L75:
 933:Source/queue.c **** 
 934:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 935:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 936:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
 937:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 938:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 939:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 940:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 941:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 942:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 943:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 944:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 945:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 946:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 947:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 948:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 920              		.loc 1 948 0 is_stmt 1
 921 005a FFF7FEFF 		bl	vPortValidateInterruptPriority
 949:Source/queue.c **** 
 950:Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 951:Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 952:Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 953:Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 954:Source/queue.c **** 	by this	post). */
 955:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 922              		.loc 1 955 0
 923 005e FFF7FEFF 		bl	ulPortSetInterruptMask
 924 0062 7861     		str	r0, [r7, #20]
 956:Source/queue.c **** 	{
 957:Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 925              		.loc 1 957 0
 926 0064 BB69     		ldr	r3, [r7, #24]
 927 0066 9A6B     		ldr	r2, [r3, #56]
 928 0068 BB69     		ldr	r3, [r7, #24]
 929 006a DB6B     		ldr	r3, [r3, #60]
 930 006c 9A42     		cmp	r2, r3
 931 006e 02D3     		bcc	.L77
 932              		.loc 1 957 0 is_stmt 0 discriminator 1
 933 0070 3B68     		ldr	r3, [r7]
 934 0072 022B     		cmp	r3, #2
 935 0074 24D1     		bne	.L78
 936              	.L77:
 958:Source/queue.c **** 		{
 959:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 960:Source/queue.c **** 
 961:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 937              		.loc 1 961 0 is_stmt 1
 938 0076 B869     		ldr	r0, [r7, #24]
 939 0078 B968     		ldr	r1, [r7, #8]
 940 007a 3A68     		ldr	r2, [r7]
 941 007c FFF7FEFF 		bl	prvCopyDataToQueue
 962:Source/queue.c **** 
 963:Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 964:Source/queue.c **** 			be done when the queue is unlocked later. */
 965:Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 942              		.loc 1 965 0
 943 0080 BB69     		ldr	r3, [r7, #24]
 944 0082 9B6C     		ldr	r3, [r3, #72]
 945 0084 B3F1FF3F 		cmp	r3, #-1
 946 0088 12D1     		bne	.L79
 966:Source/queue.c **** 			{
 967:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 968:Source/queue.c **** 				{
 969:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 970:Source/queue.c **** 					{
 971:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 972:Source/queue.c **** 						{
 973:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 974:Source/queue.c **** 							to the queue set caused a higher priority task to
 975:Source/queue.c **** 							unblock.  A context switch is required. */
 976:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 977:Source/queue.c **** 							{
 978:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 979:Source/queue.c **** 							}
 980:Source/queue.c **** 						}
 981:Source/queue.c **** 					}
 982:Source/queue.c **** 					else
 983:Source/queue.c **** 					{
 984:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 985:Source/queue.c **** 						{
 986:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 987:Source/queue.c **** 							{
 988:Source/queue.c **** 								/* The task waiting has a higher priority so record that a
 989:Source/queue.c **** 								context	switch is required. */
 990:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 991:Source/queue.c **** 								{
 992:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 993:Source/queue.c **** 								}
 994:Source/queue.c **** 							}
 995:Source/queue.c **** 						}
 996:Source/queue.c **** 					}
 997:Source/queue.c **** 				}
 998:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 999:Source/queue.c **** 				{
1000:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 947              		.loc 1 1000 0
 948 008a BB69     		ldr	r3, [r7, #24]
 949 008c 5B6A     		ldr	r3, [r3, #36]
 950 008e 002B     		cmp	r3, #0
 951 0090 13D0     		beq	.L81
1001:Source/queue.c **** 					{
1002:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 952              		.loc 1 1002 0
 953 0092 BB69     		ldr	r3, [r7, #24]
 954 0094 2433     		adds	r3, r3, #36
 955 0096 1846     		mov	r0, r3
 956 0098 FFF7FEFF 		bl	xTaskRemoveFromEventList
 957 009c 0346     		mov	r3, r0
 958 009e 002B     		cmp	r3, #0
 959 00a0 0BD0     		beq	.L81
1003:Source/queue.c **** 						{
1004:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1005:Source/queue.c **** 							context	switch is required. */
1006:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 960              		.loc 1 1006 0
 961 00a2 7B68     		ldr	r3, [r7, #4]
 962 00a4 002B     		cmp	r3, #0
 963 00a6 08D0     		beq	.L81
1007:Source/queue.c **** 							{
1008:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 964              		.loc 1 1008 0
 965 00a8 7B68     		ldr	r3, [r7, #4]
 966 00aa 0122     		movs	r2, #1
 967 00ac 1A60     		str	r2, [r3]
 968 00ae 04E0     		b	.L81
 969              	.L79:
1009:Source/queue.c **** 							}
1010:Source/queue.c **** 						}
1011:Source/queue.c **** 					}
1012:Source/queue.c **** 				}
1013:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1014:Source/queue.c **** 			}
1015:Source/queue.c **** 			else
1016:Source/queue.c **** 			{
1017:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1018:Source/queue.c **** 				knows that data was posted while it was locked. */
1019:Source/queue.c **** 				++( pxQueue->xTxLock );
 970              		.loc 1 1019 0
 971 00b0 BB69     		ldr	r3, [r7, #24]
 972 00b2 9B6C     		ldr	r3, [r3, #72]
 973 00b4 5A1C     		adds	r2, r3, #1
 974 00b6 BB69     		ldr	r3, [r7, #24]
 975 00b8 9A64     		str	r2, [r3, #72]
 976              	.L81:
1020:Source/queue.c **** 			}
1021:Source/queue.c **** 
1022:Source/queue.c **** 			xReturn = pdPASS;
 977              		.loc 1 1022 0
 978 00ba 0123     		movs	r3, #1
 979 00bc FB61     		str	r3, [r7, #28]
 980 00be 01E0     		b	.L82
 981              	.L78:
1023:Source/queue.c **** 		}
1024:Source/queue.c **** 		else
1025:Source/queue.c **** 		{
1026:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1027:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 982              		.loc 1 1027 0
 983 00c0 0023     		movs	r3, #0
 984 00c2 FB61     		str	r3, [r7, #28]
 985              	.L82:
1028:Source/queue.c **** 		}
1029:Source/queue.c **** 	}
1030:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 986              		.loc 1 1030 0
 987 00c4 7869     		ldr	r0, [r7, #20]
 988 00c6 FFF7FEFF 		bl	vPortClearInterruptMask
1031:Source/queue.c **** 
1032:Source/queue.c **** 	return xReturn;
 989              		.loc 1 1032 0
 990 00ca FB69     		ldr	r3, [r7, #28]
1033:Source/queue.c **** }
 991              		.loc 1 1033 0
 992 00cc 1846     		mov	r0, r3
 993 00ce 2037     		adds	r7, r7, #32
 994 00d0 BD46     		mov	sp, r7
 995              		@ sp needed
 996 00d2 80BD     		pop	{r7, pc}
 997              		.cfi_endproc
 998              	.LFE117:
 1000              		.section	.text.xQueueGenericReceive,"ax",%progbits
 1001              		.align	2
 1002              		.global	xQueueGenericReceive
 1003              		.thumb
 1004              		.thumb_func
 1006              	xQueueGenericReceive:
 1007              	.LFB118:
1034:Source/queue.c **** /*-----------------------------------------------------------*/
1035:Source/queue.c **** 
1036:Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTi
1037:Source/queue.c **** {
 1008              		.loc 1 1037 0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 40
 1011              		@ frame_needed = 1, uses_anonymous_args = 0
 1012 0000 80B5     		push	{r7, lr}
 1013              	.LCFI24:
 1014              		.cfi_def_cfa_offset 8
 1015              		.cfi_offset 7, -8
 1016              		.cfi_offset 14, -4
 1017 0002 8AB0     		sub	sp, sp, #40
 1018              	.LCFI25:
 1019              		.cfi_def_cfa_offset 48
 1020 0004 00AF     		add	r7, sp, #0
 1021              	.LCFI26:
 1022              		.cfi_def_cfa_register 7
 1023 0006 F860     		str	r0, [r7, #12]
 1024 0008 B960     		str	r1, [r7, #8]
 1025 000a 7A60     		str	r2, [r7, #4]
 1026 000c 3B60     		str	r3, [r7]
1038:Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1027              		.loc 1 1038 0
 1028 000e 0023     		movs	r3, #0
 1029 0010 7B62     		str	r3, [r7, #36]
1039:Source/queue.c **** xTimeOutType xTimeOut;
1040:Source/queue.c **** signed char *pcOriginalReadPosition;
1041:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1030              		.loc 1 1041 0
 1031 0012 FB68     		ldr	r3, [r7, #12]
 1032 0014 3B62     		str	r3, [r7, #32]
1042:Source/queue.c **** 
1043:Source/queue.c **** 	configASSERT( pxQueue );
 1033              		.loc 1 1043 0
 1034 0016 3B6A     		ldr	r3, [r7, #32]
 1035 0018 002B     		cmp	r3, #0
 1036 001a 02D1     		bne	.L85
 1037              		.loc 1 1043 0 is_stmt 0 discriminator 1
 1038 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 1039              	.L86:
 1040 0020 FEE7     		b	.L86
 1041              	.L85:
1044:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1042              		.loc 1 1044 0 is_stmt 1
 1043 0022 BB68     		ldr	r3, [r7, #8]
 1044 0024 002B     		cmp	r3, #0
 1045 0026 03D1     		bne	.L87
 1046              		.loc 1 1044 0 is_stmt 0 discriminator 2
 1047 0028 3B6A     		ldr	r3, [r7, #32]
 1048 002a 1B6C     		ldr	r3, [r3, #64]
 1049 002c 002B     		cmp	r3, #0
 1050 002e 01D1     		bne	.L88
 1051              	.L87:
 1052              		.loc 1 1044 0 discriminator 1
 1053 0030 0123     		movs	r3, #1
 1054 0032 00E0     		b	.L89
 1055              	.L88:
 1056              		.loc 1 1044 0 discriminator 3
 1057 0034 0023     		movs	r3, #0
 1058              	.L89:
 1059              		.loc 1 1044 0 discriminator 4
 1060 0036 002B     		cmp	r3, #0
 1061 0038 02D1     		bne	.L90
 1062              		.loc 1 1044 0 discriminator 1
 1063 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 1064              	.L91:
 1065 003e FEE7     		b	.L91
 1066              	.L90:
1045:Source/queue.c **** 
1046:Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1047:Source/queue.c **** 	statements within the function itself.  This is done in the interest
1048:Source/queue.c **** 	of execution time efficiency. */
1049:Source/queue.c **** 
1050:Source/queue.c **** 	for( ;; )
1051:Source/queue.c **** 	{
1052:Source/queue.c **** 		taskENTER_CRITICAL();
 1067              		.loc 1 1052 0 is_stmt 1
 1068 0040 FFF7FEFF 		bl	vPortEnterCritical
1053:Source/queue.c **** 		{
1054:Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1055:Source/queue.c **** 			the highest priority task wanting to access the queue. */
1056:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1069              		.loc 1 1056 0
 1070 0044 3B6A     		ldr	r3, [r7, #32]
 1071 0046 9B6B     		ldr	r3, [r3, #56]
 1072 0048 002B     		cmp	r3, #0
 1073 004a 3BD0     		beq	.L92
1057:Source/queue.c **** 			{
1058:Source/queue.c **** 				/* Remember the read position in case the queue is only being
1059:Source/queue.c **** 				peeked. */
1060:Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1074              		.loc 1 1060 0
 1075 004c 3B6A     		ldr	r3, [r7, #32]
 1076 004e DB68     		ldr	r3, [r3, #12]
 1077 0050 FB61     		str	r3, [r7, #28]
1061:Source/queue.c **** 
1062:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1078              		.loc 1 1062 0
 1079 0052 386A     		ldr	r0, [r7, #32]
 1080 0054 B968     		ldr	r1, [r7, #8]
 1081 0056 FFF7FEFF 		bl	prvCopyDataFromQueue
1063:Source/queue.c **** 
1064:Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1082              		.loc 1 1064 0
 1083 005a 3B68     		ldr	r3, [r7]
 1084 005c 002B     		cmp	r3, #0
 1085 005e 1CD1     		bne	.L93
1065:Source/queue.c **** 				{
1066:Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1067:Source/queue.c **** 
1068:Source/queue.c **** 					/* Actually removing data, not just peeking. */
1069:Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1086              		.loc 1 1069 0
 1087 0060 3B6A     		ldr	r3, [r7, #32]
 1088 0062 9B6B     		ldr	r3, [r3, #56]
 1089 0064 5A1E     		subs	r2, r3, #1
 1090 0066 3B6A     		ldr	r3, [r7, #32]
 1091 0068 9A63     		str	r2, [r3, #56]
1070:Source/queue.c **** 
1071:Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1072:Source/queue.c **** 					{
1073:Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1092              		.loc 1 1073 0
 1093 006a 3B6A     		ldr	r3, [r7, #32]
 1094 006c 1B68     		ldr	r3, [r3]
 1095 006e 002B     		cmp	r3, #0
 1096 0070 04D1     		bne	.L94
1074:Source/queue.c **** 						{
1075:Source/queue.c **** 							/* Record the information required to implement
1076:Source/queue.c **** 							priority inheritance should it become necessary. */
1077:Source/queue.c **** 							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is
 1097              		.loc 1 1077 0
 1098 0072 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1099 0076 0246     		mov	r2, r0
 1100 0078 3B6A     		ldr	r3, [r7, #32]
 1101 007a 5A60     		str	r2, [r3, #4]
 1102              	.L94:
1078:Source/queue.c **** 						}
1079:Source/queue.c **** 					}
1080:Source/queue.c **** 					#endif
1081:Source/queue.c **** 
1082:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1103              		.loc 1 1082 0
 1104 007c 3B6A     		ldr	r3, [r7, #32]
 1105 007e 1B69     		ldr	r3, [r3, #16]
 1106 0080 002B     		cmp	r3, #0
 1107 0082 1BD0     		beq	.L96
1083:Source/queue.c **** 					{
1084:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1108              		.loc 1 1084 0
 1109 0084 3B6A     		ldr	r3, [r7, #32]
 1110 0086 1033     		adds	r3, r3, #16
 1111 0088 1846     		mov	r0, r3
 1112 008a FFF7FEFF 		bl	xTaskRemoveFromEventList
 1113 008e 0346     		mov	r3, r0
 1114 0090 012B     		cmp	r3, #1
 1115 0092 13D1     		bne	.L96
1085:Source/queue.c **** 						{
1086:Source/queue.c **** 							portYIELD_WITHIN_API();
 1116              		.loc 1 1086 0
 1117 0094 FFF7FEFF 		bl	vPortYield
 1118 0098 10E0     		b	.L96
 1119              	.L93:
1087:Source/queue.c **** 						}
1088:Source/queue.c **** 					}
1089:Source/queue.c **** 				}
1090:Source/queue.c **** 				else
1091:Source/queue.c **** 				{
1092:Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1093:Source/queue.c **** 
1094:Source/queue.c **** 					/* The data is not being removed, so reset the read
1095:Source/queue.c **** 					pointer. */
1096:Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1120              		.loc 1 1096 0
 1121 009a 3B6A     		ldr	r3, [r7, #32]
 1122 009c FA69     		ldr	r2, [r7, #28]
 1123 009e DA60     		str	r2, [r3, #12]
1097:Source/queue.c **** 
1098:Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1099:Source/queue.c **** 					any other tasks waiting for the data. */
1100:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1124              		.loc 1 1100 0
 1125 00a0 3B6A     		ldr	r3, [r7, #32]
 1126 00a2 5B6A     		ldr	r3, [r3, #36]
 1127 00a4 002B     		cmp	r3, #0
 1128 00a6 09D0     		beq	.L96
1101:Source/queue.c **** 					{
1102:Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1103:Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1104:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1129              		.loc 1 1104 0
 1130 00a8 3B6A     		ldr	r3, [r7, #32]
 1131 00aa 2433     		adds	r3, r3, #36
 1132 00ac 1846     		mov	r0, r3
 1133 00ae FFF7FEFF 		bl	xTaskRemoveFromEventList
 1134 00b2 0346     		mov	r3, r0
 1135 00b4 002B     		cmp	r3, #0
 1136 00b6 01D0     		beq	.L96
1105:Source/queue.c **** 						{
1106:Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1107:Source/queue.c **** 							portYIELD_WITHIN_API();
 1137              		.loc 1 1107 0
 1138 00b8 FFF7FEFF 		bl	vPortYield
 1139              	.L96:
1108:Source/queue.c **** 						}
1109:Source/queue.c **** 					}
1110:Source/queue.c **** 				}
1111:Source/queue.c **** 
1112:Source/queue.c **** 				taskEXIT_CRITICAL();
 1140              		.loc 1 1112 0
 1141 00bc FFF7FEFF 		bl	vPortExitCritical
1113:Source/queue.c **** 				return pdPASS;
 1142              		.loc 1 1113 0
 1143 00c0 0123     		movs	r3, #1
 1144 00c2 66E0     		b	.L108
 1145              	.L92:
1114:Source/queue.c **** 			}
1115:Source/queue.c **** 			else
1116:Source/queue.c **** 			{
1117:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1146              		.loc 1 1117 0
 1147 00c4 7B68     		ldr	r3, [r7, #4]
 1148 00c6 002B     		cmp	r3, #0
 1149 00c8 03D1     		bne	.L98
1118:Source/queue.c **** 				{
1119:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1120:Source/queue.c **** 					the block time has expired) so leave now. */
1121:Source/queue.c **** 					taskEXIT_CRITICAL();
 1150              		.loc 1 1121 0
 1151 00ca FFF7FEFF 		bl	vPortExitCritical
1122:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1123:Source/queue.c **** 					return errQUEUE_EMPTY;
 1152              		.loc 1 1123 0
 1153 00ce 0023     		movs	r3, #0
 1154 00d0 5FE0     		b	.L108
 1155              	.L98:
1124:Source/queue.c **** 				}
1125:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1156              		.loc 1 1125 0
 1157 00d2 7B6A     		ldr	r3, [r7, #36]
 1158 00d4 002B     		cmp	r3, #0
 1159 00d6 06D1     		bne	.L99
1126:Source/queue.c **** 				{
1127:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1128:Source/queue.c **** 					configure the timeout structure. */
1129:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1160              		.loc 1 1129 0
 1161 00d8 07F11403 		add	r3, r7, #20
 1162 00dc 1846     		mov	r0, r3
 1163 00de FFF7FEFF 		bl	vTaskSetTimeOutState
1130:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1164              		.loc 1 1130 0
 1165 00e2 0123     		movs	r3, #1
 1166 00e4 7B62     		str	r3, [r7, #36]
 1167              	.L99:
1131:Source/queue.c **** 				}
1132:Source/queue.c **** 				else
1133:Source/queue.c **** 				{
1134:Source/queue.c **** 					/* Entry time was already set. */
1135:Source/queue.c **** 				}
1136:Source/queue.c **** 			}
1137:Source/queue.c **** 		}
1138:Source/queue.c **** 		taskEXIT_CRITICAL();
 1168              		.loc 1 1138 0
 1169 00e6 FFF7FEFF 		bl	vPortExitCritical
1139:Source/queue.c **** 
1140:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1141:Source/queue.c **** 		now the critical section has been exited. */
1142:Source/queue.c **** 
1143:Source/queue.c **** 		vTaskSuspendAll();
 1170              		.loc 1 1143 0
 1171 00ea FFF7FEFF 		bl	vTaskSuspendAll
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1172              		.loc 1 1144 0
 1173 00ee FFF7FEFF 		bl	vPortEnterCritical
 1174 00f2 3B6A     		ldr	r3, [r7, #32]
 1175 00f4 5B6C     		ldr	r3, [r3, #68]
 1176 00f6 B3F1FF3F 		cmp	r3, #-1
 1177 00fa 02D1     		bne	.L100
 1178              		.loc 1 1144 0 is_stmt 0 discriminator 1
 1179 00fc 3B6A     		ldr	r3, [r7, #32]
 1180 00fe 0022     		movs	r2, #0
 1181 0100 5A64     		str	r2, [r3, #68]
 1182              	.L100:
 1183              		.loc 1 1144 0 discriminator 2
 1184 0102 3B6A     		ldr	r3, [r7, #32]
 1185 0104 9B6C     		ldr	r3, [r3, #72]
 1186 0106 B3F1FF3F 		cmp	r3, #-1
 1187 010a 02D1     		bne	.L101
 1188              		.loc 1 1144 0 discriminator 1
 1189 010c 3B6A     		ldr	r3, [r7, #32]
 1190 010e 0022     		movs	r2, #0
 1191 0110 9A64     		str	r2, [r3, #72]
 1192              	.L101:
 1193              		.loc 1 1144 0 discriminator 2
 1194 0112 FFF7FEFF 		bl	vPortExitCritical
1145:Source/queue.c **** 
1146:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1147:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1195              		.loc 1 1147 0 is_stmt 1 discriminator 2
 1196 0116 07F11402 		add	r2, r7, #20
 1197 011a 3B1D     		adds	r3, r7, #4
 1198 011c 1046     		mov	r0, r2
 1199 011e 1946     		mov	r1, r3
 1200 0120 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1201 0124 0346     		mov	r3, r0
 1202 0126 002B     		cmp	r3, #0
 1203 0128 2BD1     		bne	.L102
1148:Source/queue.c **** 		{
1149:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1204              		.loc 1 1149 0
 1205 012a 386A     		ldr	r0, [r7, #32]
 1206 012c FFF7FEFF 		bl	prvIsQueueEmpty
 1207 0130 0346     		mov	r3, r0
 1208 0132 002B     		cmp	r3, #0
 1209 0134 1FD0     		beq	.L103
1150:Source/queue.c **** 			{
1151:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1152:Source/queue.c **** 
1153:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1154:Source/queue.c **** 				{
1155:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1210              		.loc 1 1155 0
 1211 0136 3B6A     		ldr	r3, [r7, #32]
 1212 0138 1B68     		ldr	r3, [r3]
 1213 013a 002B     		cmp	r3, #0
 1214 013c 08D1     		bne	.L104
1156:Source/queue.c **** 					{
1157:Source/queue.c **** 						portENTER_CRITICAL();
 1215              		.loc 1 1157 0
 1216 013e FFF7FEFF 		bl	vPortEnterCritical
1158:Source/queue.c **** 						{
1159:Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1217              		.loc 1 1159 0
 1218 0142 3B6A     		ldr	r3, [r7, #32]
 1219 0144 5B68     		ldr	r3, [r3, #4]
 1220 0146 1846     		mov	r0, r3
 1221 0148 FFF7FEFF 		bl	vTaskPriorityInherit
1160:Source/queue.c **** 						}
1161:Source/queue.c **** 						portEXIT_CRITICAL();
 1222              		.loc 1 1161 0
 1223 014c FFF7FEFF 		bl	vPortExitCritical
 1224              	.L104:
1162:Source/queue.c **** 					}
1163:Source/queue.c **** 				}
1164:Source/queue.c **** 				#endif
1165:Source/queue.c **** 
1166:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1225              		.loc 1 1166 0
 1226 0150 3B6A     		ldr	r3, [r7, #32]
 1227 0152 03F12402 		add	r2, r3, #36
 1228 0156 7B68     		ldr	r3, [r7, #4]
 1229 0158 1046     		mov	r0, r2
 1230 015a 1946     		mov	r1, r3
 1231 015c FFF7FEFF 		bl	vTaskPlaceOnEventList
1167:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1232              		.loc 1 1167 0
 1233 0160 386A     		ldr	r0, [r7, #32]
 1234 0162 FFF7FEFF 		bl	prvUnlockQueue
1168:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1235              		.loc 1 1168 0
 1236 0166 FFF7FEFF 		bl	xTaskResumeAll
 1237 016a 0346     		mov	r3, r0
 1238 016c 002B     		cmp	r3, #0
 1239 016e 0FD1     		bne	.L107
1169:Source/queue.c **** 				{
1170:Source/queue.c **** 					portYIELD_WITHIN_API();
 1240              		.loc 1 1170 0
 1241 0170 FFF7FEFF 		bl	vPortYield
 1242 0174 0CE0     		b	.L107
 1243              	.L103:
1171:Source/queue.c **** 				}
1172:Source/queue.c **** 			}
1173:Source/queue.c **** 			else
1174:Source/queue.c **** 			{
1175:Source/queue.c **** 				/* Try again. */
1176:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1244              		.loc 1 1176 0
 1245 0176 386A     		ldr	r0, [r7, #32]
 1246 0178 FFF7FEFF 		bl	prvUnlockQueue
1177:Source/queue.c **** 				( void ) xTaskResumeAll();
 1247              		.loc 1 1177 0
 1248 017c FFF7FEFF 		bl	xTaskResumeAll
1178:Source/queue.c **** 			}
1179:Source/queue.c **** 		}
1180:Source/queue.c **** 		else
1181:Source/queue.c **** 		{
1182:Source/queue.c **** 			prvUnlockQueue( pxQueue );
1183:Source/queue.c **** 			( void ) xTaskResumeAll();
1184:Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1185:Source/queue.c **** 			return errQUEUE_EMPTY;
1186:Source/queue.c **** 		}
1187:Source/queue.c **** 	}
 1249              		.loc 1 1187 0
 1250 0180 5EE7     		b	.L90
 1251              	.L102:
1182:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1252              		.loc 1 1182 0
 1253 0182 386A     		ldr	r0, [r7, #32]
 1254 0184 FFF7FEFF 		bl	prvUnlockQueue
1183:Source/queue.c **** 			( void ) xTaskResumeAll();
 1255              		.loc 1 1183 0
 1256 0188 FFF7FEFF 		bl	xTaskResumeAll
1185:Source/queue.c **** 			return errQUEUE_EMPTY;
 1257              		.loc 1 1185 0
 1258 018c 0023     		movs	r3, #0
 1259 018e 00E0     		b	.L108
 1260              	.L107:
 1261              		.loc 1 1187 0
 1262 0190 56E7     		b	.L90
 1263              	.L108:
1188:Source/queue.c **** }
 1264              		.loc 1 1188 0
 1265 0192 1846     		mov	r0, r3
 1266 0194 2837     		adds	r7, r7, #40
 1267 0196 BD46     		mov	sp, r7
 1268              		@ sp needed
 1269 0198 80BD     		pop	{r7, pc}
 1270              		.cfi_endproc
 1271              	.LFE118:
 1273 019a 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1274              		.align	2
 1275              		.global	xQueueReceiveFromISR
 1276              		.thumb
 1277              		.thumb_func
 1279              	xQueueReceiveFromISR:
 1280              	.LFB119:
1189:Source/queue.c **** /*-----------------------------------------------------------*/
1190:Source/queue.c **** 
1191:Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed
1192:Source/queue.c **** {
 1281              		.loc 1 1192 0
 1282              		.cfi_startproc
 1283              		@ args = 0, pretend = 0, frame = 32
 1284              		@ frame_needed = 1, uses_anonymous_args = 0
 1285 0000 80B5     		push	{r7, lr}
 1286              	.LCFI27:
 1287              		.cfi_def_cfa_offset 8
 1288              		.cfi_offset 7, -8
 1289              		.cfi_offset 14, -4
 1290 0002 88B0     		sub	sp, sp, #32
 1291              	.LCFI28:
 1292              		.cfi_def_cfa_offset 40
 1293 0004 00AF     		add	r7, sp, #0
 1294              	.LCFI29:
 1295              		.cfi_def_cfa_register 7
 1296 0006 F860     		str	r0, [r7, #12]
 1297 0008 B960     		str	r1, [r7, #8]
 1298 000a 7A60     		str	r2, [r7, #4]
1193:Source/queue.c **** signed portBASE_TYPE xReturn;
1194:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1195:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1299              		.loc 1 1195 0
 1300 000c FB68     		ldr	r3, [r7, #12]
 1301 000e BB61     		str	r3, [r7, #24]
1196:Source/queue.c **** 
1197:Source/queue.c **** 	configASSERT( pxQueue );
 1302              		.loc 1 1197 0
 1303 0010 BB69     		ldr	r3, [r7, #24]
 1304 0012 002B     		cmp	r3, #0
 1305 0014 02D1     		bne	.L110
 1306              		.loc 1 1197 0 is_stmt 0 discriminator 1
 1307 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1308              	.L111:
 1309 001a FEE7     		b	.L111
 1310              	.L110:
1198:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1311              		.loc 1 1198 0 is_stmt 1
 1312 001c BB68     		ldr	r3, [r7, #8]
 1313 001e 002B     		cmp	r3, #0
 1314 0020 03D1     		bne	.L112
 1315              		.loc 1 1198 0 is_stmt 0 discriminator 2
 1316 0022 BB69     		ldr	r3, [r7, #24]
 1317 0024 1B6C     		ldr	r3, [r3, #64]
 1318 0026 002B     		cmp	r3, #0
 1319 0028 01D1     		bne	.L113
 1320              	.L112:
 1321              		.loc 1 1198 0 discriminator 1
 1322 002a 0123     		movs	r3, #1
 1323 002c 00E0     		b	.L114
 1324              	.L113:
 1325              		.loc 1 1198 0 discriminator 3
 1326 002e 0023     		movs	r3, #0
 1327              	.L114:
 1328              		.loc 1 1198 0 discriminator 4
 1329 0030 002B     		cmp	r3, #0
 1330 0032 02D1     		bne	.L115
 1331              		.loc 1 1198 0 discriminator 1
 1332 0034 FFF7FEFF 		bl	ulPortSetInterruptMask
 1333              	.L116:
 1334 0038 FEE7     		b	.L116
 1335              	.L115:
1199:Source/queue.c **** 
1200:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1201:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1202:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1203:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1204:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1205:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1206:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1207:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1208:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1209:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1210:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1211:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1212:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1213:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1214:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1336              		.loc 1 1214 0 is_stmt 1
 1337 003a FFF7FEFF 		bl	vPortValidateInterruptPriority
1215:Source/queue.c **** 
1216:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1338              		.loc 1 1216 0
 1339 003e FFF7FEFF 		bl	ulPortSetInterruptMask
 1340 0042 7861     		str	r0, [r7, #20]
1217:Source/queue.c **** 	{
1218:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1219:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1341              		.loc 1 1219 0
 1342 0044 BB69     		ldr	r3, [r7, #24]
 1343 0046 9B6B     		ldr	r3, [r3, #56]
 1344 0048 002B     		cmp	r3, #0
 1345 004a 28D0     		beq	.L117
1220:Source/queue.c **** 		{
1221:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1222:Source/queue.c **** 
1223:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1346              		.loc 1 1223 0
 1347 004c B869     		ldr	r0, [r7, #24]
 1348 004e B968     		ldr	r1, [r7, #8]
 1349 0050 FFF7FEFF 		bl	prvCopyDataFromQueue
1224:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1350              		.loc 1 1224 0
 1351 0054 BB69     		ldr	r3, [r7, #24]
 1352 0056 9B6B     		ldr	r3, [r3, #56]
 1353 0058 5A1E     		subs	r2, r3, #1
 1354 005a BB69     		ldr	r3, [r7, #24]
 1355 005c 9A63     		str	r2, [r3, #56]
1225:Source/queue.c **** 
1226:Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1227:Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1228:Source/queue.c **** 			will know that an ISR has removed data while the queue was
1229:Source/queue.c **** 			locked. */
1230:Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1356              		.loc 1 1230 0
 1357 005e BB69     		ldr	r3, [r7, #24]
 1358 0060 5B6C     		ldr	r3, [r3, #68]
 1359 0062 B3F1FF3F 		cmp	r3, #-1
 1360 0066 12D1     		bne	.L118
1231:Source/queue.c **** 			{
1232:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1361              		.loc 1 1232 0
 1362 0068 BB69     		ldr	r3, [r7, #24]
 1363 006a 1B69     		ldr	r3, [r3, #16]
 1364 006c 002B     		cmp	r3, #0
 1365 006e 13D0     		beq	.L120
1233:Source/queue.c **** 				{
1234:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1366              		.loc 1 1234 0
 1367 0070 BB69     		ldr	r3, [r7, #24]
 1368 0072 1033     		adds	r3, r3, #16
 1369 0074 1846     		mov	r0, r3
 1370 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1371 007a 0346     		mov	r3, r0
 1372 007c 002B     		cmp	r3, #0
 1373 007e 0BD0     		beq	.L120
1235:Source/queue.c **** 					{
1236:Source/queue.c **** 						/* The task waiting has a higher priority than us so
1237:Source/queue.c **** 						force a context switch. */
1238:Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1374              		.loc 1 1238 0
 1375 0080 7B68     		ldr	r3, [r7, #4]
 1376 0082 002B     		cmp	r3, #0
 1377 0084 08D0     		beq	.L120
1239:Source/queue.c **** 						{
1240:Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1378              		.loc 1 1240 0
 1379 0086 7B68     		ldr	r3, [r7, #4]
 1380 0088 0122     		movs	r2, #1
 1381 008a 1A60     		str	r2, [r3]
 1382 008c 04E0     		b	.L120
 1383              	.L118:
1241:Source/queue.c **** 						}
1242:Source/queue.c **** 					}
1243:Source/queue.c **** 				}
1244:Source/queue.c **** 			}
1245:Source/queue.c **** 			else
1246:Source/queue.c **** 			{
1247:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1248:Source/queue.c **** 				knows that data was removed while it was locked. */
1249:Source/queue.c **** 				++( pxQueue->xRxLock );
 1384              		.loc 1 1249 0
 1385 008e BB69     		ldr	r3, [r7, #24]
 1386 0090 5B6C     		ldr	r3, [r3, #68]
 1387 0092 5A1C     		adds	r2, r3, #1
 1388 0094 BB69     		ldr	r3, [r7, #24]
 1389 0096 5A64     		str	r2, [r3, #68]
 1390              	.L120:
1250:Source/queue.c **** 			}
1251:Source/queue.c **** 
1252:Source/queue.c **** 			xReturn = pdPASS;
 1391              		.loc 1 1252 0 discriminator 1
 1392 0098 0123     		movs	r3, #1
 1393 009a FB61     		str	r3, [r7, #28]
 1394 009c 01E0     		b	.L121
 1395              	.L117:
1253:Source/queue.c **** 		}
1254:Source/queue.c **** 		else
1255:Source/queue.c **** 		{
1256:Source/queue.c **** 			xReturn = pdFAIL;
 1396              		.loc 1 1256 0
 1397 009e 0023     		movs	r3, #0
 1398 00a0 FB61     		str	r3, [r7, #28]
 1399              	.L121:
1257:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1258:Source/queue.c **** 		}
1259:Source/queue.c **** 	}
1260:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1400              		.loc 1 1260 0
 1401 00a2 7869     		ldr	r0, [r7, #20]
 1402 00a4 FFF7FEFF 		bl	vPortClearInterruptMask
1261:Source/queue.c **** 
1262:Source/queue.c **** 	return xReturn;
 1403              		.loc 1 1262 0
 1404 00a8 FB69     		ldr	r3, [r7, #28]
1263:Source/queue.c **** }
 1405              		.loc 1 1263 0
 1406 00aa 1846     		mov	r0, r3
 1407 00ac 2037     		adds	r7, r7, #32
 1408 00ae BD46     		mov	sp, r7
 1409              		@ sp needed
 1410 00b0 80BD     		pop	{r7, pc}
 1411              		.cfi_endproc
 1412              	.LFE119:
 1414 00b2 00BF     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1415              		.align	2
 1416              		.global	xQueuePeekFromISR
 1417              		.thumb
 1418              		.thumb_func
 1420              	xQueuePeekFromISR:
 1421              	.LFB120:
1264:Source/queue.c **** /*-----------------------------------------------------------*/
1265:Source/queue.c **** 
1266:Source/queue.c **** signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
1267:Source/queue.c **** {
 1422              		.loc 1 1267 0
 1423              		.cfi_startproc
 1424              		@ args = 0, pretend = 0, frame = 24
 1425              		@ frame_needed = 1, uses_anonymous_args = 0
 1426 0000 80B5     		push	{r7, lr}
 1427              	.LCFI30:
 1428              		.cfi_def_cfa_offset 8
 1429              		.cfi_offset 7, -8
 1430              		.cfi_offset 14, -4
 1431 0002 86B0     		sub	sp, sp, #24
 1432              	.LCFI31:
 1433              		.cfi_def_cfa_offset 32
 1434 0004 00AF     		add	r7, sp, #0
 1435              	.LCFI32:
 1436              		.cfi_def_cfa_register 7
 1437 0006 7860     		str	r0, [r7, #4]
 1438 0008 3960     		str	r1, [r7]
1268:Source/queue.c **** signed portBASE_TYPE xReturn;
1269:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1270:Source/queue.c **** signed char *pcOriginalReadPosition;
1271:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1439              		.loc 1 1271 0
 1440 000a 7B68     		ldr	r3, [r7, #4]
 1441 000c 3B61     		str	r3, [r7, #16]
1272:Source/queue.c **** 
1273:Source/queue.c **** 	configASSERT( pxQueue );
 1442              		.loc 1 1273 0
 1443 000e 3B69     		ldr	r3, [r7, #16]
 1444 0010 002B     		cmp	r3, #0
 1445 0012 02D1     		bne	.L124
 1446              		.loc 1 1273 0 is_stmt 0 discriminator 1
 1447 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 1448              	.L125:
 1449 0018 FEE7     		b	.L125
 1450              	.L124:
1274:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1451              		.loc 1 1274 0 is_stmt 1
 1452 001a 3B68     		ldr	r3, [r7]
 1453 001c 002B     		cmp	r3, #0
 1454 001e 03D1     		bne	.L126
 1455              		.loc 1 1274 0 is_stmt 0 discriminator 2
 1456 0020 3B69     		ldr	r3, [r7, #16]
 1457 0022 1B6C     		ldr	r3, [r3, #64]
 1458 0024 002B     		cmp	r3, #0
 1459 0026 01D1     		bne	.L127
 1460              	.L126:
 1461              		.loc 1 1274 0 discriminator 1
 1462 0028 0123     		movs	r3, #1
 1463 002a 00E0     		b	.L128
 1464              	.L127:
 1465              		.loc 1 1274 0 discriminator 3
 1466 002c 0023     		movs	r3, #0
 1467              	.L128:
 1468              		.loc 1 1274 0 discriminator 4
 1469 002e 002B     		cmp	r3, #0
 1470 0030 02D1     		bne	.L129
 1471              		.loc 1 1274 0 discriminator 1
 1472 0032 FFF7FEFF 		bl	ulPortSetInterruptMask
 1473              	.L130:
 1474 0036 FEE7     		b	.L130
 1475              	.L129:
1275:Source/queue.c **** 
1276:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1277:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1278:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1279:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1280:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1281:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1282:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1283:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1284:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1285:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1286:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1287:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1288:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1289:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1290:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1476              		.loc 1 1290 0 is_stmt 1
 1477 0038 FFF7FEFF 		bl	vPortValidateInterruptPriority
1291:Source/queue.c **** 
1292:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1478              		.loc 1 1292 0
 1479 003c FFF7FEFF 		bl	ulPortSetInterruptMask
 1480 0040 F860     		str	r0, [r7, #12]
1293:Source/queue.c **** 	{
1294:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1295:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1481              		.loc 1 1295 0
 1482 0042 3B69     		ldr	r3, [r7, #16]
 1483 0044 9B6B     		ldr	r3, [r3, #56]
 1484 0046 002B     		cmp	r3, #0
 1485 0048 0CD0     		beq	.L131
1296:Source/queue.c **** 		{
1297:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1298:Source/queue.c **** 
1299:Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1300:Source/queue.c **** 			actually being removed from the queue. */
1301:Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1486              		.loc 1 1301 0
 1487 004a 3B69     		ldr	r3, [r7, #16]
 1488 004c DB68     		ldr	r3, [r3, #12]
 1489 004e BB60     		str	r3, [r7, #8]
1302:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1490              		.loc 1 1302 0
 1491 0050 3869     		ldr	r0, [r7, #16]
 1492 0052 3968     		ldr	r1, [r7]
 1493 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
1303:Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1494              		.loc 1 1303 0
 1495 0058 3B69     		ldr	r3, [r7, #16]
 1496 005a BA68     		ldr	r2, [r7, #8]
 1497 005c DA60     		str	r2, [r3, #12]
1304:Source/queue.c **** 
1305:Source/queue.c **** 			xReturn = pdPASS;
 1498              		.loc 1 1305 0
 1499 005e 0123     		movs	r3, #1
 1500 0060 7B61     		str	r3, [r7, #20]
 1501 0062 01E0     		b	.L132
 1502              	.L131:
1306:Source/queue.c **** 		}
1307:Source/queue.c **** 		else
1308:Source/queue.c **** 		{
1309:Source/queue.c **** 			xReturn = pdFAIL;
 1503              		.loc 1 1309 0
 1504 0064 0023     		movs	r3, #0
 1505 0066 7B61     		str	r3, [r7, #20]
 1506              	.L132:
1310:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1311:Source/queue.c **** 		}
1312:Source/queue.c **** 	}
1313:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1507              		.loc 1 1313 0
 1508 0068 F868     		ldr	r0, [r7, #12]
 1509 006a FFF7FEFF 		bl	vPortClearInterruptMask
1314:Source/queue.c **** 
1315:Source/queue.c **** 	return xReturn;
 1510              		.loc 1 1315 0
 1511 006e 7B69     		ldr	r3, [r7, #20]
1316:Source/queue.c **** }
 1512              		.loc 1 1316 0
 1513 0070 1846     		mov	r0, r3
 1514 0072 1837     		adds	r7, r7, #24
 1515 0074 BD46     		mov	sp, r7
 1516              		@ sp needed
 1517 0076 80BD     		pop	{r7, pc}
 1518              		.cfi_endproc
 1519              	.LFE120:
 1521              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1522              		.align	2
 1523              		.global	uxQueueMessagesWaiting
 1524              		.thumb
 1525              		.thumb_func
 1527              	uxQueueMessagesWaiting:
 1528              	.LFB121:
1317:Source/queue.c **** /*-----------------------------------------------------------*/
1318:Source/queue.c **** 
1319:Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
1320:Source/queue.c **** {
 1529              		.loc 1 1320 0
 1530              		.cfi_startproc
 1531              		@ args = 0, pretend = 0, frame = 16
 1532              		@ frame_needed = 1, uses_anonymous_args = 0
 1533 0000 80B5     		push	{r7, lr}
 1534              	.LCFI33:
 1535              		.cfi_def_cfa_offset 8
 1536              		.cfi_offset 7, -8
 1537              		.cfi_offset 14, -4
 1538 0002 84B0     		sub	sp, sp, #16
 1539              	.LCFI34:
 1540              		.cfi_def_cfa_offset 24
 1541 0004 00AF     		add	r7, sp, #0
 1542              	.LCFI35:
 1543              		.cfi_def_cfa_register 7
 1544 0006 7860     		str	r0, [r7, #4]
1321:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1322:Source/queue.c **** 
1323:Source/queue.c **** 	configASSERT( xQueue );
 1545              		.loc 1 1323 0
 1546 0008 7B68     		ldr	r3, [r7, #4]
 1547 000a 002B     		cmp	r3, #0
 1548 000c 02D1     		bne	.L135
 1549              		.loc 1 1323 0 is_stmt 0 discriminator 1
 1550 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1551              	.L136:
 1552 0012 FEE7     		b	.L136
 1553              	.L135:
1324:Source/queue.c **** 
1325:Source/queue.c **** 	taskENTER_CRITICAL();
 1554              		.loc 1 1325 0 is_stmt 1
 1555 0014 FFF7FEFF 		bl	vPortEnterCritical
1326:Source/queue.c **** 		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1556              		.loc 1 1326 0
 1557 0018 7B68     		ldr	r3, [r7, #4]
 1558 001a 9B6B     		ldr	r3, [r3, #56]
 1559 001c FB60     		str	r3, [r7, #12]
1327:Source/queue.c **** 	taskEXIT_CRITICAL();
 1560              		.loc 1 1327 0
 1561 001e FFF7FEFF 		bl	vPortExitCritical
1328:Source/queue.c **** 
1329:Source/queue.c **** 	return uxReturn;
 1562              		.loc 1 1329 0
 1563 0022 FB68     		ldr	r3, [r7, #12]
1330:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1564              		.loc 1 1330 0
 1565 0024 1846     		mov	r0, r3
 1566 0026 1037     		adds	r7, r7, #16
 1567 0028 BD46     		mov	sp, r7
 1568              		@ sp needed
 1569 002a 80BD     		pop	{r7, pc}
 1570              		.cfi_endproc
 1571              	.LFE121:
 1573              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1574              		.align	2
 1575              		.global	uxQueueSpacesAvailable
 1576              		.thumb
 1577              		.thumb_func
 1579              	uxQueueSpacesAvailable:
 1580              	.LFB122:
1331:Source/queue.c **** /*-----------------------------------------------------------*/
1332:Source/queue.c **** 
1333:Source/queue.c **** unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
1334:Source/queue.c **** {
 1581              		.loc 1 1334 0
 1582              		.cfi_startproc
 1583              		@ args = 0, pretend = 0, frame = 16
 1584              		@ frame_needed = 1, uses_anonymous_args = 0
 1585 0000 80B5     		push	{r7, lr}
 1586              	.LCFI36:
 1587              		.cfi_def_cfa_offset 8
 1588              		.cfi_offset 7, -8
 1589              		.cfi_offset 14, -4
 1590 0002 84B0     		sub	sp, sp, #16
 1591              	.LCFI37:
 1592              		.cfi_def_cfa_offset 24
 1593 0004 00AF     		add	r7, sp, #0
 1594              	.LCFI38:
 1595              		.cfi_def_cfa_register 7
 1596 0006 7860     		str	r0, [r7, #4]
1335:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1336:Source/queue.c **** xQUEUE *pxQueue;
1337:Source/queue.c **** 
1338:Source/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 1597              		.loc 1 1338 0
 1598 0008 7B68     		ldr	r3, [r7, #4]
 1599 000a FB60     		str	r3, [r7, #12]
1339:Source/queue.c **** 	configASSERT( pxQueue );
 1600              		.loc 1 1339 0
 1601 000c FB68     		ldr	r3, [r7, #12]
 1602 000e 002B     		cmp	r3, #0
 1603 0010 02D1     		bne	.L139
 1604              		.loc 1 1339 0 is_stmt 0 discriminator 1
 1605 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1606              	.L140:
 1607 0016 FEE7     		b	.L140
 1608              	.L139:
1340:Source/queue.c **** 
1341:Source/queue.c **** 	taskENTER_CRITICAL();
 1609              		.loc 1 1341 0 is_stmt 1
 1610 0018 FFF7FEFF 		bl	vPortEnterCritical
1342:Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1611              		.loc 1 1342 0
 1612 001c FB68     		ldr	r3, [r7, #12]
 1613 001e DA6B     		ldr	r2, [r3, #60]
 1614 0020 FB68     		ldr	r3, [r7, #12]
 1615 0022 9B6B     		ldr	r3, [r3, #56]
 1616 0024 D31A     		subs	r3, r2, r3
 1617 0026 BB60     		str	r3, [r7, #8]
1343:Source/queue.c **** 	taskEXIT_CRITICAL();
 1618              		.loc 1 1343 0
 1619 0028 FFF7FEFF 		bl	vPortExitCritical
1344:Source/queue.c **** 
1345:Source/queue.c **** 	return uxReturn;
 1620              		.loc 1 1345 0
 1621 002c BB68     		ldr	r3, [r7, #8]
1346:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1622              		.loc 1 1346 0
 1623 002e 1846     		mov	r0, r3
 1624 0030 1037     		adds	r7, r7, #16
 1625 0032 BD46     		mov	sp, r7
 1626              		@ sp needed
 1627 0034 80BD     		pop	{r7, pc}
 1628              		.cfi_endproc
 1629              	.LFE122:
 1631 0036 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1632              		.align	2
 1633              		.global	uxQueueMessagesWaitingFromISR
 1634              		.thumb
 1635              		.thumb_func
 1637              	uxQueueMessagesWaitingFromISR:
 1638              	.LFB123:
1347:Source/queue.c **** /*-----------------------------------------------------------*/
1348:Source/queue.c **** 
1349:Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
1350:Source/queue.c **** {
 1639              		.loc 1 1350 0
 1640              		.cfi_startproc
 1641              		@ args = 0, pretend = 0, frame = 16
 1642              		@ frame_needed = 1, uses_anonymous_args = 0
 1643 0000 80B5     		push	{r7, lr}
 1644              	.LCFI39:
 1645              		.cfi_def_cfa_offset 8
 1646              		.cfi_offset 7, -8
 1647              		.cfi_offset 14, -4
 1648 0002 84B0     		sub	sp, sp, #16
 1649              	.LCFI40:
 1650              		.cfi_def_cfa_offset 24
 1651 0004 00AF     		add	r7, sp, #0
 1652              	.LCFI41:
 1653              		.cfi_def_cfa_register 7
 1654 0006 7860     		str	r0, [r7, #4]
1351:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1352:Source/queue.c **** 
1353:Source/queue.c **** 	configASSERT( xQueue );
 1655              		.loc 1 1353 0
 1656 0008 7B68     		ldr	r3, [r7, #4]
 1657 000a 002B     		cmp	r3, #0
 1658 000c 02D1     		bne	.L143
 1659              		.loc 1 1353 0 is_stmt 0 discriminator 1
 1660 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1661              	.L144:
 1662 0012 FEE7     		b	.L144
 1663              	.L143:
1354:Source/queue.c **** 
1355:Source/queue.c **** 	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1664              		.loc 1 1355 0 is_stmt 1
 1665 0014 7B68     		ldr	r3, [r7, #4]
 1666 0016 9B6B     		ldr	r3, [r3, #56]
 1667 0018 FB60     		str	r3, [r7, #12]
1356:Source/queue.c **** 
1357:Source/queue.c **** 	return uxReturn;
 1668              		.loc 1 1357 0
 1669 001a FB68     		ldr	r3, [r7, #12]
1358:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1670              		.loc 1 1358 0
 1671 001c 1846     		mov	r0, r3
 1672 001e 1037     		adds	r7, r7, #16
 1673 0020 BD46     		mov	sp, r7
 1674              		@ sp needed
 1675 0022 80BD     		pop	{r7, pc}
 1676              		.cfi_endproc
 1677              	.LFE123:
 1679              		.section	.text.vQueueDelete,"ax",%progbits
 1680              		.align	2
 1681              		.global	vQueueDelete
 1682              		.thumb
 1683              		.thumb_func
 1685              	vQueueDelete:
 1686              	.LFB124:
1359:Source/queue.c **** /*-----------------------------------------------------------*/
1360:Source/queue.c **** 
1361:Source/queue.c **** void vQueueDelete( xQueueHandle xQueue )
1362:Source/queue.c **** {
 1687              		.loc 1 1362 0
 1688              		.cfi_startproc
 1689              		@ args = 0, pretend = 0, frame = 16
 1690              		@ frame_needed = 1, uses_anonymous_args = 0
 1691 0000 80B5     		push	{r7, lr}
 1692              	.LCFI42:
 1693              		.cfi_def_cfa_offset 8
 1694              		.cfi_offset 7, -8
 1695              		.cfi_offset 14, -4
 1696 0002 84B0     		sub	sp, sp, #16
 1697              	.LCFI43:
 1698              		.cfi_def_cfa_offset 24
 1699 0004 00AF     		add	r7, sp, #0
 1700              	.LCFI44:
 1701              		.cfi_def_cfa_register 7
 1702 0006 7860     		str	r0, [r7, #4]
1363:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1703              		.loc 1 1363 0
 1704 0008 7B68     		ldr	r3, [r7, #4]
 1705 000a FB60     		str	r3, [r7, #12]
1364:Source/queue.c **** 
1365:Source/queue.c **** 	configASSERT( pxQueue );
 1706              		.loc 1 1365 0
 1707 000c FB68     		ldr	r3, [r7, #12]
 1708 000e 002B     		cmp	r3, #0
 1709 0010 02D1     		bne	.L147
 1710              		.loc 1 1365 0 is_stmt 0 discriminator 1
 1711 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1712              	.L148:
 1713 0016 FEE7     		b	.L148
 1714              	.L147:
1366:Source/queue.c **** 
1367:Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1368:Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1369:Source/queue.c **** 	{
1370:Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1715              		.loc 1 1370 0 is_stmt 1
 1716 0018 F868     		ldr	r0, [r7, #12]
 1717 001a FFF7FEFF 		bl	vQueueUnregisterQueue
1371:Source/queue.c **** 	}
1372:Source/queue.c **** 	#endif
1373:Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1718              		.loc 1 1373 0
 1719 001e FB68     		ldr	r3, [r7, #12]
 1720 0020 1B68     		ldr	r3, [r3]
 1721 0022 1846     		mov	r0, r3
 1722 0024 FFF7FEFF 		bl	vPortFree
1374:Source/queue.c **** 	vPortFree( pxQueue );
 1723              		.loc 1 1374 0
 1724 0028 F868     		ldr	r0, [r7, #12]
 1725 002a FFF7FEFF 		bl	vPortFree
1375:Source/queue.c **** }
 1726              		.loc 1 1375 0
 1727 002e 1037     		adds	r7, r7, #16
 1728 0030 BD46     		mov	sp, r7
 1729              		@ sp needed
 1730 0032 80BD     		pop	{r7, pc}
 1731              		.cfi_endproc
 1732              	.LFE124:
 1734              		.section	.text.ucQueueGetQueueNumber,"ax",%progbits
 1735              		.align	2
 1736              		.global	ucQueueGetQueueNumber
 1737              		.thumb
 1738              		.thumb_func
 1740              	ucQueueGetQueueNumber:
 1741              	.LFB125:
1376:Source/queue.c **** /*-----------------------------------------------------------*/
1377:Source/queue.c **** 
1378:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1379:Source/queue.c **** 
1380:Source/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
1381:Source/queue.c **** 	{
 1742              		.loc 1 1381 0
 1743              		.cfi_startproc
 1744              		@ args = 0, pretend = 0, frame = 8
 1745              		@ frame_needed = 1, uses_anonymous_args = 0
 1746              		@ link register save eliminated.
 1747 0000 80B4     		push	{r7}
 1748              	.LCFI45:
 1749              		.cfi_def_cfa_offset 4
 1750              		.cfi_offset 7, -4
 1751 0002 83B0     		sub	sp, sp, #12
 1752              	.LCFI46:
 1753              		.cfi_def_cfa_offset 16
 1754 0004 00AF     		add	r7, sp, #0
 1755              	.LCFI47:
 1756              		.cfi_def_cfa_register 7
 1757 0006 7860     		str	r0, [r7, #4]
1382:Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
 1758              		.loc 1 1382 0
 1759 0008 7B68     		ldr	r3, [r7, #4]
 1760 000a 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1383:Source/queue.c **** 	}
 1761              		.loc 1 1383 0
 1762 000e 1846     		mov	r0, r3
 1763 0010 0C37     		adds	r7, r7, #12
 1764 0012 BD46     		mov	sp, r7
 1765              		@ sp needed
 1766 0014 5DF8047B 		ldr	r7, [sp], #4
 1767 0018 7047     		bx	lr
 1768              		.cfi_endproc
 1769              	.LFE125:
 1771 001a 00BF     		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 1772              		.align	2
 1773              		.global	vQueueSetQueueNumber
 1774              		.thumb
 1775              		.thumb_func
 1777              	vQueueSetQueueNumber:
 1778              	.LFB126:
1384:Source/queue.c **** 
1385:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1386:Source/queue.c **** /*-----------------------------------------------------------*/
1387:Source/queue.c **** 
1388:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1389:Source/queue.c **** 
1390:Source/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
1391:Source/queue.c **** 	{
 1779              		.loc 1 1391 0
 1780              		.cfi_startproc
 1781              		@ args = 0, pretend = 0, frame = 8
 1782              		@ frame_needed = 1, uses_anonymous_args = 0
 1783              		@ link register save eliminated.
 1784 0000 80B4     		push	{r7}
 1785              	.LCFI48:
 1786              		.cfi_def_cfa_offset 4
 1787              		.cfi_offset 7, -4
 1788 0002 83B0     		sub	sp, sp, #12
 1789              	.LCFI49:
 1790              		.cfi_def_cfa_offset 16
 1791 0004 00AF     		add	r7, sp, #0
 1792              	.LCFI50:
 1793              		.cfi_def_cfa_register 7
 1794 0006 7860     		str	r0, [r7, #4]
 1795 0008 0B46     		mov	r3, r1
 1796 000a FB70     		strb	r3, [r7, #3]
1392:Source/queue.c **** 		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
 1797              		.loc 1 1392 0
 1798 000c 7B68     		ldr	r3, [r7, #4]
 1799 000e FA78     		ldrb	r2, [r7, #3]
 1800 0010 83F84C20 		strb	r2, [r3, #76]
1393:Source/queue.c **** 	}
 1801              		.loc 1 1393 0
 1802 0014 0C37     		adds	r7, r7, #12
 1803 0016 BD46     		mov	sp, r7
 1804              		@ sp needed
 1805 0018 5DF8047B 		ldr	r7, [sp], #4
 1806 001c 7047     		bx	lr
 1807              		.cfi_endproc
 1808              	.LFE126:
 1810 001e 00BF     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 1811              		.align	2
 1812              		.global	ucQueueGetQueueType
 1813              		.thumb
 1814              		.thumb_func
 1816              	ucQueueGetQueueType:
 1817              	.LFB127:
1394:Source/queue.c **** 
1395:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1396:Source/queue.c **** /*-----------------------------------------------------------*/
1397:Source/queue.c **** 
1398:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1399:Source/queue.c **** 
1400:Source/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
1401:Source/queue.c **** 	{
 1818              		.loc 1 1401 0
 1819              		.cfi_startproc
 1820              		@ args = 0, pretend = 0, frame = 8
 1821              		@ frame_needed = 1, uses_anonymous_args = 0
 1822              		@ link register save eliminated.
 1823 0000 80B4     		push	{r7}
 1824              	.LCFI51:
 1825              		.cfi_def_cfa_offset 4
 1826              		.cfi_offset 7, -4
 1827 0002 83B0     		sub	sp, sp, #12
 1828              	.LCFI52:
 1829              		.cfi_def_cfa_offset 16
 1830 0004 00AF     		add	r7, sp, #0
 1831              	.LCFI53:
 1832              		.cfi_def_cfa_register 7
 1833 0006 7860     		str	r0, [r7, #4]
1402:Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueType;
 1834              		.loc 1 1402 0
 1835 0008 7B68     		ldr	r3, [r7, #4]
 1836 000a 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1403:Source/queue.c **** 	}
 1837              		.loc 1 1403 0
 1838 000e 1846     		mov	r0, r3
 1839 0010 0C37     		adds	r7, r7, #12
 1840 0012 BD46     		mov	sp, r7
 1841              		@ sp needed
 1842 0014 5DF8047B 		ldr	r7, [sp], #4
 1843 0018 7047     		bx	lr
 1844              		.cfi_endproc
 1845              	.LFE127:
 1847 001a 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1848              		.align	2
 1849              		.thumb
 1850              		.thumb_func
 1852              	prvCopyDataToQueue:
 1853              	.LFB128:
1404:Source/queue.c **** 
1405:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1406:Source/queue.c **** /*-----------------------------------------------------------*/
1407:Source/queue.c **** 
1408:Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1409:Source/queue.c **** {
 1854              		.loc 1 1409 0
 1855              		.cfi_startproc
 1856              		@ args = 0, pretend = 0, frame = 16
 1857              		@ frame_needed = 1, uses_anonymous_args = 0
 1858 0000 80B5     		push	{r7, lr}
 1859              	.LCFI54:
 1860              		.cfi_def_cfa_offset 8
 1861              		.cfi_offset 7, -8
 1862              		.cfi_offset 14, -4
 1863 0002 84B0     		sub	sp, sp, #16
 1864              	.LCFI55:
 1865              		.cfi_def_cfa_offset 24
 1866 0004 00AF     		add	r7, sp, #0
 1867              	.LCFI56:
 1868              		.cfi_def_cfa_register 7
 1869 0006 F860     		str	r0, [r7, #12]
 1870 0008 B960     		str	r1, [r7, #8]
 1871 000a 7A60     		str	r2, [r7, #4]
1410:Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1872              		.loc 1 1410 0
 1873 000c FB68     		ldr	r3, [r7, #12]
 1874 000e 1B6C     		ldr	r3, [r3, #64]
 1875 0010 002B     		cmp	r3, #0
 1876 0012 0CD1     		bne	.L155
1411:Source/queue.c **** 	{
1412:Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1413:Source/queue.c **** 		{
1414:Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1877              		.loc 1 1414 0
 1878 0014 FB68     		ldr	r3, [r7, #12]
 1879 0016 1B68     		ldr	r3, [r3]
 1880 0018 002B     		cmp	r3, #0
 1881 001a 51D1     		bne	.L157
1415:Source/queue.c **** 			{
1416:Source/queue.c **** 				/* The mutex is no longer being held. */
1417:Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1882              		.loc 1 1417 0
 1883 001c FB68     		ldr	r3, [r7, #12]
 1884 001e 5B68     		ldr	r3, [r3, #4]
 1885 0020 1846     		mov	r0, r3
 1886 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1418:Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1887              		.loc 1 1418 0
 1888 0026 FB68     		ldr	r3, [r7, #12]
 1889 0028 0022     		movs	r2, #0
 1890 002a 5A60     		str	r2, [r3, #4]
 1891 002c 48E0     		b	.L157
 1892              	.L155:
1419:Source/queue.c **** 			}
1420:Source/queue.c **** 		}
1421:Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1422:Source/queue.c **** 	}
1423:Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1893              		.loc 1 1423 0
 1894 002e 7B68     		ldr	r3, [r7, #4]
 1895 0030 002B     		cmp	r3, #0
 1896 0032 1AD1     		bne	.L158
1424:Source/queue.c **** 	{
1425:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1897              		.loc 1 1425 0
 1898 0034 FB68     		ldr	r3, [r7, #12]
 1899 0036 9A68     		ldr	r2, [r3, #8]
 1900 0038 FB68     		ldr	r3, [r7, #12]
 1901 003a 1B6C     		ldr	r3, [r3, #64]
 1902 003c 1046     		mov	r0, r2
 1903 003e B968     		ldr	r1, [r7, #8]
 1904 0040 1A46     		mov	r2, r3
 1905 0042 FFF7FEFF 		bl	memcpy
1426:Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1906              		.loc 1 1426 0
 1907 0046 FB68     		ldr	r3, [r7, #12]
 1908 0048 9A68     		ldr	r2, [r3, #8]
 1909 004a FB68     		ldr	r3, [r7, #12]
 1910 004c 1B6C     		ldr	r3, [r3, #64]
 1911 004e 1A44     		add	r2, r2, r3
 1912 0050 FB68     		ldr	r3, [r7, #12]
 1913 0052 9A60     		str	r2, [r3, #8]
1427:Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1914              		.loc 1 1427 0
 1915 0054 FB68     		ldr	r3, [r7, #12]
 1916 0056 9A68     		ldr	r2, [r3, #8]
 1917 0058 FB68     		ldr	r3, [r7, #12]
 1918 005a 5B68     		ldr	r3, [r3, #4]
 1919 005c 9A42     		cmp	r2, r3
 1920 005e 2FD3     		bcc	.L157
1428:Source/queue.c **** 		{
1429:Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1921              		.loc 1 1429 0
 1922 0060 FB68     		ldr	r3, [r7, #12]
 1923 0062 1A68     		ldr	r2, [r3]
 1924 0064 FB68     		ldr	r3, [r7, #12]
 1925 0066 9A60     		str	r2, [r3, #8]
 1926 0068 2AE0     		b	.L157
 1927              	.L158:
1430:Source/queue.c **** 		}
1431:Source/queue.c **** 	}
1432:Source/queue.c **** 	else
1433:Source/queue.c **** 	{
1434:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 1928              		.loc 1 1434 0
 1929 006a FB68     		ldr	r3, [r7, #12]
 1930 006c DA68     		ldr	r2, [r3, #12]
 1931 006e FB68     		ldr	r3, [r7, #12]
 1932 0070 1B6C     		ldr	r3, [r3, #64]
 1933 0072 1046     		mov	r0, r2
 1934 0074 B968     		ldr	r1, [r7, #8]
 1935 0076 1A46     		mov	r2, r3
 1936 0078 FFF7FEFF 		bl	memcpy
1435:Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1937              		.loc 1 1435 0
 1938 007c FB68     		ldr	r3, [r7, #12]
 1939 007e DA68     		ldr	r2, [r3, #12]
 1940 0080 FB68     		ldr	r3, [r7, #12]
 1941 0082 1B6C     		ldr	r3, [r3, #64]
 1942 0084 5B42     		negs	r3, r3
 1943 0086 1A44     		add	r2, r2, r3
 1944 0088 FB68     		ldr	r3, [r7, #12]
 1945 008a DA60     		str	r2, [r3, #12]
1436:Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1946              		.loc 1 1436 0
 1947 008c FB68     		ldr	r3, [r7, #12]
 1948 008e DA68     		ldr	r2, [r3, #12]
 1949 0090 FB68     		ldr	r3, [r7, #12]
 1950 0092 1B68     		ldr	r3, [r3]
 1951 0094 9A42     		cmp	r2, r3
 1952 0096 07D2     		bcs	.L160
1437:Source/queue.c **** 		{
1438:Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1953              		.loc 1 1438 0
 1954 0098 FB68     		ldr	r3, [r7, #12]
 1955 009a 5A68     		ldr	r2, [r3, #4]
 1956 009c FB68     		ldr	r3, [r7, #12]
 1957 009e 1B6C     		ldr	r3, [r3, #64]
 1958 00a0 5B42     		negs	r3, r3
 1959 00a2 1A44     		add	r2, r2, r3
 1960 00a4 FB68     		ldr	r3, [r7, #12]
 1961 00a6 DA60     		str	r2, [r3, #12]
 1962              	.L160:
1439:Source/queue.c **** 		}
1440:Source/queue.c **** 
1441:Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 1963              		.loc 1 1441 0
 1964 00a8 7B68     		ldr	r3, [r7, #4]
 1965 00aa 022B     		cmp	r3, #2
 1966 00ac 08D1     		bne	.L157
1442:Source/queue.c **** 		{
1443:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1967              		.loc 1 1443 0
 1968 00ae FB68     		ldr	r3, [r7, #12]
 1969 00b0 9B6B     		ldr	r3, [r3, #56]
 1970 00b2 002B     		cmp	r3, #0
 1971 00b4 04D0     		beq	.L157
1444:Source/queue.c **** 			{
1445:Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1446:Source/queue.c **** 				one from the recorded number of items in the queue so when
1447:Source/queue.c **** 				one is added again below the number of recorded items remains
1448:Source/queue.c **** 				correct. */
1449:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 1972              		.loc 1 1449 0
 1973 00b6 FB68     		ldr	r3, [r7, #12]
 1974 00b8 9B6B     		ldr	r3, [r3, #56]
 1975 00ba 5A1E     		subs	r2, r3, #1
 1976 00bc FB68     		ldr	r3, [r7, #12]
 1977 00be 9A63     		str	r2, [r3, #56]
 1978              	.L157:
1450:Source/queue.c **** 			}
1451:Source/queue.c **** 		}
1452:Source/queue.c **** 	}
1453:Source/queue.c **** 
1454:Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1979              		.loc 1 1454 0
 1980 00c0 FB68     		ldr	r3, [r7, #12]
 1981 00c2 9B6B     		ldr	r3, [r3, #56]
 1982 00c4 5A1C     		adds	r2, r3, #1
 1983 00c6 FB68     		ldr	r3, [r7, #12]
 1984 00c8 9A63     		str	r2, [r3, #56]
1455:Source/queue.c **** }
 1985              		.loc 1 1455 0
 1986 00ca 1037     		adds	r7, r7, #16
 1987 00cc BD46     		mov	sp, r7
 1988              		@ sp needed
 1989 00ce 80BD     		pop	{r7, pc}
 1990              		.cfi_endproc
 1991              	.LFE128:
 1993              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1994              		.align	2
 1995              		.thumb
 1996              		.thumb_func
 1998              	prvCopyDataFromQueue:
 1999              	.LFB129:
1456:Source/queue.c **** /*-----------------------------------------------------------*/
1457:Source/queue.c **** 
1458:Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
1459:Source/queue.c **** {
 2000              		.loc 1 1459 0
 2001              		.cfi_startproc
 2002              		@ args = 0, pretend = 0, frame = 8
 2003              		@ frame_needed = 1, uses_anonymous_args = 0
 2004 0000 80B5     		push	{r7, lr}
 2005              	.LCFI57:
 2006              		.cfi_def_cfa_offset 8
 2007              		.cfi_offset 7, -8
 2008              		.cfi_offset 14, -4
 2009 0002 82B0     		sub	sp, sp, #8
 2010              	.LCFI58:
 2011              		.cfi_def_cfa_offset 16
 2012 0004 00AF     		add	r7, sp, #0
 2013              	.LCFI59:
 2014              		.cfi_def_cfa_register 7
 2015 0006 7860     		str	r0, [r7, #4]
 2016 0008 3960     		str	r1, [r7]
1460:Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 2017              		.loc 1 1460 0
 2018 000a 7B68     		ldr	r3, [r7, #4]
 2019 000c 1B68     		ldr	r3, [r3]
 2020 000e 002B     		cmp	r3, #0
 2021 0010 19D0     		beq	.L161
1461:Source/queue.c **** 	{
1462:Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2022              		.loc 1 1462 0
 2023 0012 7B68     		ldr	r3, [r7, #4]
 2024 0014 DA68     		ldr	r2, [r3, #12]
 2025 0016 7B68     		ldr	r3, [r7, #4]
 2026 0018 1B6C     		ldr	r3, [r3, #64]
 2027 001a 1A44     		add	r2, r2, r3
 2028 001c 7B68     		ldr	r3, [r7, #4]
 2029 001e DA60     		str	r2, [r3, #12]
1463:Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2030              		.loc 1 1463 0
 2031 0020 7B68     		ldr	r3, [r7, #4]
 2032 0022 DA68     		ldr	r2, [r3, #12]
 2033 0024 7B68     		ldr	r3, [r7, #4]
 2034 0026 5B68     		ldr	r3, [r3, #4]
 2035 0028 9A42     		cmp	r2, r3
 2036 002a 03D3     		bcc	.L163
1464:Source/queue.c **** 		{
1465:Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2037              		.loc 1 1465 0
 2038 002c 7B68     		ldr	r3, [r7, #4]
 2039 002e 1A68     		ldr	r2, [r3]
 2040 0030 7B68     		ldr	r3, [r7, #4]
 2041 0032 DA60     		str	r2, [r3, #12]
 2042              	.L163:
1466:Source/queue.c **** 		}
1467:Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2043              		.loc 1 1467 0
 2044 0034 7B68     		ldr	r3, [r7, #4]
 2045 0036 DA68     		ldr	r2, [r3, #12]
 2046 0038 7B68     		ldr	r3, [r7, #4]
 2047 003a 1B6C     		ldr	r3, [r3, #64]
 2048 003c 3868     		ldr	r0, [r7]
 2049 003e 1146     		mov	r1, r2
 2050 0040 1A46     		mov	r2, r3
 2051 0042 FFF7FEFF 		bl	memcpy
 2052              	.L161:
1468:Source/queue.c **** 	}
1469:Source/queue.c **** }
 2053              		.loc 1 1469 0
 2054 0046 0837     		adds	r7, r7, #8
 2055 0048 BD46     		mov	sp, r7
 2056              		@ sp needed
 2057 004a 80BD     		pop	{r7, pc}
 2058              		.cfi_endproc
 2059              	.LFE129:
 2061              		.section	.text.prvUnlockQueue,"ax",%progbits
 2062              		.align	2
 2063              		.thumb
 2064              		.thumb_func
 2066              	prvUnlockQueue:
 2067              	.LFB130:
1470:Source/queue.c **** /*-----------------------------------------------------------*/
1471:Source/queue.c **** 
1472:Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue )
1473:Source/queue.c **** {
 2068              		.loc 1 1473 0
 2069              		.cfi_startproc
 2070              		@ args = 0, pretend = 0, frame = 8
 2071              		@ frame_needed = 1, uses_anonymous_args = 0
 2072 0000 80B5     		push	{r7, lr}
 2073              	.LCFI60:
 2074              		.cfi_def_cfa_offset 8
 2075              		.cfi_offset 7, -8
 2076              		.cfi_offset 14, -4
 2077 0002 82B0     		sub	sp, sp, #8
 2078              	.LCFI61:
 2079              		.cfi_def_cfa_offset 16
 2080 0004 00AF     		add	r7, sp, #0
 2081              	.LCFI62:
 2082              		.cfi_def_cfa_register 7
 2083 0006 7860     		str	r0, [r7, #4]
1474:Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1475:Source/queue.c **** 
1476:Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1477:Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1478:Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1479:Source/queue.c **** 	updated. */
1480:Source/queue.c **** 	taskENTER_CRITICAL();
 2084              		.loc 1 1480 0
 2085 0008 FFF7FEFF 		bl	vPortEnterCritical
1481:Source/queue.c **** 	{
1482:Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1483:Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2086              		.loc 1 1483 0
 2087 000c 14E0     		b	.L165
 2088              	.L170:
1484:Source/queue.c **** 		{
1485:Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1486:Source/queue.c **** 			blocked waiting for data to become available? */
1487:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1488:Source/queue.c **** 			{
1489:Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1490:Source/queue.c **** 				{
1491:Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1492:Source/queue.c **** 					{
1493:Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1494:Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1495:Source/queue.c **** 						A context switch is required. */
1496:Source/queue.c **** 						vTaskMissedYield();
1497:Source/queue.c **** 					}
1498:Source/queue.c **** 				}
1499:Source/queue.c **** 				else
1500:Source/queue.c **** 				{
1501:Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1502:Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1503:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1504:Source/queue.c **** 					{
1505:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1506:Source/queue.c **** 						{
1507:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1508:Source/queue.c **** 							context	switch is required. */
1509:Source/queue.c **** 							vTaskMissedYield();
1510:Source/queue.c **** 						}
1511:Source/queue.c **** 					}
1512:Source/queue.c **** 					else
1513:Source/queue.c **** 					{
1514:Source/queue.c **** 						break;
1515:Source/queue.c **** 					}
1516:Source/queue.c **** 				}
1517:Source/queue.c **** 			}
1518:Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1519:Source/queue.c **** 			{
1520:Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1521:Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1522:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2089              		.loc 1 1522 0
 2090 000e 7B68     		ldr	r3, [r7, #4]
 2091 0010 5B6A     		ldr	r3, [r3, #36]
 2092 0012 002B     		cmp	r3, #0
 2093 0014 0AD0     		beq	.L166
1523:Source/queue.c **** 				{
1524:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2094              		.loc 1 1524 0
 2095 0016 7B68     		ldr	r3, [r7, #4]
 2096 0018 2433     		adds	r3, r3, #36
 2097 001a 1846     		mov	r0, r3
 2098 001c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2099 0020 0346     		mov	r3, r0
 2100 0022 002B     		cmp	r3, #0
 2101 0024 03D0     		beq	.L168
1525:Source/queue.c **** 					{
1526:Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1527:Source/queue.c **** 						context	switch is required. */
1528:Source/queue.c **** 						vTaskMissedYield();
 2102              		.loc 1 1528 0
 2103 0026 FFF7FEFF 		bl	vTaskMissedYield
 2104 002a 00E0     		b	.L168
 2105              	.L166:
1529:Source/queue.c **** 					}
1530:Source/queue.c **** 				}
1531:Source/queue.c **** 				else
1532:Source/queue.c **** 				{
1533:Source/queue.c **** 					break;
 2106              		.loc 1 1533 0
 2107 002c 08E0     		b	.L169
 2108              	.L168:
1534:Source/queue.c **** 				}
1535:Source/queue.c **** 			}
1536:Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1537:Source/queue.c **** 
1538:Source/queue.c **** 			--( pxQueue->xTxLock );
 2109              		.loc 1 1538 0
 2110 002e 7B68     		ldr	r3, [r7, #4]
 2111 0030 9B6C     		ldr	r3, [r3, #72]
 2112 0032 5A1E     		subs	r2, r3, #1
 2113 0034 7B68     		ldr	r3, [r7, #4]
 2114 0036 9A64     		str	r2, [r3, #72]
 2115              	.L165:
1483:Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2116              		.loc 1 1483 0 discriminator 1
 2117 0038 7B68     		ldr	r3, [r7, #4]
 2118 003a 9B6C     		ldr	r3, [r3, #72]
 2119 003c 002B     		cmp	r3, #0
 2120 003e E6DC     		bgt	.L170
 2121              	.L169:
1539:Source/queue.c **** 		}
1540:Source/queue.c **** 
1541:Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 2122              		.loc 1 1541 0
 2123 0040 7B68     		ldr	r3, [r7, #4]
 2124 0042 4FF0FF32 		mov	r2, #-1
 2125 0046 9A64     		str	r2, [r3, #72]
1542:Source/queue.c **** 	}
1543:Source/queue.c **** 	taskEXIT_CRITICAL();
 2126              		.loc 1 1543 0
 2127 0048 FFF7FEFF 		bl	vPortExitCritical
1544:Source/queue.c **** 
1545:Source/queue.c **** 	/* Do the same for the Rx lock. */
1546:Source/queue.c **** 	taskENTER_CRITICAL();
 2128              		.loc 1 1546 0
 2129 004c FFF7FEFF 		bl	vPortEnterCritical
1547:Source/queue.c **** 	{
1548:Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2130              		.loc 1 1548 0
 2131 0050 14E0     		b	.L171
 2132              	.L175:
1549:Source/queue.c **** 		{
1550:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2133              		.loc 1 1550 0
 2134 0052 7B68     		ldr	r3, [r7, #4]
 2135 0054 1B69     		ldr	r3, [r3, #16]
 2136 0056 002B     		cmp	r3, #0
 2137 0058 0FD0     		beq	.L172
1551:Source/queue.c **** 			{
1552:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2138              		.loc 1 1552 0
 2139 005a 7B68     		ldr	r3, [r7, #4]
 2140 005c 1033     		adds	r3, r3, #16
 2141 005e 1846     		mov	r0, r3
 2142 0060 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2143 0064 0346     		mov	r3, r0
 2144 0066 002B     		cmp	r3, #0
 2145 0068 01D0     		beq	.L173
1553:Source/queue.c **** 				{
1554:Source/queue.c **** 					vTaskMissedYield();
 2146              		.loc 1 1554 0
 2147 006a FFF7FEFF 		bl	vTaskMissedYield
 2148              	.L173:
1555:Source/queue.c **** 				}
1556:Source/queue.c **** 
1557:Source/queue.c **** 				--( pxQueue->xRxLock );
 2149              		.loc 1 1557 0
 2150 006e 7B68     		ldr	r3, [r7, #4]
 2151 0070 5B6C     		ldr	r3, [r3, #68]
 2152 0072 5A1E     		subs	r2, r3, #1
 2153 0074 7B68     		ldr	r3, [r7, #4]
 2154 0076 5A64     		str	r2, [r3, #68]
 2155 0078 00E0     		b	.L171
 2156              	.L172:
1558:Source/queue.c **** 			}
1559:Source/queue.c **** 			else
1560:Source/queue.c **** 			{
1561:Source/queue.c **** 				break;
 2157              		.loc 1 1561 0
 2158 007a 03E0     		b	.L174
 2159              	.L171:
1548:Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2160              		.loc 1 1548 0 discriminator 1
 2161 007c 7B68     		ldr	r3, [r7, #4]
 2162 007e 5B6C     		ldr	r3, [r3, #68]
 2163 0080 002B     		cmp	r3, #0
 2164 0082 E6DC     		bgt	.L175
 2165              	.L174:
1562:Source/queue.c **** 			}
1563:Source/queue.c **** 		}
1564:Source/queue.c **** 
1565:Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 2166              		.loc 1 1565 0
 2167 0084 7B68     		ldr	r3, [r7, #4]
 2168 0086 4FF0FF32 		mov	r2, #-1
 2169 008a 5A64     		str	r2, [r3, #68]
1566:Source/queue.c **** 	}
1567:Source/queue.c **** 	taskEXIT_CRITICAL();
 2170              		.loc 1 1567 0
 2171 008c FFF7FEFF 		bl	vPortExitCritical
1568:Source/queue.c **** }
 2172              		.loc 1 1568 0
 2173 0090 0837     		adds	r7, r7, #8
 2174 0092 BD46     		mov	sp, r7
 2175              		@ sp needed
 2176 0094 80BD     		pop	{r7, pc}
 2177              		.cfi_endproc
 2178              	.LFE130:
 2180 0096 00BF     		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2181              		.align	2
 2182              		.thumb
 2183              		.thumb_func
 2185              	prvIsQueueEmpty:
 2186              	.LFB131:
1569:Source/queue.c **** /*-----------------------------------------------------------*/
1570:Source/queue.c **** 
1571:Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
1572:Source/queue.c **** {
 2187              		.loc 1 1572 0
 2188              		.cfi_startproc
 2189              		@ args = 0, pretend = 0, frame = 16
 2190              		@ frame_needed = 1, uses_anonymous_args = 0
 2191 0000 80B5     		push	{r7, lr}
 2192              	.LCFI63:
 2193              		.cfi_def_cfa_offset 8
 2194              		.cfi_offset 7, -8
 2195              		.cfi_offset 14, -4
 2196 0002 84B0     		sub	sp, sp, #16
 2197              	.LCFI64:
 2198              		.cfi_def_cfa_offset 24
 2199 0004 00AF     		add	r7, sp, #0
 2200              	.LCFI65:
 2201              		.cfi_def_cfa_register 7
 2202 0006 7860     		str	r0, [r7, #4]
1573:Source/queue.c **** signed portBASE_TYPE xReturn;
1574:Source/queue.c **** 
1575:Source/queue.c **** 	taskENTER_CRITICAL();
 2203              		.loc 1 1575 0
 2204 0008 FFF7FEFF 		bl	vPortEnterCritical
1576:Source/queue.c **** 	{
1577:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 2205              		.loc 1 1577 0
 2206 000c 7B68     		ldr	r3, [r7, #4]
 2207 000e 9B6B     		ldr	r3, [r3, #56]
 2208 0010 002B     		cmp	r3, #0
 2209 0012 02D1     		bne	.L177
1578:Source/queue.c **** 		{
1579:Source/queue.c **** 			xReturn = pdTRUE;
 2210              		.loc 1 1579 0
 2211 0014 0123     		movs	r3, #1
 2212 0016 FB60     		str	r3, [r7, #12]
 2213 0018 01E0     		b	.L178
 2214              	.L177:
1580:Source/queue.c **** 		}
1581:Source/queue.c **** 		else
1582:Source/queue.c **** 		{
1583:Source/queue.c **** 			xReturn = pdFALSE;
 2215              		.loc 1 1583 0
 2216 001a 0023     		movs	r3, #0
 2217 001c FB60     		str	r3, [r7, #12]
 2218              	.L178:
1584:Source/queue.c **** 		}
1585:Source/queue.c **** 	}
1586:Source/queue.c **** 	taskEXIT_CRITICAL();
 2219              		.loc 1 1586 0
 2220 001e FFF7FEFF 		bl	vPortExitCritical
1587:Source/queue.c **** 
1588:Source/queue.c **** 	return xReturn;
 2221              		.loc 1 1588 0
 2222 0022 FB68     		ldr	r3, [r7, #12]
1589:Source/queue.c **** }
 2223              		.loc 1 1589 0
 2224 0024 1846     		mov	r0, r3
 2225 0026 1037     		adds	r7, r7, #16
 2226 0028 BD46     		mov	sp, r7
 2227              		@ sp needed
 2228 002a 80BD     		pop	{r7, pc}
 2229              		.cfi_endproc
 2230              	.LFE131:
 2232              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2233              		.align	2
 2234              		.global	xQueueIsQueueEmptyFromISR
 2235              		.thumb
 2236              		.thumb_func
 2238              	xQueueIsQueueEmptyFromISR:
 2239              	.LFB132:
1590:Source/queue.c **** /*-----------------------------------------------------------*/
1591:Source/queue.c **** 
1592:Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
1593:Source/queue.c **** {
 2240              		.loc 1 1593 0
 2241              		.cfi_startproc
 2242              		@ args = 0, pretend = 0, frame = 16
 2243              		@ frame_needed = 1, uses_anonymous_args = 0
 2244 0000 80B5     		push	{r7, lr}
 2245              	.LCFI66:
 2246              		.cfi_def_cfa_offset 8
 2247              		.cfi_offset 7, -8
 2248              		.cfi_offset 14, -4
 2249 0002 84B0     		sub	sp, sp, #16
 2250              	.LCFI67:
 2251              		.cfi_def_cfa_offset 24
 2252 0004 00AF     		add	r7, sp, #0
 2253              	.LCFI68:
 2254              		.cfi_def_cfa_register 7
 2255 0006 7860     		str	r0, [r7, #4]
1594:Source/queue.c **** signed portBASE_TYPE xReturn;
1595:Source/queue.c **** 
1596:Source/queue.c **** 	configASSERT( xQueue );
 2256              		.loc 1 1596 0
 2257 0008 7B68     		ldr	r3, [r7, #4]
 2258 000a 002B     		cmp	r3, #0
 2259 000c 02D1     		bne	.L181
 2260              		.loc 1 1596 0 is_stmt 0 discriminator 1
 2261 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2262              	.L182:
 2263 0012 FEE7     		b	.L182
 2264              	.L181:
1597:Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 2265              		.loc 1 1597 0 is_stmt 1
 2266 0014 7B68     		ldr	r3, [r7, #4]
 2267 0016 9B6B     		ldr	r3, [r3, #56]
 2268 0018 002B     		cmp	r3, #0
 2269 001a 02D1     		bne	.L183
1598:Source/queue.c **** 	{
1599:Source/queue.c **** 		xReturn = pdTRUE;
 2270              		.loc 1 1599 0
 2271 001c 0123     		movs	r3, #1
 2272 001e FB60     		str	r3, [r7, #12]
 2273 0020 01E0     		b	.L184
 2274              	.L183:
1600:Source/queue.c **** 	}
1601:Source/queue.c **** 	else
1602:Source/queue.c **** 	{
1603:Source/queue.c **** 		xReturn = pdFALSE;
 2275              		.loc 1 1603 0
 2276 0022 0023     		movs	r3, #0
 2277 0024 FB60     		str	r3, [r7, #12]
 2278              	.L184:
1604:Source/queue.c **** 	}
1605:Source/queue.c **** 
1606:Source/queue.c **** 	return xReturn;
 2279              		.loc 1 1606 0
 2280 0026 FB68     		ldr	r3, [r7, #12]
1607:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2281              		.loc 1 1607 0
 2282 0028 1846     		mov	r0, r3
 2283 002a 1037     		adds	r7, r7, #16
 2284 002c BD46     		mov	sp, r7
 2285              		@ sp needed
 2286 002e 80BD     		pop	{r7, pc}
 2287              		.cfi_endproc
 2288              	.LFE132:
 2290              		.section	.text.prvIsQueueFull,"ax",%progbits
 2291              		.align	2
 2292              		.thumb
 2293              		.thumb_func
 2295              	prvIsQueueFull:
 2296              	.LFB133:
1608:Source/queue.c **** /*-----------------------------------------------------------*/
1609:Source/queue.c **** 
1610:Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
1611:Source/queue.c **** {
 2297              		.loc 1 1611 0
 2298              		.cfi_startproc
 2299              		@ args = 0, pretend = 0, frame = 16
 2300              		@ frame_needed = 1, uses_anonymous_args = 0
 2301 0000 80B5     		push	{r7, lr}
 2302              	.LCFI69:
 2303              		.cfi_def_cfa_offset 8
 2304              		.cfi_offset 7, -8
 2305              		.cfi_offset 14, -4
 2306 0002 84B0     		sub	sp, sp, #16
 2307              	.LCFI70:
 2308              		.cfi_def_cfa_offset 24
 2309 0004 00AF     		add	r7, sp, #0
 2310              	.LCFI71:
 2311              		.cfi_def_cfa_register 7
 2312 0006 7860     		str	r0, [r7, #4]
1612:Source/queue.c **** signed portBASE_TYPE xReturn;
1613:Source/queue.c **** 
1614:Source/queue.c **** 	taskENTER_CRITICAL();
 2313              		.loc 1 1614 0
 2314 0008 FFF7FEFF 		bl	vPortEnterCritical
1615:Source/queue.c **** 	{
1616:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2315              		.loc 1 1616 0
 2316 000c 7B68     		ldr	r3, [r7, #4]
 2317 000e 9A6B     		ldr	r2, [r3, #56]
 2318 0010 7B68     		ldr	r3, [r7, #4]
 2319 0012 DB6B     		ldr	r3, [r3, #60]
 2320 0014 9A42     		cmp	r2, r3
 2321 0016 02D1     		bne	.L187
1617:Source/queue.c **** 		{
1618:Source/queue.c **** 			xReturn = pdTRUE;
 2322              		.loc 1 1618 0
 2323 0018 0123     		movs	r3, #1
 2324 001a FB60     		str	r3, [r7, #12]
 2325 001c 01E0     		b	.L188
 2326              	.L187:
1619:Source/queue.c **** 		}
1620:Source/queue.c **** 		else
1621:Source/queue.c **** 		{
1622:Source/queue.c **** 			xReturn = pdFALSE;
 2327              		.loc 1 1622 0
 2328 001e 0023     		movs	r3, #0
 2329 0020 FB60     		str	r3, [r7, #12]
 2330              	.L188:
1623:Source/queue.c **** 		}
1624:Source/queue.c **** 	}
1625:Source/queue.c **** 	taskEXIT_CRITICAL();
 2331              		.loc 1 1625 0
 2332 0022 FFF7FEFF 		bl	vPortExitCritical
1626:Source/queue.c **** 
1627:Source/queue.c **** 	return xReturn;
 2333              		.loc 1 1627 0
 2334 0026 FB68     		ldr	r3, [r7, #12]
1628:Source/queue.c **** }
 2335              		.loc 1 1628 0
 2336 0028 1846     		mov	r0, r3
 2337 002a 1037     		adds	r7, r7, #16
 2338 002c BD46     		mov	sp, r7
 2339              		@ sp needed
 2340 002e 80BD     		pop	{r7, pc}
 2341              		.cfi_endproc
 2342              	.LFE133:
 2344              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2345              		.align	2
 2346              		.global	xQueueIsQueueFullFromISR
 2347              		.thumb
 2348              		.thumb_func
 2350              	xQueueIsQueueFullFromISR:
 2351              	.LFB134:
1629:Source/queue.c **** /*-----------------------------------------------------------*/
1630:Source/queue.c **** 
1631:Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
1632:Source/queue.c **** {
 2352              		.loc 1 1632 0
 2353              		.cfi_startproc
 2354              		@ args = 0, pretend = 0, frame = 16
 2355              		@ frame_needed = 1, uses_anonymous_args = 0
 2356 0000 80B5     		push	{r7, lr}
 2357              	.LCFI72:
 2358              		.cfi_def_cfa_offset 8
 2359              		.cfi_offset 7, -8
 2360              		.cfi_offset 14, -4
 2361 0002 84B0     		sub	sp, sp, #16
 2362              	.LCFI73:
 2363              		.cfi_def_cfa_offset 24
 2364 0004 00AF     		add	r7, sp, #0
 2365              	.LCFI74:
 2366              		.cfi_def_cfa_register 7
 2367 0006 7860     		str	r0, [r7, #4]
1633:Source/queue.c **** signed portBASE_TYPE xReturn;
1634:Source/queue.c **** 
1635:Source/queue.c **** 	configASSERT( xQueue );
 2368              		.loc 1 1635 0
 2369 0008 7B68     		ldr	r3, [r7, #4]
 2370 000a 002B     		cmp	r3, #0
 2371 000c 02D1     		bne	.L191
 2372              		.loc 1 1635 0 is_stmt 0 discriminator 1
 2373 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2374              	.L192:
 2375 0012 FEE7     		b	.L192
 2376              	.L191:
1636:Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 2377              		.loc 1 1636 0 is_stmt 1
 2378 0014 7B68     		ldr	r3, [r7, #4]
 2379 0016 9A6B     		ldr	r2, [r3, #56]
 2380 0018 7B68     		ldr	r3, [r7, #4]
 2381 001a DB6B     		ldr	r3, [r3, #60]
 2382 001c 9A42     		cmp	r2, r3
 2383 001e 02D1     		bne	.L193
1637:Source/queue.c **** 	{
1638:Source/queue.c **** 		xReturn = pdTRUE;
 2384              		.loc 1 1638 0
 2385 0020 0123     		movs	r3, #1
 2386 0022 FB60     		str	r3, [r7, #12]
 2387 0024 01E0     		b	.L194
 2388              	.L193:
1639:Source/queue.c **** 	}
1640:Source/queue.c **** 	else
1641:Source/queue.c **** 	{
1642:Source/queue.c **** 		xReturn = pdFALSE;
 2389              		.loc 1 1642 0
 2390 0026 0023     		movs	r3, #0
 2391 0028 FB60     		str	r3, [r7, #12]
 2392              	.L194:
1643:Source/queue.c **** 	}
1644:Source/queue.c **** 
1645:Source/queue.c **** 	return xReturn;
 2393              		.loc 1 1645 0
 2394 002a FB68     		ldr	r3, [r7, #12]
1646:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2395              		.loc 1 1646 0
 2396 002c 1846     		mov	r0, r3
 2397 002e 1037     		adds	r7, r7, #16
 2398 0030 BD46     		mov	sp, r7
 2399              		@ sp needed
 2400 0032 80BD     		pop	{r7, pc}
 2401              		.cfi_endproc
 2402              	.LFE134:
 2404              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2405              		.align	2
 2406              		.global	vQueueAddToRegistry
 2407              		.thumb
 2408              		.thumb_func
 2410              	vQueueAddToRegistry:
 2411              	.LFB135:
1647:Source/queue.c **** /*-----------------------------------------------------------*/
1648:Source/queue.c **** 
1649:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1650:Source/queue.c **** 
1651:Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xT
1652:Source/queue.c **** 	{
1653:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1654:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1655:Source/queue.c **** 
1656:Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1657:Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
1658:Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1659:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1660:Source/queue.c **** 		{
1661:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1662:Source/queue.c **** 			{
1663:Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
1664:Source/queue.c **** 				posting? */
1665:Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1666:Source/queue.c **** 				{
1667:Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1668:Source/queue.c **** 					return indicating that we need to block. */
1669:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1670:Source/queue.c **** 					portENABLE_INTERRUPTS();
1671:Source/queue.c **** 					return errQUEUE_BLOCKED;
1672:Source/queue.c **** 				}
1673:Source/queue.c **** 				else
1674:Source/queue.c **** 				{
1675:Source/queue.c **** 					portENABLE_INTERRUPTS();
1676:Source/queue.c **** 					return errQUEUE_FULL;
1677:Source/queue.c **** 				}
1678:Source/queue.c **** 			}
1679:Source/queue.c **** 		}
1680:Source/queue.c **** 		portENABLE_INTERRUPTS();
1681:Source/queue.c **** 
1682:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1683:Source/queue.c **** 		{
1684:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1685:Source/queue.c **** 			{
1686:Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1687:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1688:Source/queue.c **** 				xReturn = pdPASS;
1689:Source/queue.c **** 
1690:Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1691:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1692:Source/queue.c **** 				{
1693:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1694:Source/queue.c **** 					into the ready list as we are within a critical section.
1695:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1696:Source/queue.c **** 					the event were caused from within an interrupt. */
1697:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1698:Source/queue.c **** 					{
1699:Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
1700:Source/queue.c **** 						that a yield might be appropriate. */
1701:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1702:Source/queue.c **** 					}
1703:Source/queue.c **** 				}
1704:Source/queue.c **** 			}
1705:Source/queue.c **** 			else
1706:Source/queue.c **** 			{
1707:Source/queue.c **** 				xReturn = errQUEUE_FULL;
1708:Source/queue.c **** 			}
1709:Source/queue.c **** 		}
1710:Source/queue.c **** 		portENABLE_INTERRUPTS();
1711:Source/queue.c **** 
1712:Source/queue.c **** 		return xReturn;
1713:Source/queue.c **** 	}
1714:Source/queue.c **** 
1715:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1716:Source/queue.c **** /*-----------------------------------------------------------*/
1717:Source/queue.c **** 
1718:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1719:Source/queue.c **** 
1720:Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWa
1721:Source/queue.c **** 	{
1722:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1723:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1724:Source/queue.c **** 
1725:Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1726:Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
1727:Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1728:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1729:Source/queue.c **** 		{
1730:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1731:Source/queue.c **** 			{
1732:Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1733:Source/queue.c **** 				leave with nothing? */
1734:Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1735:Source/queue.c **** 				{
1736:Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
1737:Source/queue.c **** 					indicating that we need to block. */
1738:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1739:Source/queue.c **** 					portENABLE_INTERRUPTS();
1740:Source/queue.c **** 					return errQUEUE_BLOCKED;
1741:Source/queue.c **** 				}
1742:Source/queue.c **** 				else
1743:Source/queue.c **** 				{
1744:Source/queue.c **** 					portENABLE_INTERRUPTS();
1745:Source/queue.c **** 					return errQUEUE_FULL;
1746:Source/queue.c **** 				}
1747:Source/queue.c **** 			}
1748:Source/queue.c **** 		}
1749:Source/queue.c **** 		portENABLE_INTERRUPTS();
1750:Source/queue.c **** 
1751:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1752:Source/queue.c **** 		{
1753:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1754:Source/queue.c **** 			{
1755:Source/queue.c **** 				/* Data is available from the queue. */
1756:Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1757:Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1758:Source/queue.c **** 				{
1759:Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
1760:Source/queue.c **** 				}
1761:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
1762:Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
1763:Source/queue.c **** 
1764:Source/queue.c **** 				xReturn = pdPASS;
1765:Source/queue.c **** 
1766:Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
1767:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1768:Source/queue.c **** 				{
1769:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1770:Source/queue.c **** 					into the ready list as we are within a critical section.
1771:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1772:Source/queue.c **** 					the event were caused from within an interrupt. */
1773:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1774:Source/queue.c **** 					{
1775:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1776:Source/queue.c **** 					}
1777:Source/queue.c **** 				}
1778:Source/queue.c **** 			}
1779:Source/queue.c **** 			else
1780:Source/queue.c **** 			{
1781:Source/queue.c **** 				xReturn = pdFAIL;
1782:Source/queue.c **** 			}
1783:Source/queue.c **** 		}
1784:Source/queue.c **** 		portENABLE_INTERRUPTS();
1785:Source/queue.c **** 
1786:Source/queue.c **** 		return xReturn;
1787:Source/queue.c **** 	}
1788:Source/queue.c **** 
1789:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1790:Source/queue.c **** /*-----------------------------------------------------------*/
1791:Source/queue.c **** 
1792:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1793:Source/queue.c **** 
1794:Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed p
1795:Source/queue.c **** 	{
1796:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1797:Source/queue.c **** 
1798:Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
1799:Source/queue.c **** 		exit without doing anything. */
1800:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1801:Source/queue.c **** 		{
1802:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1803:Source/queue.c **** 
1804:Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
1805:Source/queue.c **** 			co-routine has not already been woken. */
1806:Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
1807:Source/queue.c **** 			{
1808:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1809:Source/queue.c **** 				{
1810:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1811:Source/queue.c **** 					{
1812:Source/queue.c **** 						return pdTRUE;
1813:Source/queue.c **** 					}
1814:Source/queue.c **** 				}
1815:Source/queue.c **** 			}
1816:Source/queue.c **** 		}
1817:Source/queue.c **** 
1818:Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
1819:Source/queue.c **** 	}
1820:Source/queue.c **** 
1821:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1822:Source/queue.c **** /*-----------------------------------------------------------*/
1823:Source/queue.c **** 
1824:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1825:Source/queue.c **** 
1826:Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_
1827:Source/queue.c **** 	{
1828:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1829:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1830:Source/queue.c **** 
1831:Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
1832:Source/queue.c **** 		not then just leave without doing anything. */
1833:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1834:Source/queue.c **** 		{
1835:Source/queue.c **** 			/* Copy the data from the queue. */
1836:Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1837:Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1838:Source/queue.c **** 			{
1839:Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
1840:Source/queue.c **** 			}
1841:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1842:Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
1843:Source/queue.c **** 
1844:Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
1845:Source/queue.c **** 			{
1846:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1847:Source/queue.c **** 				{
1848:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1849:Source/queue.c **** 					{
1850:Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
1851:Source/queue.c **** 					}
1852:Source/queue.c **** 				}
1853:Source/queue.c **** 			}
1854:Source/queue.c **** 
1855:Source/queue.c **** 			xReturn = pdPASS;
1856:Source/queue.c **** 		}
1857:Source/queue.c **** 		else
1858:Source/queue.c **** 		{
1859:Source/queue.c **** 			xReturn = pdFAIL;
1860:Source/queue.c **** 		}
1861:Source/queue.c **** 
1862:Source/queue.c **** 		return xReturn;
1863:Source/queue.c **** 	}
1864:Source/queue.c **** 
1865:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1866:Source/queue.c **** /*-----------------------------------------------------------*/
1867:Source/queue.c **** 
1868:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1869:Source/queue.c **** 
1870:Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1871:Source/queue.c **** 	{
 2412              		.loc 1 1871 0
 2413              		.cfi_startproc
 2414              		@ args = 0, pretend = 0, frame = 16
 2415              		@ frame_needed = 1, uses_anonymous_args = 0
 2416              		@ link register save eliminated.
 2417 0000 80B4     		push	{r7}
 2418              	.LCFI75:
 2419              		.cfi_def_cfa_offset 4
 2420              		.cfi_offset 7, -4
 2421 0002 85B0     		sub	sp, sp, #20
 2422              	.LCFI76:
 2423              		.cfi_def_cfa_offset 24
 2424 0004 00AF     		add	r7, sp, #0
 2425              	.LCFI77:
 2426              		.cfi_def_cfa_register 7
 2427 0006 7860     		str	r0, [r7, #4]
 2428 0008 3960     		str	r1, [r7]
1872:Source/queue.c **** 	unsigned portBASE_TYPE ux;
1873:Source/queue.c **** 
1874:Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1875:Source/queue.c **** 		a free slot. */
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2429              		.loc 1 1876 0
 2430 000a 0023     		movs	r3, #0
 2431 000c FB60     		str	r3, [r7, #12]
 2432 000e 14E0     		b	.L197
 2433              	.L200:
1877:Source/queue.c **** 		{
1878:Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2434              		.loc 1 1878 0
 2435 0010 0E4B     		ldr	r3, .L201
 2436 0012 FA68     		ldr	r2, [r7, #12]
 2437 0014 53F83230 		ldr	r3, [r3, r2, lsl #3]
 2438 0018 002B     		cmp	r3, #0
 2439 001a 0BD1     		bne	.L198
1879:Source/queue.c **** 			{
1880:Source/queue.c **** 				/* Store the information on this queue. */
1881:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2440              		.loc 1 1881 0
 2441 001c 0B4B     		ldr	r3, .L201
 2442 001e FA68     		ldr	r2, [r7, #12]
 2443 0020 3968     		ldr	r1, [r7]
 2444 0022 43F83210 		str	r1, [r3, r2, lsl #3]
1882:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2445              		.loc 1 1882 0
 2446 0026 094A     		ldr	r2, .L201
 2447 0028 FB68     		ldr	r3, [r7, #12]
 2448 002a DB00     		lsls	r3, r3, #3
 2449 002c 1344     		add	r3, r3, r2
 2450 002e 7A68     		ldr	r2, [r7, #4]
 2451 0030 5A60     		str	r2, [r3, #4]
1883:Source/queue.c **** 				break;
 2452              		.loc 1 1883 0
 2453 0032 05E0     		b	.L196
 2454              	.L198:
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2455              		.loc 1 1876 0
 2456 0034 FB68     		ldr	r3, [r7, #12]
 2457 0036 0133     		adds	r3, r3, #1
 2458 0038 FB60     		str	r3, [r7, #12]
 2459              	.L197:
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2460              		.loc 1 1876 0 is_stmt 0 discriminator 1
 2461 003a FB68     		ldr	r3, [r7, #12]
 2462 003c 072B     		cmp	r3, #7
 2463 003e E7D9     		bls	.L200
 2464              	.L196:
1884:Source/queue.c **** 			}
1885:Source/queue.c **** 		}
1886:Source/queue.c **** 	}
 2465              		.loc 1 1886 0 is_stmt 1
 2466 0040 1437     		adds	r7, r7, #20
 2467 0042 BD46     		mov	sp, r7
 2468              		@ sp needed
 2469 0044 5DF8047B 		ldr	r7, [sp], #4
 2470 0048 7047     		bx	lr
 2471              	.L202:
 2472 004a 00BF     		.align	2
 2473              	.L201:
 2474 004c 00000000 		.word	xQueueRegistry
 2475              		.cfi_endproc
 2476              	.LFE135:
 2478              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2479              		.align	2
 2480              		.global	vQueueUnregisterQueue
 2481              		.thumb
 2482              		.thumb_func
 2484              	vQueueUnregisterQueue:
 2485              	.LFB136:
1887:Source/queue.c **** 
1888:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1889:Source/queue.c **** /*-----------------------------------------------------------*/
1890:Source/queue.c **** 
1891:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1892:Source/queue.c **** 
1893:Source/queue.c **** 	void vQueueUnregisterQueue( xQueueHandle xQueue )
1894:Source/queue.c **** 	{
 2486              		.loc 1 1894 0
 2487              		.cfi_startproc
 2488              		@ args = 0, pretend = 0, frame = 16
 2489              		@ frame_needed = 1, uses_anonymous_args = 0
 2490              		@ link register save eliminated.
 2491 0000 80B4     		push	{r7}
 2492              	.LCFI78:
 2493              		.cfi_def_cfa_offset 4
 2494              		.cfi_offset 7, -4
 2495 0002 85B0     		sub	sp, sp, #20
 2496              	.LCFI79:
 2497              		.cfi_def_cfa_offset 24
 2498 0004 00AF     		add	r7, sp, #0
 2499              	.LCFI80:
 2500              		.cfi_def_cfa_register 7
 2501 0006 7860     		str	r0, [r7, #4]
1895:Source/queue.c **** 	unsigned portBASE_TYPE ux;
1896:Source/queue.c **** 
1897:Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1898:Source/queue.c **** 		registry. */
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2502              		.loc 1 1899 0
 2503 0008 0023     		movs	r3, #0
 2504 000a FB60     		str	r3, [r7, #12]
 2505 000c 10E0     		b	.L204
 2506              	.L207:
1900:Source/queue.c **** 		{
1901:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2507              		.loc 1 1901 0
 2508 000e 0C4A     		ldr	r2, .L208
 2509 0010 FB68     		ldr	r3, [r7, #12]
 2510 0012 DB00     		lsls	r3, r3, #3
 2511 0014 1344     		add	r3, r3, r2
 2512 0016 5A68     		ldr	r2, [r3, #4]
 2513 0018 7B68     		ldr	r3, [r7, #4]
 2514 001a 9A42     		cmp	r2, r3
 2515 001c 05D1     		bne	.L205
1902:Source/queue.c **** 			{
1903:Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1904:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2516              		.loc 1 1904 0
 2517 001e 084B     		ldr	r3, .L208
 2518 0020 FA68     		ldr	r2, [r7, #12]
 2519 0022 0021     		movs	r1, #0
 2520 0024 43F83210 		str	r1, [r3, r2, lsl #3]
1905:Source/queue.c **** 				break;
 2521              		.loc 1 1905 0
 2522 0028 05E0     		b	.L203
 2523              	.L205:
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2524              		.loc 1 1899 0
 2525 002a FB68     		ldr	r3, [r7, #12]
 2526 002c 0133     		adds	r3, r3, #1
 2527 002e FB60     		str	r3, [r7, #12]
 2528              	.L204:
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2529              		.loc 1 1899 0 is_stmt 0 discriminator 1
 2530 0030 FB68     		ldr	r3, [r7, #12]
 2531 0032 072B     		cmp	r3, #7
 2532 0034 EBD9     		bls	.L207
 2533              	.L203:
1906:Source/queue.c **** 			}
1907:Source/queue.c **** 		}
1908:Source/queue.c **** 
1909:Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2534              		.loc 1 1909 0 is_stmt 1
 2535 0036 1437     		adds	r7, r7, #20
 2536 0038 BD46     		mov	sp, r7
 2537              		@ sp needed
 2538 003a 5DF8047B 		ldr	r7, [sp], #4
 2539 003e 7047     		bx	lr
 2540              	.L209:
 2541              		.align	2
 2542              	.L208:
 2543 0040 00000000 		.word	xQueueRegistry
 2544              		.cfi_endproc
 2545              	.LFE136:
 2547              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2548              		.align	2
 2549              		.global	vQueueWaitForMessageRestricted
 2550              		.thumb
 2551              		.thumb_func
 2553              	vQueueWaitForMessageRestricted:
 2554              	.LFB137:
1910:Source/queue.c **** 
1911:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1912:Source/queue.c **** /*-----------------------------------------------------------*/
1913:Source/queue.c **** 
1914:Source/queue.c **** #if ( configUSE_TIMERS == 1 )
1915:Source/queue.c **** 
1916:Source/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
1917:Source/queue.c **** 	{
 2555              		.loc 1 1917 0
 2556              		.cfi_startproc
 2557              		@ args = 0, pretend = 0, frame = 16
 2558              		@ frame_needed = 1, uses_anonymous_args = 0
 2559 0000 80B5     		push	{r7, lr}
 2560              	.LCFI81:
 2561              		.cfi_def_cfa_offset 8
 2562              		.cfi_offset 7, -8
 2563              		.cfi_offset 14, -4
 2564 0002 84B0     		sub	sp, sp, #16
 2565              	.LCFI82:
 2566              		.cfi_def_cfa_offset 24
 2567 0004 00AF     		add	r7, sp, #0
 2568              	.LCFI83:
 2569              		.cfi_def_cfa_register 7
 2570 0006 7860     		str	r0, [r7, #4]
 2571 0008 3960     		str	r1, [r7]
1918:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 2572              		.loc 1 1918 0
 2573 000a 7B68     		ldr	r3, [r7, #4]
 2574 000c FB60     		str	r3, [r7, #12]
1919:Source/queue.c **** 
1920:Source/queue.c **** 		/* This function should not be called by application code hence the
1921:Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1922:Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1923:Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
1924:Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1925:Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1926:Source/queue.c **** 		section. */
1927:Source/queue.c **** 
1928:Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1929:Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1930:Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1931:Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1932:Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1933:Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1934:Source/queue.c **** 		prvLockQueue( pxQueue );
 2575              		.loc 1 1934 0
 2576 000e FFF7FEFF 		bl	vPortEnterCritical
 2577 0012 FB68     		ldr	r3, [r7, #12]
 2578 0014 5B6C     		ldr	r3, [r3, #68]
 2579 0016 B3F1FF3F 		cmp	r3, #-1
 2580 001a 02D1     		bne	.L211
 2581              		.loc 1 1934 0 is_stmt 0 discriminator 1
 2582 001c FB68     		ldr	r3, [r7, #12]
 2583 001e 0022     		movs	r2, #0
 2584 0020 5A64     		str	r2, [r3, #68]
 2585              	.L211:
 2586              		.loc 1 1934 0 discriminator 2
 2587 0022 FB68     		ldr	r3, [r7, #12]
 2588 0024 9B6C     		ldr	r3, [r3, #72]
 2589 0026 B3F1FF3F 		cmp	r3, #-1
 2590 002a 02D1     		bne	.L212
 2591              		.loc 1 1934 0 discriminator 1
 2592 002c FB68     		ldr	r3, [r7, #12]
 2593 002e 0022     		movs	r2, #0
 2594 0030 9A64     		str	r2, [r3, #72]
 2595              	.L212:
 2596              		.loc 1 1934 0 discriminator 2
 2597 0032 FFF7FEFF 		bl	vPortExitCritical
1935:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 2598              		.loc 1 1935 0 is_stmt 1 discriminator 2
 2599 0036 FB68     		ldr	r3, [r7, #12]
 2600 0038 9B6B     		ldr	r3, [r3, #56]
 2601 003a 002B     		cmp	r3, #0
 2602 003c 05D1     		bne	.L213
1936:Source/queue.c **** 		{
1937:Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1938:Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2603              		.loc 1 1938 0
 2604 003e FB68     		ldr	r3, [r7, #12]
 2605 0040 2433     		adds	r3, r3, #36
 2606 0042 1846     		mov	r0, r3
 2607 0044 3968     		ldr	r1, [r7]
 2608 0046 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 2609              	.L213:
1939:Source/queue.c **** 		}
1940:Source/queue.c **** 		prvUnlockQueue( pxQueue );
 2610              		.loc 1 1940 0
 2611 004a F868     		ldr	r0, [r7, #12]
 2612 004c FFF7FEFF 		bl	prvUnlockQueue
1941:Source/queue.c **** 	}
 2613              		.loc 1 1941 0
 2614 0050 1037     		adds	r7, r7, #16
 2615 0052 BD46     		mov	sp, r7
 2616              		@ sp needed
 2617 0054 80BD     		pop	{r7, pc}
 2618              		.cfi_endproc
 2619              	.LFE137:
 2621 0056 00BF     		.text
 2622              	.Letext0:
 2623              		.file 2 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/lib/gcc/arm-none-eabi/4.8.3/includ
 2624              		.file 3 "/home/shihyu/data/STM32F4/gcc-arm-none-eabi-4_8-2013q4/arm-none-eabi/include/stdint.h"
 2625              		.file 4 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 2626              		.file 5 "Source/include/list.h"
 2627              		.file 6 "Source/include/task.h"
 2628              		.file 7 "Source/include/queue.h"
 2629              		.file 8 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
     /tmp/cca9Fx8e.s:21     .text.xQueueGenericReset:00000000 $t
     /tmp/cca9Fx8e.s:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/cca9Fx8e.s:146    .text.xQueueGenericCreate:00000000 $t
     /tmp/cca9Fx8e.s:151    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
     /tmp/cca9Fx8e.s:250    .text.xQueueCreateMutex:00000000 $t
     /tmp/cca9Fx8e.s:255    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/cca9Fx8e.s:592    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/cca9Fx8e.s:360    .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/cca9Fx8e.s:365    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/cca9Fx8e.s:442    .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/cca9Fx8e.s:447    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/cca9Fx8e.s:1006   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/cca9Fx8e.s:527    .text.xQueueCreateCountingSemaphore:00000000 $t
     /tmp/cca9Fx8e.s:532    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
     /tmp/cca9Fx8e.s:587    .text.xQueueGenericSend:00000000 $t
     /tmp/cca9Fx8e.s:1852   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/cca9Fx8e.s:2295   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/cca9Fx8e.s:2066   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/cca9Fx8e.s:832    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/cca9Fx8e.s:837    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/cca9Fx8e.s:1001   .text.xQueueGenericReceive:00000000 $t
     /tmp/cca9Fx8e.s:1998   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/cca9Fx8e.s:2185   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/cca9Fx8e.s:1274   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/cca9Fx8e.s:1279   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/cca9Fx8e.s:1415   .text.xQueuePeekFromISR:00000000 $t
     /tmp/cca9Fx8e.s:1420   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/cca9Fx8e.s:1522   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/cca9Fx8e.s:1527   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/cca9Fx8e.s:1574   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/cca9Fx8e.s:1579   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/cca9Fx8e.s:1632   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/cca9Fx8e.s:1637   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/cca9Fx8e.s:1680   .text.vQueueDelete:00000000 $t
     /tmp/cca9Fx8e.s:1685   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/cca9Fx8e.s:2484   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/cca9Fx8e.s:1735   .text.ucQueueGetQueueNumber:00000000 $t
     /tmp/cca9Fx8e.s:1740   .text.ucQueueGetQueueNumber:00000000 ucQueueGetQueueNumber
     /tmp/cca9Fx8e.s:1772   .text.vQueueSetQueueNumber:00000000 $t
     /tmp/cca9Fx8e.s:1777   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
     /tmp/cca9Fx8e.s:1811   .text.ucQueueGetQueueType:00000000 $t
     /tmp/cca9Fx8e.s:1816   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
     /tmp/cca9Fx8e.s:1848   .text.prvCopyDataToQueue:00000000 $t
     /tmp/cca9Fx8e.s:1994   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/cca9Fx8e.s:2062   .text.prvUnlockQueue:00000000 $t
     /tmp/cca9Fx8e.s:2181   .text.prvIsQueueEmpty:00000000 $t
     /tmp/cca9Fx8e.s:2233   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/cca9Fx8e.s:2238   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/cca9Fx8e.s:2291   .text.prvIsQueueFull:00000000 $t
     /tmp/cca9Fx8e.s:2345   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/cca9Fx8e.s:2350   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/cca9Fx8e.s:2405   .text.vQueueAddToRegistry:00000000 $t
     /tmp/cca9Fx8e.s:2410   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/cca9Fx8e.s:2474   .text.vQueueAddToRegistry:0000004c $d
     /tmp/cca9Fx8e.s:2479   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/cca9Fx8e.s:2543   .text.vQueueUnregisterQueue:00000040 $d
     /tmp/cca9Fx8e.s:2548   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/cca9Fx8e.s:2553   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
vPortEnterCritical
xTaskRemoveFromEventList
vPortYield
vListInitialise
vPortExitCritical
pvPortMalloc
vPortFree
xTaskGetCurrentTaskHandle
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
vPortClearInterruptMask
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
